//
//  FileGenerator.swift
//  buf-gen-swift
//
//  Created by Khaled Chehabeddine on 10/01/2026.
//  Copyright Â© 2026 Sebuf. All rights reserved.
//

import Foundation
import SwiftProtobuf
import SwiftProtobufPluginLibrary

internal final class FileGenerator {
	
	private let descriptor: FileDescriptor
	private let options: GeneratorOptions
	private let namer: SwiftProtobufNamer
	
	internal init(descriptor: FileDescriptor, options: GeneratorOptions) {
		self.descriptor = descriptor
		self.options = options
		self.namer = SwiftProtobufNamer(currentFile: descriptor, protoFileToModuleMappings: options.protoToModuleMappings)
	}
	
	internal var name: String {
		let ext = ".sebuf.swift"
		let pathComponents = descriptor.name.pathComponents
		switch options.fileNaming {
		case .fullPath: return pathComponents.directory + pathComponents.base + ext
		case .pathToUnderscores:
			let directoryUnderscored = pathComponents.directory.replacingOccurrences(of: "/", with: "_")
			return directoryUnderscored + pathComponents.base + ext
		case .dropPath: return pathComponents.base + ext
		}
	}
	
	internal func generate(printer p: inout CodePrinter) throws(GeneratorError) {
		guard descriptor.options.swiftPrefix.isEmpty
				|| isValidSwiftIdentifier(descriptor.options.swiftPrefix, allowQuoted: false) else {
			throw .invalidSwiftPrefix(filename: descriptor.name, prefix: descriptor.options.swiftPrefix)
		}
		p.print(
			"""
			// DO NOT EDIT.
			// swift-format-ignore-file
			// swiftlint:disable all
			//
			// Generated by the Sebuf generator plugin for the buf compiler.
			// Source: \(descriptor.name)
			//
			// For information on using the generated types, please see the documentation:
			//   https://github.com/SebastienMelki/sebuf/
			
			"""
		)
		
		// Generate the comments from the top of the .proto file as they may contain copyrights/preamble/etc.
		if options.experimentalStripNonfunctionalCodegen {
			let editionPath = IndexPath(index: Google_Protobuf_FileDescriptorProto.FieldNumbers.edition)
			let syntaxPath = IndexPath(index: Google_Protobuf_FileDescriptorProto.FieldNumbers.syntax)
			let commentLocation: Google_Protobuf_SourceCodeInfo.Location? = if let location = descriptor.sourceCodeInfoLocation(
				path: editionPath
			) {
				location
			} else if let location = descriptor.sourceCodeInfoLocation(path: syntaxPath) {
				location
			} else {
				nil
			}
			if let commentLocation {
				let comments = commentLocation.asSourceComment(commentPrefix: "///", leadingDetachedPrefix: "//")
				if !comments.isEmpty {
					// Ensure there is a blank line between the .proto comments and generated code
					p.print(comments, newlines: !comments.hasSuffix("\n\n"))
				}
			}
		}
		
		let fileDefinesTypes = !descriptor.services.isEmpty
		
		if SwiftProtobufInfo.isBundledProto(file: descriptor) {
			p.print(
				"// 'import \(namer.swiftProtobufModuleName)' suppressed, this proto file is meant to be bundled in the runtime.\n"
			)
		} else if fileDefinesTypes {
			p.print("\(options.importDirective.snippet) \(namer.swiftProtobufModuleName)\n")
		}
		
		guard fileDefinesTypes else {
			p.print("// This file contained no services.")
			return
		}
		
		generateVersionCheck(printer: &p)
		
		for serviceDescriptor in descriptor.services {
			let serviceGenerator = ServiceGenerator(descriptor: serviceDescriptor, options: options, namer: namer)
			serviceGenerator.generate(printer: &p)
		}
	}
	
	private func generateVersionCheck(printer p: inout CodePrinter) {
		let v = Version.compatibility
		p.print(
			"""
			// If the compiler emits an error on this type, it is because this file
			// was generated by a version of the `protoc` Swift plug-in that is
			// incompatible with the version of SwiftProtobuf to which you are linking.
			// Please ensure that you are building against the same version of the API
			// that was used to generate this file.
			fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
			"""
		)
		p.printIndented(
			"""
			struct _\(v): SwiftProtobuf.ProtobufAPIVersion_\(v) {}
			typealias Version = _\(v)
			"""
		)
		p.print("}")
	}
}
