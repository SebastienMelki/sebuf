
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>http: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/SebastienMelki/sebuf/http/annotations.pb.go (7.9%)</option>
				
				<option value="file1">github.com/SebastienMelki/sebuf/http/errors.pb.go (24.2%)</option>
				
				<option value="file2">github.com/SebastienMelki/sebuf/http/errors_impl.go (100.0%)</option>
				
				<option value="file3">github.com/SebastienMelki/sebuf/http/headers.pb.go (9.1%)</option>
				
				<option value="file4">github.com/SebastienMelki/sebuf/internal/httpgen/annotations.go (15.7%)</option>
				
				<option value="file5">github.com/SebastienMelki/sebuf/internal/httpgen/generator.go (1.4%)</option>
				
				<option value="file6">github.com/SebastienMelki/sebuf/internal/httpgen/mock_generator.go (0.0%)</option>
				
				<option value="file7">github.com/SebastienMelki/sebuf/internal/httpgen/validation.go (0.0%)</option>
				
				<option value="file8">github.com/SebastienMelki/sebuf/internal/openapiv3/generator.go (12.6%)</option>
				
				<option value="file9">github.com/SebastienMelki/sebuf/internal/openapiv3/http_annotations.go (40.1%)</option>
				
				<option value="file10">github.com/SebastienMelki/sebuf/internal/openapiv3/types.go (0.0%)</option>
				
				<option value="file11">github.com/SebastienMelki/sebuf/internal/openapiv3/validation.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.9
//         protoc        v5.29.2
// source: proto/sebuf/http/annotations.proto

package http

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        descriptorpb "google.golang.org/protobuf/types/descriptorpb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// HttpMethod specifies the HTTP verb for an RPC method
type HttpMethod int32

const (
        // Unspecified defaults to POST for backward compatibility
        HttpMethod_HTTP_METHOD_UNSPECIFIED HttpMethod = 0
        HttpMethod_HTTP_METHOD_GET         HttpMethod = 1
        HttpMethod_HTTP_METHOD_POST        HttpMethod = 2
        HttpMethod_HTTP_METHOD_PUT         HttpMethod = 3
        HttpMethod_HTTP_METHOD_DELETE      HttpMethod = 4
        HttpMethod_HTTP_METHOD_PATCH       HttpMethod = 5
)

// Enum value maps for HttpMethod.
var (
        HttpMethod_name = map[int32]string{
                0: "HTTP_METHOD_UNSPECIFIED",
                1: "HTTP_METHOD_GET",
                2: "HTTP_METHOD_POST",
                3: "HTTP_METHOD_PUT",
                4: "HTTP_METHOD_DELETE",
                5: "HTTP_METHOD_PATCH",
        }
        HttpMethod_value = map[string]int32{
                "HTTP_METHOD_UNSPECIFIED": 0,
                "HTTP_METHOD_GET":         1,
                "HTTP_METHOD_POST":        2,
                "HTTP_METHOD_PUT":         3,
                "HTTP_METHOD_DELETE":      4,
                "HTTP_METHOD_PATCH":       5,
        }
)

func (x HttpMethod) Enum() *HttpMethod <span class="cov0" title="0">{
        p := new(HttpMethod)
        *p = x
        return p
}</span>

func (x HttpMethod) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (HttpMethod) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_proto_sebuf_http_annotations_proto_enumTypes[0].Descriptor()
}</span>

func (HttpMethod) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_proto_sebuf_http_annotations_proto_enumTypes[0]
}</span>

func (x HttpMethod) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use HttpMethod.Descriptor instead.
func (HttpMethod) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_annotations_proto_rawDescGZIP(), []int{0}
}</span>

// HttpConfig defines HTTP-specific configuration for an RPC method
type HttpConfig struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // The HTTP path for this method (supports path variables like /users/{id})
        Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
        // The HTTP method (GET, POST, PUT, DELETE, PATCH). Defaults to POST if unspecified.
        Method        HttpMethod `protobuf:"varint,2,opt,name=method,proto3,enum=sebuf.http.HttpMethod" json:"method,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *HttpConfig) Reset() <span class="cov0" title="0">{
        *x = HttpConfig{}
        mi := &amp;file_proto_sebuf_http_annotations_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *HttpConfig) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*HttpConfig) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *HttpConfig) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_sebuf_http_annotations_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use HttpConfig.ProtoReflect.Descriptor instead.
func (*HttpConfig) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_annotations_proto_rawDescGZIP(), []int{0}
}</span>

func (x *HttpConfig) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HttpConfig) GetMethod() HttpMethod <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Method
        }</span>
        <span class="cov0" title="0">return HttpMethod_HTTP_METHOD_UNSPECIFIED</span>
}

// ServiceConfig defines HTTP-specific configuration for an entire service
type ServiceConfig struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // Base path prefix for all methods in this service
        BasePath      string `protobuf:"bytes,1,opt,name=base_path,json=basePath,proto3" json:"base_path,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ServiceConfig) Reset() <span class="cov0" title="0">{
        *x = ServiceConfig{}
        mi := &amp;file_proto_sebuf_http_annotations_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ServiceConfig) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ServiceConfig) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ServiceConfig) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_sebuf_http_annotations_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ServiceConfig.ProtoReflect.Descriptor instead.
func (*ServiceConfig) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_annotations_proto_rawDescGZIP(), []int{1}
}</span>

func (x *ServiceConfig) GetBasePath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BasePath
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// FieldExamples defines example values for a field
type FieldExamples struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // List of example values for this field
        Values        []string `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *FieldExamples) Reset() <span class="cov0" title="0">{
        *x = FieldExamples{}
        mi := &amp;file_proto_sebuf_http_annotations_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *FieldExamples) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FieldExamples) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FieldExamples) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_sebuf_http_annotations_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FieldExamples.ProtoReflect.Descriptor instead.
func (*FieldExamples) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_annotations_proto_rawDescGZIP(), []int{2}
}</span>

func (x *FieldExamples) GetValues() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Values
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// QueryConfig defines query parameter configuration for a message field
type QueryConfig struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // The query parameter name in the URL (e.g., "page_size" for ?page_size=10)
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Whether this query parameter is required
        Required      bool `protobuf:"varint,2,opt,name=required,proto3" json:"required,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *QueryConfig) Reset() <span class="cov0" title="0">{
        *x = QueryConfig{}
        mi := &amp;file_proto_sebuf_http_annotations_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *QueryConfig) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*QueryConfig) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *QueryConfig) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_sebuf_http_annotations_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use QueryConfig.ProtoReflect.Descriptor instead.
func (*QueryConfig) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_annotations_proto_rawDescGZIP(), []int{3}
}</span>

func (x *QueryConfig) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *QueryConfig) GetRequired() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Required
        }</span>
        <span class="cov0" title="0">return false</span>
}

var file_proto_sebuf_http_annotations_proto_extTypes = []protoimpl.ExtensionInfo{
        {
                ExtendedType:  (*descriptorpb.MethodOptions)(nil),
                ExtensionType: (*HttpConfig)(nil),
                Field:         50003,
                Name:          "sebuf.http.config",
                Tag:           "bytes,50003,opt,name=config",
                Filename:      "proto/sebuf/http/annotations.proto",
        },
        {
                ExtendedType:  (*descriptorpb.ServiceOptions)(nil),
                ExtensionType: (*ServiceConfig)(nil),
                Field:         50004,
                Name:          "sebuf.http.service_config",
                Tag:           "bytes,50004,opt,name=service_config",
                Filename:      "proto/sebuf/http/annotations.proto",
        },
        {
                ExtendedType:  (*descriptorpb.FieldOptions)(nil),
                ExtensionType: (*FieldExamples)(nil),
                Field:         50007,
                Name:          "sebuf.http.field_examples",
                Tag:           "bytes,50007,opt,name=field_examples",
                Filename:      "proto/sebuf/http/annotations.proto",
        },
        {
                ExtendedType:  (*descriptorpb.FieldOptions)(nil),
                ExtensionType: (*QueryConfig)(nil),
                Field:         50008,
                Name:          "sebuf.http.query",
                Tag:           "bytes,50008,opt,name=query",
                Filename:      "proto/sebuf/http/annotations.proto",
        },
}

// Extension fields to descriptorpb.MethodOptions.
var (
        // optional sebuf.http.HttpConfig config = 50003;
        E_Config = &amp;file_proto_sebuf_http_annotations_proto_extTypes[0]
)

// Extension fields to descriptorpb.ServiceOptions.
var (
        // optional sebuf.http.ServiceConfig service_config = 50004;
        E_ServiceConfig = &amp;file_proto_sebuf_http_annotations_proto_extTypes[1]
)

// Extension fields to descriptorpb.FieldOptions.
var (
        // Example values for documentation/OpenAPI
        //
        // optional sebuf.http.FieldExamples field_examples = 50007;
        E_FieldExamples = &amp;file_proto_sebuf_http_annotations_proto_extTypes[2]
        // Query parameter configuration for a field
        //
        // optional sebuf.http.QueryConfig query = 50008;
        E_Query = &amp;file_proto_sebuf_http_annotations_proto_extTypes[3]
)

var File_proto_sebuf_http_annotations_proto protoreflect.FileDescriptor

const file_proto_sebuf_http_annotations_proto_rawDesc = "" +
        "\n" +
        "\"proto/sebuf/http/annotations.proto\x12\n" +
        "sebuf.http\x1a google/protobuf/descriptor.proto\"P\n" +
        "\n" +
        "HttpConfig\x12\x12\n" +
        "\x04path\x18\x01 \x01(\tR\x04path\x12.\n" +
        "\x06method\x18\x02 \x01(\x0e2\x16.sebuf.http.HttpMethodR\x06method\",\n" +
        "\rServiceConfig\x12\x1b\n" +
        "\tbase_path\x18\x01 \x01(\tR\bbasePath\"'\n" +
        "\rFieldExamples\x12\x16\n" +
        "\x06values\x18\x01 \x03(\tR\x06values\"=\n" +
        "\vQueryConfig\x12\x12\n" +
        "\x04name\x18\x01 \x01(\tR\x04name\x12\x1a\n" +
        "\brequired\x18\x02 \x01(\bR\brequired*\x98\x01\n" +
        "\n" +
        "HttpMethod\x12\x1b\n" +
        "\x17HTTP_METHOD_UNSPECIFIED\x10\x00\x12\x13\n" +
        "\x0fHTTP_METHOD_GET\x10\x01\x12\x14\n" +
        "\x10HTTP_METHOD_POST\x10\x02\x12\x13\n" +
        "\x0fHTTP_METHOD_PUT\x10\x03\x12\x16\n" +
        "\x12HTTP_METHOD_DELETE\x10\x04\x12\x15\n" +
        "\x11HTTP_METHOD_PATCH\x10\x05:P\n" +
        "\x06config\x12\x1e.google.protobuf.MethodOptions\x18ӆ\x03 \x01(\v2\x16.sebuf.http.HttpConfigR\x06config:c\n" +
        "\x0eservice_config\x12\x1f.google.protobuf.ServiceOptions\x18Ԇ\x03 \x01(\v2\x19.sebuf.http.ServiceConfigR\rserviceConfig:a\n" +
        "\x0efield_examples\x12\x1d.google.protobuf.FieldOptions\x18׆\x03 \x01(\v2\x19.sebuf.http.FieldExamplesR\rfieldExamples:N\n" +
        "\x05query\x12\x1d.google.protobuf.FieldOptions\x18؆\x03 \x01(\v2\x17.sebuf.http.QueryConfigR\x05queryB+Z)github.com/SebastienMelki/sebuf/http;httpb\x06proto3"

var (
        file_proto_sebuf_http_annotations_proto_rawDescOnce sync.Once
        file_proto_sebuf_http_annotations_proto_rawDescData []byte
)

func file_proto_sebuf_http_annotations_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_sebuf_http_annotations_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_sebuf_http_annotations_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_sebuf_http_annotations_proto_rawDesc), len(file_proto_sebuf_http_annotations_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_proto_sebuf_http_annotations_proto_rawDescData</span>
}

var file_proto_sebuf_http_annotations_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_proto_sebuf_http_annotations_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_proto_sebuf_http_annotations_proto_goTypes = []any{
        (HttpMethod)(0),                     // 0: sebuf.http.HttpMethod
        (*HttpConfig)(nil),                  // 1: sebuf.http.HttpConfig
        (*ServiceConfig)(nil),               // 2: sebuf.http.ServiceConfig
        (*FieldExamples)(nil),               // 3: sebuf.http.FieldExamples
        (*QueryConfig)(nil),                 // 4: sebuf.http.QueryConfig
        (*descriptorpb.MethodOptions)(nil),  // 5: google.protobuf.MethodOptions
        (*descriptorpb.ServiceOptions)(nil), // 6: google.protobuf.ServiceOptions
        (*descriptorpb.FieldOptions)(nil),   // 7: google.protobuf.FieldOptions
}
var file_proto_sebuf_http_annotations_proto_depIdxs = []int32{
        0, // 0: sebuf.http.HttpConfig.method:type_name -&gt; sebuf.http.HttpMethod
        5, // 1: sebuf.http.config:extendee -&gt; google.protobuf.MethodOptions
        6, // 2: sebuf.http.service_config:extendee -&gt; google.protobuf.ServiceOptions
        7, // 3: sebuf.http.field_examples:extendee -&gt; google.protobuf.FieldOptions
        7, // 4: sebuf.http.query:extendee -&gt; google.protobuf.FieldOptions
        1, // 5: sebuf.http.config:type_name -&gt; sebuf.http.HttpConfig
        2, // 6: sebuf.http.service_config:type_name -&gt; sebuf.http.ServiceConfig
        3, // 7: sebuf.http.field_examples:type_name -&gt; sebuf.http.FieldExamples
        4, // 8: sebuf.http.query:type_name -&gt; sebuf.http.QueryConfig
        9, // [9:9] is the sub-list for method output_type
        9, // [9:9] is the sub-list for method input_type
        5, // [5:9] is the sub-list for extension type_name
        1, // [1:5] is the sub-list for extension extendee
        0, // [0:1] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_proto_sebuf_http_annotations_proto_init() }</span>
func file_proto_sebuf_http_annotations_proto_init() <span class="cov8" title="1">{
        if File_proto_sebuf_http_annotations_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_sebuf_http_annotations_proto_rawDesc), len(file_proto_sebuf_http_annotations_proto_rawDesc)),
                        NumEnums:      1,
                        NumMessages:   4,
                        NumExtensions: 4,
                        NumServices:   0,
                },
                GoTypes:           file_proto_sebuf_http_annotations_proto_goTypes,
                DependencyIndexes: file_proto_sebuf_http_annotations_proto_depIdxs,
                EnumInfos:         file_proto_sebuf_http_annotations_proto_enumTypes,
                MessageInfos:      file_proto_sebuf_http_annotations_proto_msgTypes,
                ExtensionInfos:    file_proto_sebuf_http_annotations_proto_extTypes,
        }.Build()
        File_proto_sebuf_http_annotations_proto = out.File
        file_proto_sebuf_http_annotations_proto_goTypes = nil
        file_proto_sebuf_http_annotations_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.9
//         protoc        v5.29.2
// source: proto/sebuf/http/errors.proto

package http

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ValidationError is returned when request validation fails.
// It contains a list of field violations describing what went wrong.
type ValidationError struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // List of validation violations
        Violations    []*FieldViolation `protobuf:"bytes,1,rep,name=violations,proto3" json:"violations,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ValidationError) Reset() <span class="cov0" title="0">{
        *x = ValidationError{}
        mi := &amp;file_proto_sebuf_http_errors_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ValidationError) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ValidationError) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ValidationError) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_sebuf_http_errors_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ValidationError.ProtoReflect.Descriptor instead.
func (*ValidationError) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_errors_proto_rawDescGZIP(), []int{0}
}</span>

func (x *ValidationError) GetViolations() []*FieldViolation <span class="cov10" title="15">{
        if x != nil </span><span class="cov10" title="15">{
                return x.Violations
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Error is returned when a handler encounters an error.
// It contains a simple error message that the developer can customize.
type Error struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // Error message (e.g., "user not found", "database connection failed")
        Message       string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Error) Reset() <span class="cov0" title="0">{
        *x = Error{}
        mi := &amp;file_proto_sebuf_http_errors_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Error) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Error) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Error) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_sebuf_http_errors_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Error.ProtoReflect.Descriptor instead.
func (*Error) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_errors_proto_rawDescGZIP(), []int{1}
}</span>

func (x *Error) GetMessage() string <span class="cov7" title="8">{
        if x != nil </span><span class="cov7" title="8">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// FieldViolation describes a single validation error for a specific field.
type FieldViolation struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // The field path that failed validation (e.g., "user.email" for nested fields)
        // For header validation, this will be the header name (e.g., "X-API-Key")
        Field string `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
        // Human-readable description of the validation violation
        // (e.g., "must be a valid email address", "required field missing")
        Description   string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *FieldViolation) Reset() <span class="cov0" title="0">{
        *x = FieldViolation{}
        mi := &amp;file_proto_sebuf_http_errors_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *FieldViolation) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FieldViolation) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FieldViolation) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_sebuf_http_errors_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FieldViolation.ProtoReflect.Descriptor instead.
func (*FieldViolation) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_errors_proto_rawDescGZIP(), []int{2}
}</span>

func (x *FieldViolation) GetField() string <span class="cov6" title="6">{
        if x != nil </span><span class="cov6" title="6">{
                return x.Field
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FieldViolation) GetDescription() string <span class="cov6" title="5">{
        if x != nil </span><span class="cov6" title="5">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_proto_sebuf_http_errors_proto protoreflect.FileDescriptor

const file_proto_sebuf_http_errors_proto_rawDesc = "" +
        "\n" +
        "\x1dproto/sebuf/http/errors.proto\x12\n" +
        "sebuf.http\"M\n" +
        "\x0fValidationError\x12:\n" +
        "\n" +
        "violations\x18\x01 \x03(\v2\x1a.sebuf.http.FieldViolationR\n" +
        "violations\"!\n" +
        "\x05Error\x12\x18\n" +
        "\amessage\x18\x01 \x01(\tR\amessage\"H\n" +
        "\x0eFieldViolation\x12\x14\n" +
        "\x05field\x18\x01 \x01(\tR\x05field\x12 \n" +
        "\vdescription\x18\x02 \x01(\tR\vdescriptionB+Z)github.com/SebastienMelki/sebuf/http;httpb\x06proto3"

var (
        file_proto_sebuf_http_errors_proto_rawDescOnce sync.Once
        file_proto_sebuf_http_errors_proto_rawDescData []byte
)

func file_proto_sebuf_http_errors_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_sebuf_http_errors_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_sebuf_http_errors_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_sebuf_http_errors_proto_rawDesc), len(file_proto_sebuf_http_errors_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_proto_sebuf_http_errors_proto_rawDescData</span>
}

var file_proto_sebuf_http_errors_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_proto_sebuf_http_errors_proto_goTypes = []any{
        (*ValidationError)(nil), // 0: sebuf.http.ValidationError
        (*Error)(nil),           // 1: sebuf.http.Error
        (*FieldViolation)(nil),  // 2: sebuf.http.FieldViolation
}
var file_proto_sebuf_http_errors_proto_depIdxs = []int32{
        2, // 0: sebuf.http.ValidationError.violations:type_name -&gt; sebuf.http.FieldViolation
        1, // [1:1] is the sub-list for method output_type
        1, // [1:1] is the sub-list for method input_type
        1, // [1:1] is the sub-list for extension type_name
        1, // [1:1] is the sub-list for extension extendee
        0, // [0:1] is the sub-list for field type_name
}

func init() <span class="cov1" title="1">{ file_proto_sebuf_http_errors_proto_init() }</span>
func file_proto_sebuf_http_errors_proto_init() <span class="cov1" title="1">{
        if File_proto_sebuf_http_errors_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_sebuf_http_errors_proto_rawDesc), len(file_proto_sebuf_http_errors_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   3,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_proto_sebuf_http_errors_proto_goTypes,
                DependencyIndexes: file_proto_sebuf_http_errors_proto_depIdxs,
                MessageInfos:      file_proto_sebuf_http_errors_proto_msgTypes,
        }.Build()
        File_proto_sebuf_http_errors_proto = out.File
        file_proto_sebuf_http_errors_proto_goTypes = nil
        file_proto_sebuf_http_errors_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package http

import (
        "fmt"
        "strings"
)

// Error implements the error interface for ValidationError.
// This allows ValidationError to be used with errors.As() and errors.Is().
func (e *ValidationError) Error() string <span class="cov10" title="6">{
        if e == nil </span><span class="cov1" title="1">{
                return "validation error: &lt;nil&gt;"
        }</span>

        <span class="cov9" title="5">if len(e.GetViolations()) == 0 </span><span class="cov1" title="1">{
                return "validation error: no violations"
        }</span>

        <span class="cov7" title="4">if len(e.GetViolations()) == 1 </span><span class="cov6" title="3">{
                v := e.GetViolations()[0]
                return fmt.Sprintf("validation error: %s: %s", v.GetField(), v.GetDescription())
        }</span>

        // Multiple violations
        <span class="cov1" title="1">var violations []string
        for _, v := range e.GetViolations() </span><span class="cov4" title="2">{
                violations = append(violations, fmt.Sprintf("%s: %s", v.GetField(), v.GetDescription()))
        }</span>

        <span class="cov1" title="1">return fmt.Sprintf("validation error: [%s]", strings.Join(violations, ", "))</span>
}

// Error implements the error interface for Error.
// This allows Error to be used with errors.As() and errors.Is().
func (e *Error) Error() string <span class="cov9" title="5">{
        if e == nil </span><span class="cov1" title="1">{
                return "error: &lt;nil&gt;"
        }</span>

        <span class="cov7" title="4">if e.GetMessage() == "" </span><span class="cov1" title="1">{
                return "error: empty message"
        }</span>

        <span class="cov6" title="3">return e.GetMessage()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.9
//         protoc        v5.29.2
// source: proto/sebuf/http/headers.proto

package http

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        descriptorpb "google.golang.org/protobuf/types/descriptorpb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Header definition for OpenAPI specification
type Header struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // Name of the header parameter
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Description of the header parameter
        Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        // Type of the header parameter (string, integer, number, boolean, array)
        Type string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
        // Whether the header is required
        Required bool `protobuf:"varint,4,opt,name=required,proto3" json:"required,omitempty"`
        // Schema format (e.g. "uuid", "email", "date-time")
        Format string `protobuf:"bytes,5,opt,name=format,proto3" json:"format,omitempty"`
        // Example value for the header
        Example string `protobuf:"bytes,6,opt,name=example,proto3" json:"example,omitempty"`
        // Whether the header is deprecated
        Deprecated    bool `protobuf:"varint,7,opt,name=deprecated,proto3" json:"deprecated,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Header) Reset() <span class="cov0" title="0">{
        *x = Header{}
        mi := &amp;file_proto_sebuf_http_headers_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Header) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Header) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Header) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_sebuf_http_headers_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Header.ProtoReflect.Descriptor instead.
func (*Header) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_headers_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Header) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetRequired() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Required
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Header) GetFormat() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Format
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetExample() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Example
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetDeprecated() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Deprecated
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Service-level headers configuration
type ServiceHeaders struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // List of required headers for all RPCs in the service
        RequiredHeaders []*Header `protobuf:"bytes,1,rep,name=required_headers,json=requiredHeaders,proto3" json:"required_headers,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *ServiceHeaders) Reset() <span class="cov0" title="0">{
        *x = ServiceHeaders{}
        mi := &amp;file_proto_sebuf_http_headers_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ServiceHeaders) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ServiceHeaders) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ServiceHeaders) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_sebuf_http_headers_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ServiceHeaders.ProtoReflect.Descriptor instead.
func (*ServiceHeaders) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_headers_proto_rawDescGZIP(), []int{1}
}</span>

func (x *ServiceHeaders) GetRequiredHeaders() []*Header <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RequiredHeaders
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Method-level headers configuration
type MethodHeaders struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // List of required headers for this specific RPC
        RequiredHeaders []*Header `protobuf:"bytes,1,rep,name=required_headers,json=requiredHeaders,proto3" json:"required_headers,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *MethodHeaders) Reset() <span class="cov0" title="0">{
        *x = MethodHeaders{}
        mi := &amp;file_proto_sebuf_http_headers_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *MethodHeaders) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MethodHeaders) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MethodHeaders) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_sebuf_http_headers_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MethodHeaders.ProtoReflect.Descriptor instead.
func (*MethodHeaders) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_headers_proto_rawDescGZIP(), []int{2}
}</span>

func (x *MethodHeaders) GetRequiredHeaders() []*Header <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RequiredHeaders
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var file_proto_sebuf_http_headers_proto_extTypes = []protoimpl.ExtensionInfo{
        {
                ExtendedType:  (*descriptorpb.ServiceOptions)(nil),
                ExtensionType: (*ServiceHeaders)(nil),
                Field:         50005,
                Name:          "sebuf.http.service_headers",
                Tag:           "bytes,50005,opt,name=service_headers",
                Filename:      "proto/sebuf/http/headers.proto",
        },
        {
                ExtendedType:  (*descriptorpb.MethodOptions)(nil),
                ExtensionType: (*MethodHeaders)(nil),
                Field:         50006,
                Name:          "sebuf.http.method_headers",
                Tag:           "bytes,50006,opt,name=method_headers",
                Filename:      "proto/sebuf/http/headers.proto",
        },
}

// Extension fields to descriptorpb.ServiceOptions.
var (
        // optional sebuf.http.ServiceHeaders service_headers = 50005;
        E_ServiceHeaders = &amp;file_proto_sebuf_http_headers_proto_extTypes[0]
)

// Extension fields to descriptorpb.MethodOptions.
var (
        // optional sebuf.http.MethodHeaders method_headers = 50006;
        E_MethodHeaders = &amp;file_proto_sebuf_http_headers_proto_extTypes[1]
)

var File_proto_sebuf_http_headers_proto protoreflect.FileDescriptor

const file_proto_sebuf_http_headers_proto_rawDesc = "" +
        "\n" +
        "\x1eproto/sebuf/http/headers.proto\x12\n" +
        "sebuf.http\x1a google/protobuf/descriptor.proto\"\xc0\x01\n" +
        "\x06Header\x12\x12\n" +
        "\x04name\x18\x01 \x01(\tR\x04name\x12 \n" +
        "\vdescription\x18\x02 \x01(\tR\vdescription\x12\x12\n" +
        "\x04type\x18\x03 \x01(\tR\x04type\x12\x1a\n" +
        "\brequired\x18\x04 \x01(\bR\brequired\x12\x16\n" +
        "\x06format\x18\x05 \x01(\tR\x06format\x12\x18\n" +
        "\aexample\x18\x06 \x01(\tR\aexample\x12\x1e\n" +
        "\n" +
        "deprecated\x18\a \x01(\bR\n" +
        "deprecated\"O\n" +
        "\x0eServiceHeaders\x12=\n" +
        "\x10required_headers\x18\x01 \x03(\v2\x12.sebuf.http.HeaderR\x0frequiredHeaders\"N\n" +
        "\rMethodHeaders\x12=\n" +
        "\x10required_headers\x18\x01 \x03(\v2\x12.sebuf.http.HeaderR\x0frequiredHeaders:f\n" +
        "\x0fservice_headers\x12\x1f.google.protobuf.ServiceOptions\x18Ն\x03 \x01(\v2\x1a.sebuf.http.ServiceHeadersR\x0eserviceHeaders:b\n" +
        "\x0emethod_headers\x12\x1e.google.protobuf.MethodOptions\x18ֆ\x03 \x01(\v2\x19.sebuf.http.MethodHeadersR\rmethodHeadersB+Z)github.com/SebastienMelki/sebuf/http;httpb\x06proto3"

var (
        file_proto_sebuf_http_headers_proto_rawDescOnce sync.Once
        file_proto_sebuf_http_headers_proto_rawDescData []byte
)

func file_proto_sebuf_http_headers_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_sebuf_http_headers_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_sebuf_http_headers_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_sebuf_http_headers_proto_rawDesc), len(file_proto_sebuf_http_headers_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_proto_sebuf_http_headers_proto_rawDescData</span>
}

var file_proto_sebuf_http_headers_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_proto_sebuf_http_headers_proto_goTypes = []any{
        (*Header)(nil),                      // 0: sebuf.http.Header
        (*ServiceHeaders)(nil),              // 1: sebuf.http.ServiceHeaders
        (*MethodHeaders)(nil),               // 2: sebuf.http.MethodHeaders
        (*descriptorpb.ServiceOptions)(nil), // 3: google.protobuf.ServiceOptions
        (*descriptorpb.MethodOptions)(nil),  // 4: google.protobuf.MethodOptions
}
var file_proto_sebuf_http_headers_proto_depIdxs = []int32{
        0, // 0: sebuf.http.ServiceHeaders.required_headers:type_name -&gt; sebuf.http.Header
        0, // 1: sebuf.http.MethodHeaders.required_headers:type_name -&gt; sebuf.http.Header
        3, // 2: sebuf.http.service_headers:extendee -&gt; google.protobuf.ServiceOptions
        4, // 3: sebuf.http.method_headers:extendee -&gt; google.protobuf.MethodOptions
        1, // 4: sebuf.http.service_headers:type_name -&gt; sebuf.http.ServiceHeaders
        2, // 5: sebuf.http.method_headers:type_name -&gt; sebuf.http.MethodHeaders
        6, // [6:6] is the sub-list for method output_type
        6, // [6:6] is the sub-list for method input_type
        4, // [4:6] is the sub-list for extension type_name
        2, // [2:4] is the sub-list for extension extendee
        0, // [0:2] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_proto_sebuf_http_headers_proto_init() }</span>
func file_proto_sebuf_http_headers_proto_init() <span class="cov8" title="1">{
        if File_proto_sebuf_http_headers_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_sebuf_http_headers_proto_rawDesc), len(file_proto_sebuf_http_headers_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   3,
                        NumExtensions: 2,
                        NumServices:   0,
                },
                GoTypes:           file_proto_sebuf_http_headers_proto_goTypes,
                DependencyIndexes: file_proto_sebuf_http_headers_proto_depIdxs,
                MessageInfos:      file_proto_sebuf_http_headers_proto_msgTypes,
                ExtensionInfos:    file_proto_sebuf_http_headers_proto_extTypes,
        }.Build()
        File_proto_sebuf_http_headers_proto = out.File
        file_proto_sebuf_http_headers_proto_goTypes = nil
        file_proto_sebuf_http_headers_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package httpgen

import (
        "regexp"

        "google.golang.org/protobuf/compiler/protogen"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/types/descriptorpb"

        "github.com/SebastienMelki/sebuf/http"
)

// HTTP method constants.
const (
        httpMethodGET    = "GET"
        httpMethodPOST   = "POST"
        httpMethodPUT    = "PUT"
        httpMethodDELETE = "DELETE"
        httpMethodPATCH  = "PATCH"
)

// pathParamRegex matches path variables like {user_id} or {id}.
var pathParamRegex = regexp.MustCompile(`\{([^}]+)\}`)

// HTTPConfig represents the HTTP configuration for a method.
type HTTPConfig struct {
        Path       string
        Method     string   // "GET", "POST", "PUT", "DELETE", "PATCH"
        PathParams []string // Path variable names extracted from path
}

// QueryParam represents a query parameter configuration extracted from a field.
type QueryParam struct {
        FieldName   string // Proto field name
        FieldGoName string // Go field name
        ParamName   string // Query parameter name
        Required    bool
}

// ServiceConfigImpl represents the HTTP configuration for a service.
type ServiceConfigImpl struct {
        BasePath string
}

// getMethodHTTPConfig extracts HTTP configuration from method options.
func getMethodHTTPConfig(method *protogen.Method) *HTTPConfig <span class="cov0" title="0">{
        options := method.Desc.Options()
        if options == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the raw options
        <span class="cov0" title="0">methodOptions, ok := options.(*descriptorpb.MethodOptions)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract our custom extension using the generated code
        <span class="cov0" title="0">ext := proto.GetExtension(methodOptions, http.E_Config)
        if ext == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">httpConfig, ok := ext.(*http.HttpConfig)
        if !ok || httpConfig == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">path := httpConfig.GetPath()

        return &amp;HTTPConfig{
                Path:       path,
                Method:     httpMethodToString(httpConfig.GetMethod()),
                PathParams: extractPathParams(path),
        }</span>
}

// httpMethodToString converts HttpMethod enum to string. Returns "POST" for unspecified (backward compatibility).
func httpMethodToString(m http.HttpMethod) string <span class="cov6" title="8">{
        switch m </span>{
        case http.HttpMethod_HTTP_METHOD_GET:<span class="cov1" title="1">
                return httpMethodGET</span>
        case http.HttpMethod_HTTP_METHOD_POST:<span class="cov1" title="1">
                return httpMethodPOST</span>
        case http.HttpMethod_HTTP_METHOD_PUT:<span class="cov1" title="1">
                return httpMethodPUT</span>
        case http.HttpMethod_HTTP_METHOD_DELETE:<span class="cov1" title="1">
                return httpMethodDELETE</span>
        case http.HttpMethod_HTTP_METHOD_PATCH:<span class="cov1" title="1">
                return httpMethodPATCH</span>
        case http.HttpMethod_HTTP_METHOD_UNSPECIFIED:<span class="cov1" title="1">
                // HTTP_METHOD_UNSPECIFIED defaults to POST for backward compatibility
                return httpMethodPOST</span>
        }
        // Any unknown value defaults to POST for backward compatibility
        <span class="cov2" title="2">return httpMethodPOST</span>
}

// extractPathParams parses path variables from a path string.
// Example: "/users/{user_id}/posts/{post_id}" -&gt; ["user_id", "post_id"].
func extractPathParams(path string) []string <span class="cov9" title="22">{
        matches := pathParamRegex.FindAllStringSubmatch(path, -1)
        if len(matches) == 0 </span><span class="cov6" title="7">{
                return nil
        }</span>

        <span class="cov8" title="15">params := make([]string, 0, len(matches))
        for _, match := range matches </span><span class="cov10" title="23">{
                if len(match) &gt; 1 </span><span class="cov10" title="23">{
                        params = append(params, match[1])
                }</span>
        }
        <span class="cov8" title="15">return params</span>
}

// getServiceHTTPConfig extracts HTTP configuration from service options.
func getServiceHTTPConfig(service *protogen.Service) *ServiceConfigImpl <span class="cov0" title="0">{
        options := service.Desc.Options()
        if options == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the raw options
        <span class="cov0" title="0">serviceOptions, ok := options.(*descriptorpb.ServiceOptions)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract our custom extension using the generated code
        <span class="cov0" title="0">ext := proto.GetExtension(serviceOptions, http.E_ServiceConfig)
        if ext == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">serviceConfig, ok := ext.(*http.ServiceConfig)
        if !ok || serviceConfig == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;ServiceConfigImpl{
                BasePath: serviceConfig.GetBasePath(),
        }</span>
}

// getServiceHeaders extracts header configuration from service options.
func getServiceHeaders(service *protogen.Service) []*http.Header <span class="cov0" title="0">{
        options := service.Desc.Options()
        if options == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the raw options
        <span class="cov0" title="0">serviceOptions, ok := options.(*descriptorpb.ServiceOptions)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract our custom extension using the generated code
        <span class="cov0" title="0">ext := proto.GetExtension(serviceOptions, http.E_ServiceHeaders)
        if ext == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">serviceHeaders, ok := ext.(*http.ServiceHeaders)
        if !ok || serviceHeaders == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return serviceHeaders.GetRequiredHeaders()</span>
}

// getMethodHeaders extracts header configuration from method options.
func getMethodHeaders(method *protogen.Method) []*http.Header <span class="cov0" title="0">{
        options := method.Desc.Options()
        if options == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the raw options
        <span class="cov0" title="0">methodOptions, ok := options.(*descriptorpb.MethodOptions)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract our custom extension using the generated code
        <span class="cov0" title="0">ext := proto.GetExtension(methodOptions, http.E_MethodHeaders)
        if ext == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">methodHeaders, ok := ext.(*http.MethodHeaders)
        if !ok || methodHeaders == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return methodHeaders.GetRequiredHeaders()</span>
}

// For now, let's add a helper to parse paths from the existing authv1 proto format.
func parseExistingAnnotation(_ *protogen.Method) string <span class="cov0" title="0">{
        // This is a temporary parser for the existing sebuf.http.config format
        // that's used in authv1/service.proto

        // In the actual implementation, this would properly parse the extension
        // For now, we'll return empty and use default paths
        return ""
}</span>

// getFieldExamples extracts example values from field options.
func getFieldExamples(field *protogen.Field) []string <span class="cov0" title="0">{
        options := field.Desc.Options()
        if options == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the raw options
        <span class="cov0" title="0">fieldOptions, ok := options.(*descriptorpb.FieldOptions)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract our custom extension using the generated code
        <span class="cov0" title="0">ext := proto.GetExtension(fieldOptions, http.E_FieldExamples)
        if ext == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">fieldExamples, ok := ext.(*http.FieldExamples)
        if !ok || fieldExamples == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return fieldExamples.GetValues()</span>
}

// getQueryParams extracts query parameter configurations from message fields.
func getQueryParams(message *protogen.Message) []QueryParam <span class="cov0" title="0">{
        var params []QueryParam

        for _, field := range message.Fields </span><span class="cov0" title="0">{
                options := field.Desc.Options()
                if options == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fieldOptions, ok := options.(*descriptorpb.FieldOptions)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">ext := proto.GetExtension(fieldOptions, http.E_Query)
                if ext == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">queryConfig, ok := ext.(*http.QueryConfig)
                if !ok || queryConfig == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Use the configured name, or default to the proto field name
                <span class="cov0" title="0">paramName := queryConfig.GetName()
                if paramName == "" </span><span class="cov0" title="0">{
                        paramName = string(field.Desc.Name())
                }</span>

                <span class="cov0" title="0">params = append(params, QueryParam{
                        FieldName:   string(field.Desc.Name()),
                        FieldGoName: field.GoName,
                        ParamName:   paramName,
                        Required:    queryConfig.GetRequired(),
                })</span>
        }

        <span class="cov0" title="0">return params</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package httpgen

import (
        "fmt"
        "strconv"
        "strings"

        "google.golang.org/protobuf/compiler/protogen"

        "github.com/SebastienMelki/sebuf/http"
)

// Generator handles HTTP code generation for protobuf services.
type Generator struct {
        plugin       *protogen.Plugin
        generateMock bool
}

// Options configures the generator.
type Options struct {
        GenerateMock bool
}

// New creates a new HTTP generator.
func New(plugin *protogen.Plugin) *Generator <span class="cov1" title="1">{
        return &amp;Generator{
                plugin: plugin,
        }
}</span>

// NewWithOptions creates a new HTTP generator with options.
func NewWithOptions(plugin *protogen.Plugin, opts Options) *Generator <span class="cov2" title="3">{
        return &amp;Generator{
                plugin:       plugin,
                generateMock: opts.GenerateMock,
        }
}</span>

// Generate processes all files and generates HTTP handlers.
func (g *Generator) Generate() error <span class="cov0" title="0">{
        for _, file := range g.plugin.Files </span><span class="cov0" title="0">{
                if !file.Generate </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if err := g.generateFile(file); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (g *Generator) generateFile(file *protogen.File) error <span class="cov0" title="0">{
        // Generate error implementation file if there are messages ending with Error
        if err := g.generateErrorImplFile(file); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(file.Services) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Validate HTTP configurations - fail fast on any errors
        <span class="cov0" title="0">for _, service := range file.Services </span><span class="cov0" title="0">{
                if err := ValidateService(service); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("validation error: %w", err)
                }</span>
        }

        // Generate main HTTP file
        <span class="cov0" title="0">if err := g.generateHTTPFile(file); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Generate binding file
        <span class="cov0" title="0">if err := g.generateBindingFile(file); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Generate config file
        <span class="cov0" title="0">if err := g.generateConfigFile(file); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Generate mock file if requested
        <span class="cov0" title="0">if g.generateMock </span><span class="cov0" title="0">{
                if err := g.generateMockFile(file); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (g *Generator) generateHTTPFile(file *protogen.File) error <span class="cov0" title="0">{
        filename := file.GeneratedFilenamePrefix + "_http.pb.go"
        gf := g.plugin.NewGeneratedFile(filename, file.GoImportPath)

        g.writeHeader(gf, file)

        gf.P("import (")
        gf.P(`"context"`)
        gf.P()
        gf.P(`sebufhttp "github.com/SebastienMelki/sebuf/http"`)
        gf.P(")")
        gf.P()

        for _, service := range file.Services </span><span class="cov0" title="0">{
                if err := g.generateService(gf, file, service); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (g *Generator) generateService(gf *protogen.GeneratedFile, file *protogen.File, service *protogen.Service) error <span class="cov0" title="0">{
        serviceName := service.GoName

        // Generate service interface
        gf.P("// ", serviceName, "Server is the server API for ", serviceName, " service.")
        gf.P("type ", serviceName, "Server interface {")
        for _, method := range service.Methods </span><span class="cov0" title="0">{
                gf.P(method.GoName, "(context.Context, *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error)")
        }</span>
        <span class="cov0" title="0">gf.P("}")
        gf.P()

        // Generate registration function
        gf.P(
                "// Register",
                serviceName,
                "Server registers the HTTP handlers for service ",
                serviceName,
                " to the given mux.",
        )
        gf.P("func Register", serviceName, "Server(server ", serviceName, "Server, opts ...ServerOption) error {")
        gf.P("config := getConfiguration(opts...)")
        gf.P()

        // Get service-level base path if configured
        basePath := g.getServiceBasePath(service)

        // Get service-level headers
        gf.P("serviceHeaders := get", serviceName, "Headers()")
        gf.P()

        for i, method := range service.Methods </span><span class="cov0" title="0">{
                httpPath := g.getMethodPath(method, basePath, file.GoPackageName)
                httpMethod := g.getHTTPMethod(method)

                handlerName := fmt.Sprintf("%sHandler", lowerFirst(method.GoName))
                if i == 0 </span><span class="cov0" title="0">{
                        gf.P("methodHeaders := get", method.GoName, "Headers()")
                }</span> else<span class="cov0" title="0"> {
                        gf.P("methodHeaders = get", method.GoName, "Headers()")
                }</span>
                <span class="cov0" title="0">gf.P(handlerName, " := BindingMiddleware[", method.Input.GoIdent, "](")
                gf.P("genericHandler(server.", method.GoName, "), serviceHeaders, methodHeaders,")
                gf.P(lowerFirst(method.GoName), "PathParams, ", lowerFirst(method.GoName), "QueryParams,")
                gf.P(`"`, httpMethod, `",`)
                gf.P(")")
                gf.P()
                gf.P(`config.mux.Handle("`, httpMethod, ` `, httpPath, `", `, handlerName, `)`)
                gf.P()</span>
        }

        <span class="cov0" title="0">gf.P("return nil")
        gf.P("}")
        gf.P()

        // Generate header getter functions
        if err := g.generateHeaderGetters(gf, service); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Generate path and query param configs
        <span class="cov0" title="0">if err := g.generateParamConfigs(gf, service); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

//nolint:funlen // This function generates a lot of boilerplate code
func (g *Generator) generateBindingFile(file *protogen.File) error <span class="cov0" title="0">{
        filename := file.GeneratedFilenamePrefix + "_http_binding.pb.go"
        gf := g.plugin.NewGeneratedFile(filename, file.GoImportPath)

        g.writeHeader(gf, file)

        gf.P("import (")
        gf.P(`"bytes"`)
        gf.P(`"context"`)
        gf.P(`"errors"`)
        gf.P(`"fmt"`)
        gf.P(`"io"`)
        gf.P(`"net/http"`)
        gf.P(`"strconv"`)
        gf.P(`"strings"`)
        gf.P(`"sync"`)
        gf.P(`"time"`)
        gf.P(`"unicode/utf8"`)
        gf.P()
        gf.P(`protovalidate "buf.build/go/protovalidate"`)
        gf.P(`"google.golang.org/protobuf/encoding/protojson"`)
        gf.P(`"google.golang.org/protobuf/proto"`)
        gf.P(`"google.golang.org/protobuf/reflect/protoreflect"`)
        gf.P()
        gf.P(`sebufhttp "github.com/SebastienMelki/sebuf/http"`)
        gf.P(")")
        gf.P()

        // Content type constants
        gf.P("const (")
        gf.P(`// JSONContentType is the content type for JSON`)
        gf.P(`JSONContentType = "application/json"`)
        gf.P(`// BinaryContentType is the content type for binary protobuf`)
        gf.P(`BinaryContentType = "application/octet-stream"`)
        gf.P(`// ProtoContentType is the content type for protobuf`)
        gf.P(`ProtoContentType = "application/x-protobuf"`)
        gf.P(")")
        gf.P()

        // Context key for request storage
        gf.P("type bodyCtxKey struct{}")
        gf.P()

        // PathParamConfig type
        gf.P("// PathParamConfig defines configuration for a path parameter.")
        gf.P("type PathParamConfig struct {")
        gf.P("URLParam  string // Parameter name in URL path")
        gf.P("FieldName string // Proto field name to bind to")
        gf.P("}")
        gf.P()

        // QueryParamConfig type
        gf.P("// QueryParamConfig defines configuration for a query parameter.")
        gf.P("type QueryParamConfig struct {")
        gf.P("QueryName string // Parameter name in query string")
        gf.P("FieldName string // Proto field name to bind to")
        gf.P("Required  bool   // Whether this parameter is required")
        gf.P("}")
        gf.P()

        // getRequest function
        gf.P("func getRequest[Req any](ctx context.Context) Req {")
        gf.P("val := ctx.Value(bodyCtxKey{})")
        gf.P("request, ok := val.(Req)")
        gf.P("if ok {")
        gf.P("return request")
        gf.P("}")
        gf.P("return *new(Req)")
        gf.P("}")
        gf.P()

        // BindingMiddleware function
        gf.P("// BindingMiddleware creates a middleware that binds HTTP requests to protobuf messages")
        gf.P("// and validates them using protovalidate and header validation.")
        gf.P("// It supports path parameters, query parameters, and request body binding.")
        gf.P("func BindingMiddleware[Req any](next http.Handler, serviceHeaders, methodHeaders []*sebufhttp.Header,")
        gf.P("pathParams []PathParamConfig, queryParams []QueryParamConfig, httpMethod string) http.Handler {")
        gf.P("return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {")
        gf.P("// Validate headers first")
        gf.P("if validationErr := validateHeaders(r, serviceHeaders, methodHeaders); validationErr != nil {")
        gf.P("writeValidationErrorResponse(w, r, validationErr)")
        gf.P("return")
        gf.P("}")
        gf.P()
        gf.P("toBind := new(Req)")
        gf.P()
        gf.P("// Bind path parameters")
        gf.P("if msg, ok := any(toBind).(proto.Message); ok {")
        gf.P("if err := bindPathParams(r, msg, pathParams); err != nil {")
        gf.P("writeValidationErrorResponse(w, r, err)")
        gf.P("return")
        gf.P("}")
        gf.P()
        gf.P("// Bind query parameters")
        gf.P("if err := bindQueryParams(r, msg, queryParams); err != nil {")
        gf.P("writeValidationErrorResponse(w, r, err)")
        gf.P("return")
        gf.P("}")
        gf.P("}")
        gf.P()
        gf.P("// Bind body only for POST, PUT, PATCH methods")
        gf.P(`if httpMethod == "POST" || httpMethod == "PUT" || httpMethod == "PATCH" {`)
        gf.P("err := bindDataBasedOnContentType(r, toBind)")
        gf.P("if err != nil {")
        gf.P("// For binding errors, return a simple validation error")
        gf.P("validationErr := &amp;sebufhttp.ValidationError{")
        gf.P("Violations: []*sebufhttp.FieldViolation{")
        gf.P("{")
        gf.P(`Field: "body",`)
        gf.P(`Description: fmt.Sprintf("failed to parse request body: %v", err),`)
        gf.P("},")
        gf.P("},")
        gf.P("}")
        gf.P("writeValidationErrorResponse(w, r, validationErr)")
        gf.P("return")
        gf.P("}")
        gf.P("}")
        gf.P()
        gf.P("// Validate the complete message")
        gf.P("if msg, ok := any(toBind).(proto.Message); ok {")
        gf.P("if err := ValidateMessage(msg); err != nil {")
        gf.P("writeValidationError(w, r, err)")
        gf.P("return")
        gf.P("}")
        gf.P("}")
        gf.P()
        gf.P("ctx := context.WithValue(r.Context(), bodyCtxKey{}, toBind)")
        gf.P("next.ServeHTTP(w, r.WithContext(ctx))")
        gf.P("})")
        gf.P("}")
        gf.P()

        // filterFlags helper
        gf.P("func filterFlags(content string) string {")
        gf.P("for i, char := range content {")
        gf.P("if char == ' ' || char == ';' {")
        gf.P("return content[:i]")
        gf.P("}")
        gf.P("}")
        gf.P("return content")
        gf.P("}")
        gf.P()

        // bindDataBasedOnContentType function
        gf.P("func bindDataBasedOnContentType[Req any](r *http.Request, toBind *Req) error {")
        gf.P(`contentType := filterFlags(r.Header.Get("Content-Type"))`)
        gf.P("switch contentType {")
        gf.P("case JSONContentType:")
        gf.P("return bindDataFromJSONRequest(r, toBind)")
        gf.P("case BinaryContentType, ProtoContentType:")
        gf.P("return bindDataFromBinaryRequest(r, toBind)")
        gf.P("default:")
        gf.P("return bindDataFromBinaryRequest(r, toBind)")
        gf.P("}")
        gf.P("}")
        gf.P()

        // bindDataFromJSONRequest function
        gf.P("func bindDataFromJSONRequest[Req any](r *http.Request, toBind *Req) error {")
        gf.P("bodyBytes, err := io.ReadAll(r.Body)")
        gf.P("r.Body = io.NopCloser(bytes.NewReader(bodyBytes))")
        gf.P("if err != nil {")
        gf.P(`return fmt.Errorf("could not read request body: %w", err)`)
        gf.P("}")
        gf.P()
        gf.P("if len(bodyBytes) == 0 {")
        gf.P("return nil")
        gf.P("}")
        gf.P()
        gf.P("protoRequest, ok := any(toBind).(proto.Message)")
        gf.P("if !ok {")
        gf.P(`return errors.New("JSON request is not a protocol buffer message")`)
        gf.P("}")
        gf.P()
        gf.P("err = protojson.Unmarshal(bodyBytes, protoRequest)")
        gf.P("if err != nil {")
        gf.P(`return fmt.Errorf("could not unmarshal request JSON: %w", err)`)
        gf.P("}")
        gf.P("return nil")
        gf.P("}")
        gf.P()

        // bindDataFromBinaryRequest function
        gf.P("func bindDataFromBinaryRequest[Req any](r *http.Request, toBind *Req) error {")
        gf.P("bodyBytes, err := io.ReadAll(r.Body)")
        gf.P("r.Body = io.NopCloser(bytes.NewReader(bodyBytes))")
        gf.P()
        gf.P("if len(bodyBytes) == 0 {")
        gf.P("return nil")
        gf.P("}")
        gf.P()
        gf.P("if err != nil &amp;&amp; !errors.Is(err, io.ErrUnexpectedEOF) {")
        gf.P(`return fmt.Errorf("could not read request body: %w", err)`)
        gf.P("}")
        gf.P()
        gf.P("protoRequest, ok := any(toBind).(proto.Message)")
        gf.P("if !ok {")
        gf.P(`return errors.New("binary request is not a protocol buffer message")`)
        gf.P("}")
        gf.P()
        gf.P("err = proto.Unmarshal(bodyBytes, protoRequest)")
        gf.P("if err != nil {")
        gf.P(`return fmt.Errorf("could not unmarshal binary request: %w", err)`)
        gf.P("}")
        gf.P("return nil")
        gf.P("}")
        gf.P()

        // bindPathParams function - binds URL path parameters to proto message fields
        gf.P("// bindPathParams binds URL path parameters to proto message fields using Go 1.22+ PathValue.")
        gf.P(
                "func bindPathParams(r *http.Request, msg proto.Message, params []PathParamConfig) *sebufhttp.ValidationError {",
        )
        gf.P("if len(params) == 0 {")
        gf.P("return nil")
        gf.P("}")
        gf.P()
        gf.P("reflectMsg := msg.ProtoReflect()")
        gf.P("fields := reflectMsg.Descriptor().Fields()")
        gf.P()
        gf.P("for _, param := range params {")
        gf.P("value := r.PathValue(param.URLParam)")
        gf.P("if value == \"\" {")
        gf.P("return &amp;sebufhttp.ValidationError{")
        gf.P("Violations: []*sebufhttp.FieldViolation{{")
        gf.P(`Field: param.FieldName,`)
        gf.P(`Description: fmt.Sprintf("missing required path parameter: %s", param.URLParam),`)
        gf.P("}},")
        gf.P("}")
        gf.P("}")
        gf.P()
        gf.P("field := fields.ByName(protoreflect.Name(param.FieldName))")
        gf.P("if field == nil {")
        gf.P("continue // Field not found, skip")
        gf.P("}")
        gf.P()
        gf.P("convertedValue, err := convertStringToFieldValue(value, field.Kind())")
        gf.P("if err != nil {")
        gf.P("return &amp;sebufhttp.ValidationError{")
        gf.P("Violations: []*sebufhttp.FieldViolation{{")
        gf.P(`Field: param.FieldName,`)
        gf.P(`Description: fmt.Sprintf("invalid value for path parameter %s: %v", param.URLParam, err),`)
        gf.P("}},")
        gf.P("}")
        gf.P("}")
        gf.P()
        gf.P("reflectMsg.Set(field, convertedValue)")
        gf.P("}")
        gf.P()
        gf.P("return nil")
        gf.P("}")
        gf.P()

        // bindQueryParams function - binds URL query parameters to proto message fields
        gf.P("// bindQueryParams binds URL query parameters to proto message fields.")
        gf.P(
                "func bindQueryParams(r *http.Request, msg proto.Message, params []QueryParamConfig) *sebufhttp.ValidationError {",
        )
        gf.P("if len(params) == 0 {")
        gf.P("return nil")
        gf.P("}")
        gf.P()
        gf.P("query := r.URL.Query()")
        gf.P("reflectMsg := msg.ProtoReflect()")
        gf.P("fields := reflectMsg.Descriptor().Fields()")
        gf.P()
        gf.P("for _, param := range params {")
        gf.P("values := query[param.QueryName]")
        gf.P("if len(values) == 0 {")
        gf.P("if param.Required {")
        gf.P("return &amp;sebufhttp.ValidationError{")
        gf.P("Violations: []*sebufhttp.FieldViolation{{")
        gf.P(`Field: param.FieldName,`)
        gf.P(`Description: fmt.Sprintf("missing required query parameter: %s", param.QueryName),`)
        gf.P("}},")
        gf.P("}")
        gf.P("}")
        gf.P("continue")
        gf.P("}")
        gf.P()
        gf.P("field := fields.ByName(protoreflect.Name(param.FieldName))")
        gf.P("if field == nil {")
        gf.P("continue // Field not found, skip")
        gf.P("}")
        gf.P()
        gf.P("// Handle repeated fields (arrays)")
        gf.P("if field.IsList() {")
        gf.P("list := reflectMsg.Mutable(field).List()")
        gf.P("for _, v := range values {")
        gf.P("converted, err := convertStringToFieldValue(v, field.Kind())")
        gf.P("if err != nil {")
        gf.P("return &amp;sebufhttp.ValidationError{")
        gf.P("Violations: []*sebufhttp.FieldViolation{{")
        gf.P(`Field: param.FieldName,`)
        gf.P(`Description: fmt.Sprintf("invalid value for query parameter %s: %v", param.QueryName, err),`)
        gf.P("}},")
        gf.P("}")
        gf.P("}")
        gf.P("list.Append(converted)")
        gf.P("}")
        gf.P("} else {")
        gf.P("converted, err := convertStringToFieldValue(values[0], field.Kind())")
        gf.P("if err != nil {")
        gf.P("return &amp;sebufhttp.ValidationError{")
        gf.P("Violations: []*sebufhttp.FieldViolation{{")
        gf.P(`Field: param.FieldName,`)
        gf.P(`Description: fmt.Sprintf("invalid value for query parameter %s: %v", param.QueryName, err),`)
        gf.P("}},")
        gf.P("}")
        gf.P("}")
        gf.P("reflectMsg.Set(field, converted)")
        gf.P("}")
        gf.P("}")
        gf.P()
        gf.P("return nil")
        gf.P("}")
        gf.P()

        // convertStringToFieldValue function - converts string values to protoreflect.Value
        gf.P("// convertStringToFieldValue converts a string value to the appropriate protoreflect.Value.")
        gf.P("func convertStringToFieldValue(value string, kind protoreflect.Kind) (protoreflect.Value, error) {")
        gf.P("switch kind {")
        gf.P("case protoreflect.StringKind:")
        gf.P("return protoreflect.ValueOfString(value), nil")
        gf.P("case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:")
        gf.P("v, err := strconv.ParseInt(value, 10, 32)")
        gf.P("if err != nil {")
        gf.P("return protoreflect.Value{}, err")
        gf.P("}")
        gf.P("return protoreflect.ValueOfInt32(int32(v)), nil")
        gf.P("case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:")
        gf.P("v, err := strconv.ParseInt(value, 10, 64)")
        gf.P("if err != nil {")
        gf.P("return protoreflect.Value{}, err")
        gf.P("}")
        gf.P("return protoreflect.ValueOfInt64(v), nil")
        gf.P("case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:")
        gf.P("v, err := strconv.ParseUint(value, 10, 32)")
        gf.P("if err != nil {")
        gf.P("return protoreflect.Value{}, err")
        gf.P("}")
        gf.P("return protoreflect.ValueOfUint32(uint32(v)), nil")
        gf.P("case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:")
        gf.P("v, err := strconv.ParseUint(value, 10, 64)")
        gf.P("if err != nil {")
        gf.P("return protoreflect.Value{}, err")
        gf.P("}")
        gf.P("return protoreflect.ValueOfUint64(v), nil")
        gf.P("case protoreflect.BoolKind:")
        gf.P("v, err := strconv.ParseBool(value)")
        gf.P("if err != nil {")
        gf.P("return protoreflect.Value{}, err")
        gf.P("}")
        gf.P("return protoreflect.ValueOfBool(v), nil")
        gf.P("case protoreflect.FloatKind:")
        gf.P("v, err := strconv.ParseFloat(value, 32)")
        gf.P("if err != nil {")
        gf.P("return protoreflect.Value{}, err")
        gf.P("}")
        gf.P("return protoreflect.ValueOfFloat32(float32(v)), nil")
        gf.P("case protoreflect.DoubleKind:")
        gf.P("v, err := strconv.ParseFloat(value, 64)")
        gf.P("if err != nil {")
        gf.P("return protoreflect.Value{}, err")
        gf.P("}")
        gf.P("return protoreflect.ValueOfFloat64(v), nil")
        gf.P("default:")
        gf.P(`return protoreflect.Value{}, fmt.Errorf("unsupported field type: %v", kind)`)
        gf.P("}")
        gf.P("}")
        gf.P()

        // genericHandler function
        gf.P("func genericHandler[Req any, Res any](serve func(context.Context, Req) (Res, error)) http.HandlerFunc {")
        gf.P("return func(w http.ResponseWriter, r *http.Request) {")
        gf.P("request := getRequest[Req](r.Context())")
        gf.P()
        gf.P("response, err := serve(r.Context(), request)")
        gf.P("if err != nil {")
        gf.P("errorMsg := &amp;sebufhttp.Error{")
        gf.P("Message: err.Error(),")
        gf.P("}")
        gf.P("writeErrorResponse(w, r, errorMsg)")
        gf.P("return")
        gf.P("}")
        gf.P()
        gf.P("responseBytes, err := marshalResponse(r, response)")
        gf.P("if err != nil {")
        gf.P("errorMsg := &amp;sebufhttp.Error{")
        gf.P("Message: fmt.Sprintf(\"failed to marshal response: %v\", err),")
        gf.P("}")
        gf.P("writeErrorResponse(w, r, errorMsg)")
        gf.P("return")
        gf.P("}")
        gf.P()
        gf.P("_, err = w.Write(responseBytes)")
        gf.P("if err != nil {")
        gf.P("errorMsg := &amp;sebufhttp.Error{")
        gf.P("Message: fmt.Sprintf(\"failed to write response: %v\", err),")
        gf.P("}")
        gf.P("writeErrorResponse(w, r, errorMsg)")
        gf.P("return")
        gf.P("}")
        gf.P("}")
        gf.P("}")
        gf.P()

        // marshalResponse function
        gf.P("func marshalResponse(r *http.Request, response any) ([]byte, error) {")
        gf.P(`contentType := r.Header.Get("Content-Type")`)
        gf.P("if contentType == \"\" {")
        gf.P("contentType = JSONContentType")
        gf.P("}")
        gf.P()
        gf.P("msg, ok := response.(proto.Message)")
        gf.P("if !ok {")
        gf.P(`return nil, fmt.Errorf("response is not a protocol buffer message")`)
        gf.P("}")
        gf.P()
        gf.P("switch filterFlags(contentType) {")
        gf.P("case JSONContentType:")
        gf.P("return protojson.Marshal(msg)")
        gf.P("case BinaryContentType, ProtoContentType:")
        gf.P("return proto.Marshal(msg)")
        gf.P("default:")
        gf.P(`return nil, fmt.Errorf("unsupported content type: %s", contentType)`)
        gf.P("}")
        gf.P("}")
        gf.P()

        // Generate error response helpers
        g.generateErrorResponseFunctions(gf)

        // Generate validation support
        g.generateValidationFunctions(gf)

        // Generate header validation support
        g.generateHeaderValidationFunctions(gf)

        return nil
}</span>

func (g *Generator) generateConfigFile(file *protogen.File) error <span class="cov0" title="0">{
        filename := file.GeneratedFilenamePrefix + "_http_config.pb.go"
        gf := g.plugin.NewGeneratedFile(filename, file.GoImportPath)

        g.writeHeader(gf, file)

        gf.P("import (")
        gf.P(`"net/http"`)
        gf.P(")")
        gf.P()

        // ServerOption type
        gf.P("// ServerOption configures a Server")
        gf.P("type ServerOption func(c *serverConfiguration)")
        gf.P()

        // serverConfiguration struct
        gf.P("type serverConfiguration struct {")
        gf.P("mux *http.ServeMux")
        gf.P("withMux bool")
        gf.P("}")
        gf.P()

        // getDefaultConfiguration function
        gf.P("func getDefaultConfiguration() *serverConfiguration {")
        gf.P("return &amp;serverConfiguration{")
        gf.P("mux: http.DefaultServeMux,")
        gf.P("withMux: false,")
        gf.P("}")
        gf.P("}")
        gf.P()

        // getConfiguration function
        gf.P("func getConfiguration(options ...ServerOption) *serverConfiguration {")
        gf.P("configuration := getDefaultConfiguration()")
        gf.P("for _, option := range options {")
        gf.P("option(configuration)")
        gf.P("}")
        gf.P("return configuration")
        gf.P("}")
        gf.P()

        // WithMux option
        gf.P("// WithMux configures the Server to use the given ServeMux")
        gf.P("func WithMux(mux *http.ServeMux) ServerOption {")
        gf.P("return func(c *serverConfiguration) {")
        gf.P("c.mux = mux")
        gf.P("c.withMux = true")
        gf.P("}")
        gf.P("}")
        gf.P()

        return nil
}</span>

func (g *Generator) writeHeader(gf *protogen.GeneratedFile, file *protogen.File) <span class="cov0" title="0">{
        gf.P("// Code generated by protoc-gen-go-http. DO NOT EDIT.")
        gf.P("// source: ", file.Desc.Path())
        gf.P()
        gf.P("package ", file.GoPackageName)
        gf.P()
}</span>

// getMethodPath determines the HTTP path for a method.
func (g *Generator) getMethodPath(method *protogen.Method, basePath string, packageName protogen.GoPackageName) string <span class="cov0" title="0">{
        // Try to get custom path from options
        customPath := g.getCustomPath(method)

        // If we have both base path and custom path, combine them
        if basePath != "" &amp;&amp; customPath != "" </span><span class="cov0" title="0">{
                // Ensure proper path joining
                basePath = strings.TrimSuffix(basePath, "/")
                if !strings.HasPrefix(customPath, "/") </span><span class="cov0" title="0">{
                        customPath = "/" + customPath
                }</span>
                <span class="cov0" title="0">return basePath + customPath</span>
        }

        // If only custom path, use it
        <span class="cov0" title="0">if customPath != "" </span><span class="cov0" title="0">{
                return customPath
        }</span>

        // Generate default path
        <span class="cov0" title="0">if basePath != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s/%s", strings.TrimSuffix(basePath, "/"), camelToSnake(method.GoName))
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("/%s/%s", packageName, camelToSnake(method.GoName))</span>
}

// getCustomPath extracts custom HTTP path from method options.
func (g *Generator) getCustomPath(method *protogen.Method) string <span class="cov0" title="0">{
        config := getMethodHTTPConfig(method)
        if config != nil &amp;&amp; config.Path != "" </span><span class="cov0" title="0">{
                return config.Path
        }</span>

        // Try to parse existing annotation format (temporary)
        <span class="cov0" title="0">return parseExistingAnnotation(method)</span>
}

// getServiceBasePath extracts base path from service options.
func (g *Generator) getServiceBasePath(service *protogen.Service) string <span class="cov0" title="0">{
        config := getServiceHTTPConfig(service)
        if config != nil &amp;&amp; config.BasePath != "" </span><span class="cov0" title="0">{
                return config.BasePath
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// getHTTPMethod returns the HTTP method for a method. Defaults to POST for backward compatibility.
func (g *Generator) getHTTPMethod(method *protogen.Method) string <span class="cov0" title="0">{
        config := getMethodHTTPConfig(method)
        if config != nil &amp;&amp; config.Method != "" </span><span class="cov0" title="0">{
                return config.Method
        }</span>
        <span class="cov0" title="0">return "POST"</span>
}

// getPathParams extracts path parameter names from method configuration.
func (g *Generator) getPathParams(method *protogen.Method) []string <span class="cov0" title="0">{
        config := getMethodHTTPConfig(method)
        if config != nil </span><span class="cov0" title="0">{
                return config.PathParams
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Helper functions.
func lowerFirst(s string) string <span class="cov5" title="13">{
        if s == "" </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov5" title="12">return strings.ToLower(s[:1]) + s[1:]</span>
}

func camelToSnake(s string) string <span class="cov6" title="17">{
        var result []byte
        for i, r := range s </span><span class="cov10" title="155">{
                if r &gt;= 'A' &amp;&amp; r &lt;= 'Z' </span><span class="cov7" title="35">{
                        if i &gt; 0 </span><span class="cov6" title="23">{
                                result = append(result, '_')
                        }</span>
                        <span class="cov7" title="35">result = append(result, byte(r+'a'-'A'))</span>
                } else<span class="cov9" title="120"> {
                        result = append(result, byte(r))
                }</span>
        }
        <span class="cov6" title="17">return string(result)</span>
}

// generateErrorResponseFunctions generates error response helper functions.
func (g *Generator) generateErrorResponseFunctions(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        g.generateWriteProtoMessageResponseFunc(gf)
        g.generateWriteValidationErrorResponseFunc(gf)
        g.generateWriteValidationErrorFunc(gf)
        g.generateWriteErrorResponseFunc(gf)
}</span>

// generateWriteProtoMessageResponseFunc generates a helper function for writing protobuf messages as responses.
func (g *Generator) generateWriteProtoMessageResponseFunc(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        gf.P("// writeProtoMessageResponse writes a protobuf message as an HTTP response")
        gf.P(
                "func writeProtoMessageResponse(w http.ResponseWriter, r *http.Request, msg proto.Message, statusCode int, fallbackMsg string) {",
        )
        gf.P(`contentType := r.Header.Get("Content-Type")`)
        gf.P("if contentType == \"\" {")
        gf.P("contentType = JSONContentType")
        gf.P("}")
        gf.P()
        gf.P("var responseBytes []byte")
        gf.P("var err error")
        gf.P()
        gf.P("switch filterFlags(contentType) {")
        gf.P("case JSONContentType:")
        gf.P("responseBytes, err = protojson.Marshal(msg)")
        gf.P("case BinaryContentType, ProtoContentType:")
        gf.P("responseBytes, err = proto.Marshal(msg)")
        gf.P("default:")
        gf.P("// Default to JSON for error responses")
        gf.P("responseBytes, err = protojson.Marshal(msg)")
        gf.P("}")
        gf.P()
        gf.P("if err != nil {")
        gf.P("// Fallback to plain text error if marshaling fails")
        gf.P("http.Error(w, fallbackMsg, statusCode)")
        gf.P("return")
        gf.P("}")
        gf.P()
        gf.P("w.WriteHeader(statusCode)")
        gf.P("_, _ = w.Write(responseBytes)")
        gf.P("}")
        gf.P()
}</span>

// generateWriteValidationErrorResponseFunc generates the writeValidationErrorResponse function.
func (g *Generator) generateWriteValidationErrorResponseFunc(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        gf.P("// writeValidationErrorResponse writes a ValidationError as a response")
        gf.P(
                "func writeValidationErrorResponse(w http.ResponseWriter, r *http.Request, validationErr *sebufhttp.ValidationError) {",
        )
        gf.P(`writeProtoMessageResponse(w, r, validationErr, http.StatusBadRequest, "validation failed")`)
        gf.P("}")
        gf.P()
}</span>

// generateWriteValidationErrorFunc generates the writeValidationError function for protovalidate errors.
func (g *Generator) generateWriteValidationErrorFunc(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        gf.P("// writeValidationError converts a protovalidate error to ValidationError and writes it as response")
        gf.P("func writeValidationError(w http.ResponseWriter, r *http.Request, err error) {")
        gf.P("validationErr := &amp;sebufhttp.ValidationError{}")
        gf.P()
        gf.P("// Handle protovalidate.ValidationError")
        gf.P("var valErr *protovalidate.ValidationError")
        gf.P("if errors.As(err, &amp;valErr) {")
        gf.P("for _, violation := range valErr.Violations {")
        g.generateFieldPathExtraction(gf)
        gf.P("validationErr.Violations = append(validationErr.Violations, &amp;sebufhttp.FieldViolation{")
        gf.P("Field: fieldPath,")
        gf.P("Description: violation.Proto.GetMessage(),")
        gf.P("})")
        gf.P("}")
        gf.P("} else {")
        gf.P("// Shouldn't happen, but handle as generic error")
        gf.P("validationErr.Violations = append(validationErr.Violations, &amp;sebufhttp.FieldViolation{")
        gf.P(`Field: "unknown",`)
        gf.P("Description: err.Error(),")
        gf.P("})")
        gf.P("}")
        gf.P()
        gf.P("writeValidationErrorResponse(w, r, validationErr)")
        gf.P("}")
        gf.P()
}</span>

// generateWriteErrorResponseFunc generates the writeErrorResponse function.
func (g *Generator) generateWriteErrorResponseFunc(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        gf.P("// writeErrorResponse writes an Error as a response")
        gf.P("func writeErrorResponse(w http.ResponseWriter, r *http.Request, errorMsg *sebufhttp.Error) {")
        gf.P(`writeProtoMessageResponse(w, r, errorMsg, http.StatusInternalServerError, "internal server error")`)
        gf.P("}")
        gf.P()
}</span>

// generateFieldPathExtraction generates the field path extraction logic.
func (g *Generator) generateFieldPathExtraction(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        gf.P("// Extract field path from violation")
        gf.P("fieldPath := \"\"")
        gf.P("if violation.Proto != nil &amp;&amp; violation.Proto.GetField() != nil {")
        gf.P("elements := violation.Proto.GetField().GetElements()")
        gf.P("if len(elements) &gt; 0 {")
        gf.P("fieldPath = elements[0].GetFieldName()")
        gf.P("for i := 1; i &lt; len(elements); i++ {")
        gf.P("fieldPath += \".\" + elements[i].GetFieldName()")
        gf.P("}")
        gf.P("}")
        gf.P("}")
        gf.P("if fieldPath == \"\" {")
        gf.P("fieldPath = \"unknown\"")
        gf.P("}")
        gf.P()
}</span>

// generateValidationFunctions generates the validation support code.
func (g *Generator) generateValidationFunctions(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        // Global validator instance
        gf.P("var (")
        gf.P("// Global validator instance - created once and reused")
        gf.P("validatorOnce sync.Once")
        gf.P("validator protovalidate.Validator")
        gf.P("validatorErr error")
        gf.P(")")
        gf.P()

        // getValidator function
        gf.P("// getValidator returns a cached validator instance")
        gf.P("func getValidator() (protovalidate.Validator, error) {")
        gf.P("validatorOnce.Do(func() {")
        gf.P("validator, validatorErr = protovalidate.New()")
        gf.P("})")
        gf.P("return validator, validatorErr")
        gf.P("}")
        gf.P()

        // ValidateMessage function
        gf.P("// ValidateMessage validates a protobuf message using protovalidate")
        gf.P("func ValidateMessage(msg proto.Message) error {")
        gf.P("// Get cached validator")
        gf.P("v, err := getValidator()")
        gf.P("if err != nil {")
        gf.P("// If we can't create a validator, log and continue")
        gf.P("// This allows the service to run even if validation setup fails")
        gf.P("return nil")
        gf.P("}")
        gf.P()
        gf.P("// Validate the message and return any error")
        gf.P("return v.Validate(msg)")
        gf.P("}")
        gf.P()
}</span>

// generateHeaderValidationFunctions generates header validation support code.
func (g *Generator) generateHeaderValidationFunctions(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        g.generateValidateHeadersFunction(gf)
        g.generateValidateHeaderValueFunction(gf)
        g.generateTypeValidators(gf)
        g.generateFormatValidators(gf)
}</span>

// generateValidateHeadersFunction generates the main header validation function.
func (g *Generator) generateValidateHeadersFunction(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        gf.P("// validateHeaders validates required headers for a service and method")
        gf.P("// Returns a ValidationError if any required headers are missing or invalid")
        gf.P(
                "func validateHeaders(r *http.Request, serviceHeaders, methodHeaders []*sebufhttp.Header) *sebufhttp.ValidationError {",
        )
        g.generateHeaderMergeLogic(gf)
        g.generateHeaderValidationLoop(gf)
        g.generateValidationErrorReturn(gf)
        gf.P("}")
        gf.P()
}</span>

// generateHeaderMergeLogic generates the logic to merge service and method headers.
func (g *Generator) generateHeaderMergeLogic(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        gf.P("// Merge service and method headers, with method headers taking precedence")
        gf.P("allHeaders := make(map[string]*sebufhttp.Header)")
        gf.P()
        gf.P("// Add service headers first")
        gf.P("for _, header := range serviceHeaders {")
        gf.P("if header.GetRequired() {")
        gf.P("allHeaders[strings.ToLower(header.GetName())] = header")
        gf.P("}")
        gf.P("}")
        gf.P()
        gf.P("// Add method headers (override service headers if same name)")
        gf.P("for _, header := range methodHeaders {")
        gf.P("if header.GetRequired() {")
        gf.P("allHeaders[strings.ToLower(header.GetName())] = header")
        gf.P("}")
        gf.P("}")
        gf.P()
}</span>

// generateHeaderValidationLoop generates the main header validation loop.
func (g *Generator) generateHeaderValidationLoop(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        gf.P("// Collect all validation violations")
        gf.P("var violations []*sebufhttp.FieldViolation")
        gf.P()
        gf.P("// Validate each required header")
        gf.P("for _, headerSpec := range allHeaders {")
        gf.P("value := r.Header.Get(headerSpec.GetName())")
        gf.P("if value == \"\" {")
        gf.P("violations = append(violations, &amp;sebufhttp.FieldViolation{")
        gf.P("Field: headerSpec.GetName(),")
        gf.P(`Description: fmt.Sprintf("required header '%s' is missing", headerSpec.GetName()),`)
        gf.P("})")
        gf.P("continue")
        gf.P("}")
        gf.P()
        gf.P("if err := validateHeaderValue(headerSpec, value); err != nil {")
        gf.P("violations = append(violations, &amp;sebufhttp.FieldViolation{")
        gf.P("Field: headerSpec.GetName(),")
        gf.P(`Description: fmt.Sprintf("header '%s' validation failed: %v", headerSpec.GetName(), err),`)
        gf.P("})")
        gf.P("}")
        gf.P("}")
        gf.P()
}</span>

// generateValidationErrorReturn generates the validation error return logic.
func (g *Generator) generateValidationErrorReturn(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        gf.P("// Return ValidationError if there are violations")
        gf.P("if len(violations) &gt; 0 {")
        gf.P("return &amp;sebufhttp.ValidationError{")
        gf.P("Violations: violations,")
        gf.P("}")
        gf.P("}")
        gf.P()
        gf.P("return nil")
}</span>

// generateValidateHeaderValueFunction generates the header value validation function.
func (g *Generator) generateValidateHeaderValueFunction(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        gf.P("// validateHeaderValue validates a single header value against its specification")
        gf.P("func validateHeaderValue(headerSpec *sebufhttp.Header, value string) error {")
        gf.P("headerType := headerSpec.GetType()")
        gf.P("format := headerSpec.GetFormat()")
        gf.P()
        gf.P("// Validate based on type")
        gf.P("switch headerType {")
        gf.P("case \"string\":")
        gf.P("return validateStringHeader(value, format)")
        gf.P("case \"integer\":")
        gf.P("return validateIntegerHeader(value)")
        gf.P("case \"number\":")
        gf.P("return validateNumberHeader(value)")
        gf.P("case \"boolean\":")
        gf.P("return validateBooleanHeader(value)")
        gf.P("case \"array\":")
        gf.P("return validateArrayHeader(value)")
        gf.P("default:")
        gf.P("// Default to string validation if type is not specified")
        gf.P("return validateStringHeader(value, format)")
        gf.P("}")
        gf.P("}")
        gf.P()
}</span>

// generateTypeValidators generates type-specific validation functions.
func (g *Generator) generateTypeValidators(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        g.generateStringValidator(gf)
        g.generateNumericValidators(gf)
        g.generateArrayValidator(gf)
}</span>

// generateStringValidator generates string header validation function.
func (g *Generator) generateStringValidator(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        gf.P("// validateStringHeader validates string headers with optional format validation")
        gf.P("func validateStringHeader(value, format string) error {")
        gf.P("if !utf8.ValidString(value) {")
        gf.P(`return fmt.Errorf("value is not valid UTF-8")`)
        gf.P("}")
        gf.P()
        gf.P("// Apply format-specific validation")
        gf.P("switch format {")
        gf.P("case \"uuid\":")
        gf.P("return validateUUIDFormat(value)")
        gf.P("case \"email\":")
        gf.P("return validateEmailFormat(value)")
        gf.P("case \"date-time\":")
        gf.P("return validateDateTimeFormat(value)")
        gf.P("case \"date\":")
        gf.P("return validateDateFormat(value)")
        gf.P("case \"time\":")
        gf.P("return validateTimeFormat(value)")
        gf.P("}")
        gf.P()
        gf.P("return nil")
        gf.P("}")
        gf.P()
}</span>

// generateNumericValidators generates numeric header validation functions.
//
//nolint:dupl // Code generation patterns naturally have similar structure
func (g *Generator) generateNumericValidators(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        // Integer header validation
        gf.P("// validateIntegerHeader validates integer headers")
        gf.P("func validateIntegerHeader(value string) error {")
        gf.P("_, err := strconv.ParseInt(value, 10, 64)")
        gf.P("if err != nil {")
        gf.P(`return fmt.Errorf("value is not a valid integer: %w", err)`)
        gf.P("}")
        gf.P("return nil")
        gf.P("}")
        gf.P()

        // Number header validation
        gf.P("// validateNumberHeader validates numeric headers (float)")
        gf.P("func validateNumberHeader(value string) error {")
        gf.P("_, err := strconv.ParseFloat(value, 64)")
        gf.P("if err != nil {")
        gf.P(`return fmt.Errorf("value is not a valid number: %w", err)`)
        gf.P("}")
        gf.P("return nil")
        gf.P("}")
        gf.P()

        // Boolean header validation
        gf.P("// validateBooleanHeader validates boolean headers")
        gf.P("func validateBooleanHeader(value string) error {")
        gf.P("_, err := strconv.ParseBool(value)")
        gf.P("if err != nil {")
        gf.P(`return fmt.Errorf("value is not a valid boolean: %w", err)`)
        gf.P("}")
        gf.P("return nil")
        gf.P("}")
        gf.P()
}</span>

// generateArrayValidator generates array header validation function.
func (g *Generator) generateArrayValidator(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        gf.P("// validateArrayHeader validates array headers (comma-separated values)")
        gf.P("func validateArrayHeader(value string) error {")
        gf.P("// Arrays are typically comma-separated values")
        gf.P("// Basic validation: ensure it's not empty")
        gf.P("if strings.TrimSpace(value) == \"\" {")
        gf.P(`return fmt.Errorf("array value cannot be empty")`)
        gf.P("}")
        gf.P("return nil")
        gf.P("}")
        gf.P()
}</span>

// generateFormatValidators generates format-specific validation functions.
func (g *Generator) generateFormatValidators(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        g.generateUUIDValidator(gf)
        g.generateEmailValidator(gf)
        g.generateDateTimeValidators(gf)
}</span>

// generateUUIDValidator generates UUID format validation function.
func (g *Generator) generateUUIDValidator(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        gf.P("// validateUUIDFormat validates UUID format (basic check)")
        gf.P("func validateUUIDFormat(value string) error {")
        gf.P("// Basic UUID format check: 8-4-4-4-12 hex digits")
        gf.P("if len(value) != 36 {")
        gf.P(`return fmt.Errorf("UUID must be 36 characters long")`)
        gf.P("}")
        gf.P()
        gf.P("// Check for correct dash positions")
        gf.P("if value[8] != '-' || value[13] != '-' || value[18] != '-' || value[23] != '-' {")
        gf.P(`return fmt.Errorf("invalid UUID format")`)
        gf.P("}")
        gf.P()
        gf.P("return nil")
        gf.P("}")
        gf.P()
}</span>

// generateEmailValidator generates email format validation function.
func (g *Generator) generateEmailValidator(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        gf.P("// validateEmailFormat validates email format (basic check)")
        gf.P("func validateEmailFormat(value string) error {")
        gf.P("// Basic email format check")
        gf.P("if !strings.Contains(value, \"@\") {")
        gf.P(`return fmt.Errorf("invalid email format: missing @")`)
        gf.P("}")
        gf.P()
        gf.P("parts := strings.Split(value, \"@\")")
        gf.P("if len(parts) != 2 || parts[0] == \"\" || parts[1] == \"\" {")
        gf.P(`return fmt.Errorf("invalid email format")`)
        gf.P("}")
        gf.P()
        gf.P("return nil")
        gf.P("}")
        gf.P()
}</span>

// generateDateTimeValidators generates date/time format validation functions.
//
//nolint:dupl // Code generation patterns naturally have similar structure
func (g *Generator) generateDateTimeValidators(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        gf.P("// validateDateTimeFormat validates RFC3339 date-time format")
        gf.P("func validateDateTimeFormat(value string) error {")
        gf.P("_, err := time.Parse(time.RFC3339, value)")
        gf.P("if err != nil {")
        gf.P(`return fmt.Errorf("invalid date-time format, expected RFC3339: %w", err)`)
        gf.P("}")
        gf.P("return nil")
        gf.P("}")
        gf.P()

        gf.P("// validateDateFormat validates date format (YYYY-MM-DD)")
        gf.P("func validateDateFormat(value string) error {")
        gf.P("_, err := time.Parse(\"2006-01-02\", value)")
        gf.P("if err != nil {")
        gf.P(`return fmt.Errorf("invalid date format, expected YYYY-MM-DD: %w", err)`)
        gf.P("}")
        gf.P("return nil")
        gf.P("}")
        gf.P()

        gf.P("// validateTimeFormat validates time format (HH:MM:SS)")
        gf.P("func validateTimeFormat(value string) error {")
        gf.P("_, err := time.Parse(\"15:04:05\", value)")
        gf.P("if err != nil {")
        gf.P(`return fmt.Errorf("invalid time format, expected HH:MM:SS: %w", err)`)
        gf.P("}")
        gf.P("return nil")
        gf.P("}")
        gf.P()
}</span>

// generateHeaderGetters generates functions to get headers for service and methods.
func (g *Generator) generateHeaderGetters(gf *protogen.GeneratedFile, service *protogen.Service) error <span class="cov0" title="0">{
        // Generate service headers getter function
        serviceName := service.GoName
        gf.P("// get", serviceName, "Headers returns the service-level required headers for ", serviceName)
        gf.P("func get", serviceName, "Headers() []*sebufhttp.Header {")

        // Get actual service headers if they exist
        serviceHeaders := getServiceHeaders(service)
        if len(serviceHeaders) &gt; 0 </span><span class="cov0" title="0">{
                gf.P("return []*sebufhttp.Header{")
                for _, header := range serviceHeaders </span><span class="cov0" title="0">{
                        g.generateHeaderLiteral(gf, header)
                }</span>
                <span class="cov0" title="0">gf.P("}")</span>
        } else<span class="cov0" title="0"> {
                gf.P("return nil")
        }</span>
        <span class="cov0" title="0">gf.P("}")
        gf.P()

        // Generate method headers getter functions
        for _, method := range service.Methods </span><span class="cov0" title="0">{
                gf.P("// get", method.GoName, "Headers returns the method-level required headers for ", method.GoName)
                gf.P("func get", method.GoName, "Headers() []*sebufhttp.Header {")

                // Get actual method headers if they exist
                methodHeaders := getMethodHeaders(method)
                if len(methodHeaders) &gt; 0 </span><span class="cov0" title="0">{
                        gf.P("return []*sebufhttp.Header{")
                        for _, header := range methodHeaders </span><span class="cov0" title="0">{
                                g.generateHeaderLiteral(gf, header)
                        }</span>
                        <span class="cov0" title="0">gf.P("}")</span>
                } else<span class="cov0" title="0"> {
                        gf.P("return nil")
                }</span>
                <span class="cov0" title="0">gf.P("}")
                gf.P()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// generateHeaderLiteral generates a header literal in Go code.
func (g *Generator) generateHeaderLiteral(gf *protogen.GeneratedFile, header *http.Header) <span class="cov0" title="0">{
        gf.P("{")
        gf.P(`Name: "`, header.GetName(), `",`)
        gf.P(`Description: "`, header.GetDescription(), `",`)
        gf.P(`Type: "`, header.GetType(), `",`)
        gf.P(`Required: `, strconv.FormatBool(header.GetRequired()), `,`)
        gf.P(`Format: "`, header.GetFormat(), `",`)
        gf.P(`Example: "`, header.GetExample(), `",`)
        gf.P(`Deprecated: `, strconv.FormatBool(header.GetDeprecated()), `,`)
        gf.P("},")
}</span>

// generateParamConfigs generates path and query parameter configurations for each method.
func (g *Generator) generateParamConfigs(gf *protogen.GeneratedFile, service *protogen.Service) error <span class="cov0" title="0">{
        for _, method := range service.Methods </span><span class="cov0" title="0">{
                methodName := lowerFirst(method.GoName)

                // Generate path params config
                pathParams := g.getPathParams(method)
                gf.P("// ", methodName, "PathParams contains path parameter configuration for ", method.GoName)
                gf.P("var ", methodName, "PathParams = []PathParamConfig{")
                for _, param := range pathParams </span><span class="cov0" title="0">{
                        gf.P("{URLParam: \"", param, "\", FieldName: \"", param, "\"},")
                }</span>
                <span class="cov0" title="0">gf.P("}")
                gf.P()

                // Generate query params config
                queryParams := getQueryParams(method.Input)
                gf.P("// ", methodName, "QueryParams contains query parameter configuration for ", method.GoName)
                gf.P("var ", methodName, "QueryParams = []QueryParamConfig{")
                for _, qp := range queryParams </span><span class="cov0" title="0">{
                        gf.P(
                                "{QueryName: \"",
                                qp.ParamName,
                                "\", FieldName: \"",
                                qp.FieldName,
                                "\", Required: ",
                                strconv.FormatBool(qp.Required),
                                "},",
                        )
                }</span>
                <span class="cov0" title="0">gf.P("}")
                gf.P()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (g *Generator) generateErrorImplFile(file *protogen.File) error <span class="cov0" title="0">{
        // Find messages ending with "Error"
        var errorMessages []*protogen.Message
        for _, message := range file.Messages </span><span class="cov0" title="0">{
                if strings.HasSuffix(message.GoIdent.GoName, "Error") </span><span class="cov0" title="0">{
                        errorMessages = append(errorMessages, message)
                }</span>
        }

        // If no error messages found, skip generation
        <span class="cov0" title="0">if len(errorMessages) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Generate error implementation file
        <span class="cov0" title="0">filename := file.GeneratedFilenamePrefix + "_error_impl.pb.go"
        gf := g.plugin.NewGeneratedFile(filename, file.GoImportPath)

        g.writeHeader(gf, file)

        gf.P("import (")
        gf.P(`"fmt"`)
        gf.P()
        gf.P(`"google.golang.org/protobuf/encoding/protojson"`)
        gf.P(")")
        gf.P()

        // Generate Error() methods for each error message
        for _, message := range errorMessages </span><span class="cov0" title="0">{
                g.generateErrorMethod(gf, message)
                gf.P()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (g *Generator) generateErrorMethod(gf *protogen.GeneratedFile, message *protogen.Message) <span class="cov0" title="0">{
        typeName := message.GoIdent.GoName

        gf.P("// Error implements the error interface for ", typeName, ".")
        gf.P("// This allows ", typeName, " to be used with errors.As() and errors.Is().")
        gf.P("func (e *", typeName, ") Error() string {")
        gf.P("if e == nil {")
        gf.P(`return "`, strings.ToLower(typeName), `: &lt;nil&gt;"`)
        gf.P("}")
        gf.P()
        gf.P("jsonBytes, err := protojson.Marshal(e)")
        gf.P("if err != nil {")
        gf.P(`return fmt.Sprintf("`, strings.ToLower(typeName), `: failed to serialize (%v)", err)`)
        gf.P("}")
        gf.P()
        gf.P("return string(jsonBytes)")
        gf.P("}")
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package httpgen

import (
        "strings"

        "google.golang.org/protobuf/compiler/protogen"
        "google.golang.org/protobuf/reflect/protoreflect"
)

// generateMockFile generates a mock server implementation file.
func (g *Generator) generateMockFile(file *protogen.File) error <span class="cov0" title="0">{
        filename := file.GeneratedFilenamePrefix + "_http_mock.pb.go"
        gf := g.plugin.NewGeneratedFile(filename, file.GoImportPath)

        g.writeHeader(gf, file)

        // Imports
        gf.P("import (")
        gf.P(`"context"`)
        gf.P(`cryptorand "crypto/rand"`)
        gf.P(`"fmt"`)
        gf.P(`"math/rand"`)
        gf.P(`"strconv"`)
        gf.P(`"time"`)
        gf.P()
        gf.P(`"google.golang.org/protobuf/proto"`)
        gf.P(")")
        gf.P()

        // Generate field examples storage
        if err := g.generateFieldExamplesStorage(gf, file); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Generate mock servers for each service
        <span class="cov0" title="0">for _, service := range file.Services </span><span class="cov0" title="0">{
                if err := g.generateMockService(gf, file, service); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Generate helper functions
        <span class="cov0" title="0">g.generateMockHelpers(gf)

        return nil</span>
}

// generateFieldExamplesStorage generates storage for field examples.
func (g *Generator) generateFieldExamplesStorage(gf *protogen.GeneratedFile, file *protogen.File) error <span class="cov0" title="0">{
        gf.P("// Field examples extracted from proto definitions")
        gf.P("var fieldExamples = map[string][]string{")

        // Collect all field examples from all messages
        for _, message := range file.Messages </span><span class="cov0" title="0">{
                g.collectMessageFieldExamples(gf, message, "")
        }</span>

        <span class="cov0" title="0">gf.P("}")
        gf.P()

        return nil</span>
}

// collectMessageFieldExamples recursively collects field examples.
func (g *Generator) collectMessageFieldExamples(gf *protogen.GeneratedFile, message *protogen.Message, prefix string) <span class="cov0" title="0">{
        messagePath := prefix + string(message.Desc.Name())

        for _, field := range message.Fields </span><span class="cov0" title="0">{
                examples := getFieldExamples(field)
                if len(examples) &gt; 0 </span><span class="cov0" title="0">{
                        fieldPath := messagePath + "." + string(field.Desc.Name())
                        gf.P(`"`, fieldPath, `": {`)
                        for _, example := range examples </span><span class="cov0" title="0">{
                                gf.P(`"`, example, `",`)
                        }</span>
                        <span class="cov0" title="0">gf.P("},")</span>
                }
        }

        // Process nested messages
        <span class="cov0" title="0">for _, nested := range message.Messages </span><span class="cov0" title="0">{
                g.collectMessageFieldExamples(gf, nested, messagePath+".")
        }</span>
}

// generateMockService generates a mock implementation for a service.
func (g *Generator) generateMockService(
        gf *protogen.GeneratedFile,
        _ *protogen.File,
        service *protogen.Service,
) error <span class="cov0" title="0">{
        serviceName := service.GoName

        // Mock server struct
        gf.P("// Mock", serviceName, "Server is a mock implementation of ", serviceName, "Server.")
        gf.P("type Mock", serviceName, "Server struct {")
        gf.P("// Add any mock-specific fields here")
        gf.P("}")
        gf.P()

        // Constructor
        gf.P("// NewMock", serviceName, "Server creates a new mock server for ", serviceName, ".")
        gf.P("func NewMock", serviceName, "Server() *Mock", serviceName, "Server {")
        gf.P("return &amp;Mock", serviceName, "Server{}")
        gf.P("}")
        gf.P()

        // Generate mock methods
        for _, method := range service.Methods </span><span class="cov0" title="0">{
                if err := g.generateMockMethod(gf, service, method); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// generateMockMethod generates a mock implementation for an RPC method.
func (g *Generator) generateMockMethod(
        gf *protogen.GeneratedFile,
        service *protogen.Service,
        method *protogen.Method,
) error <span class="cov0" title="0">{
        methodName := method.GoName
        inputType := method.Input.GoIdent
        outputType := method.Output.GoIdent

        gf.P("// ", methodName, " is a mock implementation of ", service.GoName, "Server.", methodName, ".")
        gf.P(
                "func (m *Mock",
                service.GoName,
                "Server) ",
                methodName,
                "(ctx context.Context, req *",
                inputType,
                ") (*",
                outputType,
                ", error) {",
        )

        // Validate request
        gf.P("// Validate the request")
        gf.P("if msg, ok := any(req).(proto.Message); ok {")
        gf.P("if err := ValidateMessage(msg); err != nil {")
        gf.P("return nil, err")
        gf.P("}")
        gf.P("}")
        gf.P()

        // Generate response
        gf.P("// Generate mock response")
        gf.P("resp := &amp;", outputType, "{}")
        gf.P()

        // Fill response fields
        g.generateMockFieldAssignments(gf, method.Output, "resp")

        gf.P("return resp, nil")
        gf.P("}")
        gf.P()

        return nil
}</span>

// generateMockFieldAssignments generates field assignments for a message.
func (g *Generator) generateMockFieldAssignments(
        gf *protogen.GeneratedFile,
        message *protogen.Message,
        varName string,
) <span class="cov0" title="0">{
        messageName := string(message.Desc.Name())

        for _, field := range message.Fields </span><span class="cov0" title="0">{
                fieldName := field.GoName
                fieldPath := messageName + "." + string(field.Desc.Name())

                // Generate assignment based on field type
                switch field.Desc.Kind() </span>{
                case protoreflect.StringKind:<span class="cov0" title="0">
                        gf.P(
                                varName,
                                ".",
                                fieldName,
                                " = selectStringExample(\"",
                                fieldPath,
                                "\", ",
                                g.getDefaultGenerator(field),
                                ")",
                        )</span>
                case protoreflect.Int32Kind, protoreflect.Int64Kind:<span class="cov0" title="0">
                        gf.P(varName, ".", fieldName, " = selectIntExample(\"", fieldPath, "\", ", g.getDefaultValue(field), ")")</span>
                case protoreflect.BoolKind:<span class="cov0" title="0">
                        gf.P(varName, ".", fieldName, " = selectBoolExample(\"", fieldPath, "\", ", g.getDefaultValue(field), ")")</span>
                case protoreflect.FloatKind, protoreflect.DoubleKind:<span class="cov0" title="0">
                        gf.P(varName, ".", fieldName, " = selectFloatExample(\"", fieldPath, "\", ", g.getDefaultValue(field), ")")</span>
                case protoreflect.MessageKind:<span class="cov0" title="0">
                        if field.Desc.IsList() </span><span class="cov0" title="0">{
                                gf.P("// TODO: Handle repeated message field ", fieldName)
                        }</span> else<span class="cov0" title="0"> {
                                gf.P(varName, ".", fieldName, " = &amp;", field.Message.GoIdent, "{}")
                                g.generateMockFieldAssignments(gf, field.Message, varName+"."+fieldName)
                        }</span>
                case protoreflect.EnumKind,
                        protoreflect.Sint32Kind,
                        protoreflect.Uint32Kind,
                        protoreflect.Sint64Kind,
                        protoreflect.Uint64Kind,
                        protoreflect.Sfixed32Kind,
                        protoreflect.Fixed32Kind,
                        protoreflect.Sfixed64Kind,
                        protoreflect.Fixed64Kind,
                        protoreflect.BytesKind,
                        protoreflect.GroupKind:<span class="cov0" title="0">
                        gf.P("// TODO: Handle field ", fieldName, " of type ", field.Desc.Kind())</span>
                default:<span class="cov0" title="0">
                        gf.P("// TODO: Handle field ", fieldName, " of type ", field.Desc.Kind())</span>
                }
        }
}

// getDefaultGenerator returns a function name for generating default values.
func (g *Generator) getDefaultGenerator(field *protogen.Field) string <span class="cov0" title="0">{
        fieldName := strings.ToLower(string(field.Desc.Name()))

        // Check for common field names
        switch </span>{
        case strings.Contains(fieldName, "id"):<span class="cov0" title="0">
                return "generateUUID"</span>
        case strings.Contains(fieldName, "email"):<span class="cov0" title="0">
                return "generateEmail"</span>
        case strings.Contains(fieldName, "name"):<span class="cov0" title="0">
                return "generateName"</span>
        case strings.Contains(fieldName, "phone"):<span class="cov0" title="0">
                return "generatePhone"</span>
        case strings.Contains(fieldName, "address"):<span class="cov0" title="0">
                return "generateAddress"</span>
        case strings.Contains(fieldName, "url"):<span class="cov0" title="0">
                return "generateURL"</span>
        default:<span class="cov0" title="0">
                return "generateString"</span>
        }
}

// getDefaultValue returns a default value for a field.
func (g *Generator) getDefaultValue(field *protogen.Field) string <span class="cov0" title="0">{
        switch field.Desc.Kind() </span>{
        case protoreflect.Int32Kind, protoreflect.Int64Kind:<span class="cov0" title="0">
                return "42"</span>
        case protoreflect.BoolKind:<span class="cov0" title="0">
                return "true"</span>
        case protoreflect.FloatKind, protoreflect.DoubleKind:<span class="cov0" title="0">
                return "3.14"</span>
        case protoreflect.EnumKind,
                protoreflect.Sint32Kind,
                protoreflect.Uint32Kind,
                protoreflect.Sint64Kind,
                protoreflect.Uint64Kind,
                protoreflect.Sfixed32Kind,
                protoreflect.Fixed32Kind,
                protoreflect.Sfixed64Kind,
                protoreflect.Fixed64Kind,
                protoreflect.StringKind,
                protoreflect.BytesKind,
                protoreflect.MessageKind,
                protoreflect.GroupKind:<span class="cov0" title="0">
                return `""`</span>
        default:<span class="cov0" title="0">
                return `""`</span>
        }
}

// generateMockHelpers generates helper functions for mock data generation.
func (g *Generator) generateMockHelpers(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        g.generateExampleSelectors(gf)
        g.generateDefaultGenerators(gf)
        g.generateInitFunction(gf)
}</span>

// generateExampleSelectors generates functions to select examples from predefined values.
func (g *Generator) generateExampleSelectors(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        // String example selector
        gf.P("// selectStringExample selects a random example or generates a default value.")
        gf.P("func selectStringExample(fieldPath string, defaultGenerator func() string) string {")
        gf.P("if examples, ok := fieldExamples[fieldPath]; ok &amp;&amp; len(examples) &gt; 0 {")
        gf.P("return examples[rand.Intn(len(examples))]")
        gf.P("}")
        gf.P("return defaultGenerator()")
        gf.P("}")
        gf.P()

        // Int example selector
        gf.P("// selectIntExample selects a random example or returns a default value.")
        gf.P("func selectIntExample(fieldPath string, defaultValue int64) int64 {")
        gf.P("if examples, ok := fieldExamples[fieldPath]; ok &amp;&amp; len(examples) &gt; 0 {")
        gf.P("example := examples[rand.Intn(len(examples))]")
        gf.P("if v, err := strconv.ParseInt(example, 10, 64); err == nil {")
        gf.P("return v")
        gf.P("}")
        gf.P("}")
        gf.P("return defaultValue")
        gf.P("}")
        gf.P()

        // Bool example selector
        gf.P("// selectBoolExample selects a random example or returns a default value.")
        gf.P("func selectBoolExample(fieldPath string, defaultValue bool) bool {")
        gf.P("if examples, ok := fieldExamples[fieldPath]; ok &amp;&amp; len(examples) &gt; 0 {")
        gf.P("example := examples[rand.Intn(len(examples))]")
        gf.P("if v, err := strconv.ParseBool(example); err == nil {")
        gf.P("return v")
        gf.P("}")
        gf.P("}")
        gf.P("return defaultValue")
        gf.P("}")
        gf.P()

        // Float example selector
        gf.P("// selectFloatExample selects a random example or returns a default value.")
        gf.P("func selectFloatExample(fieldPath string, defaultValue float64) float64 {")
        gf.P("if examples, ok := fieldExamples[fieldPath]; ok &amp;&amp; len(examples) &gt; 0 {")
        gf.P("example := examples[rand.Intn(len(examples))]")
        gf.P("if v, err := strconv.ParseFloat(example, 64); err == nil {")
        gf.P("return v")
        gf.P("}")
        gf.P("}")
        gf.P("return defaultValue")
        gf.P("}")
        gf.P()
}</span>

// generateDefaultGenerators generates default value generator functions.
func (g *Generator) generateDefaultGenerators(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        gf.P("// Default value generators")
        gf.P("func generateUUID() string {")
        gf.P("var b [16]byte")
        gf.P("_, err := cryptorand.Read(b[:])")
        gf.P("if err != nil {")
        gf.P(`return "550e8400-e29b-41d4-a716-446655440000" // fallback`)
        gf.P("}")
        gf.P("b[6] = (b[6] &amp; 0x0f) | 0x40 // Version 4")
        gf.P("b[8] = (b[8] &amp; 0x3f) | 0x80 // Variant bits")
        gf.P("return fmt.Sprintf(\"%x-%x-%x-%x-%x\", b[0:4], b[4:6], b[6:8], b[8:10], b[10:16])")
        gf.P("}")
        gf.P()

        gf.P("func generateEmail() string {")
        gf.P(`return "user@example.com"`)
        gf.P("}")
        gf.P()

        gf.P("func generateName() string {")
        gf.P(`names := []string{"Alice Johnson", "Bob Smith", "Charlie Davis", "Diana Wilson"}`)
        gf.P("return names[rand.Intn(len(names))]")
        gf.P("}")
        gf.P()

        gf.P("func generatePhone() string {")
        gf.P(`return "+1-555-0123"`)
        gf.P("}")
        gf.P()

        gf.P("func generateAddress() string {")
        gf.P(`return "123 Main Street, Anytown, USA"`)
        gf.P("}")
        gf.P()

        gf.P("func generateURL() string {")
        gf.P(`return "https://example.com"`)
        gf.P("}")
        gf.P()

        gf.P("func generateString() string {")
        gf.P(`return "example string"`)
        gf.P("}")
        gf.P()
}</span>

// generateInitFunction generates the init function for seeding random number generator.
func (g *Generator) generateInitFunction(gf *protogen.GeneratedFile) <span class="cov0" title="0">{
        gf.P("func init() {")
        gf.P("rand.Seed(time.Now().UnixNano())")
        gf.P("}")
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package httpgen

import (
        "fmt"

        "google.golang.org/protobuf/compiler/protogen"
        "google.golang.org/protobuf/reflect/protoreflect"
)

// ValidationError represents a generation-time validation error.
type ValidationError struct {
        Service string
        Method  string
        Message string
}

// ValidateMethodConfig validates HTTP configuration for a method.
// Returns a list of validation errors found.
func ValidateMethodConfig(service *protogen.Service, method *protogen.Method) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError

        config := getMethodHTTPConfig(method)
        if config == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">serviceName := string(service.Desc.Name())
        methodName := string(method.Desc.Name())
        inputMsgName := string(method.Input.Desc.Name())

        // 1. Validate path variables have corresponding fields
        for _, param := range config.PathParams </span><span class="cov0" title="0">{
                field := findFieldByProtoName(method.Input, param)
                if field == nil </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Service: serviceName,
                                Method:  methodName,
                                Message: fmt.Sprintf(
                                        "path variable '{%s}' in path '%s' has no matching field in message '%s'. "+
                                                "Add a field named '%s' to the request message, or fix the path variable name.",
                                        param, config.Path, inputMsgName, param),
                        })
                        continue</span>
                }

                // 2. Validate path variable field types (must be scalar)
                <span class="cov0" title="0">if !isPathParamCompatible(field) </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Service: serviceName,
                                Method:  methodName,
                                Message: fmt.Sprintf(
                                        "path variable '{%s}' is bound to field '%s' of type '%s', but path parameters must be scalar types "+
                                                "(string, int32, int64, uint32, uint64, bool, float, double). "+
                                                "Change the field type or remove it from the path.",
                                        param,
                                        param,
                                        field.Desc.Kind(),
                                ),
                        })
                }</span>
        }

        // 3. Validate query parameter fields don't conflict with path params
        <span class="cov0" title="0">queryParams := getQueryParams(method.Input)
        for _, qp := range queryParams </span><span class="cov0" title="0">{
                for _, pathParam := range config.PathParams </span><span class="cov0" title="0">{
                        if qp.FieldName == pathParam </span><span class="cov0" title="0">{
                                errors = append(errors, ValidationError{
                                        Service: serviceName,
                                        Method:  methodName,
                                        Message: fmt.Sprintf(
                                                "field '%s' is used both as a path variable in '%s' and as a query parameter. "+
                                                        "A field can only be bound to one parameter type. "+
                                                        "Remove either the path variable or the query annotation.",
                                                qp.FieldName, config.Path),
                                })
                        }</span>
                }
        }

        // 4. Error on GET/DELETE with unbound body fields
        <span class="cov0" title="0">httpMethod := config.Method
        if httpMethod == "" </span><span class="cov0" title="0">{
                httpMethod = "POST"
        }</span>

        <span class="cov0" title="0">if httpMethod == "GET" || httpMethod == "DELETE" </span><span class="cov0" title="0">{
                bodyFields := getBodyFields(method.Input, config.PathParams, queryParams)
                if len(bodyFields) &gt; 0 </span><span class="cov0" title="0">{
                        fieldNames := make([]string, 0, len(bodyFields))
                        for _, f := range bodyFields </span><span class="cov0" title="0">{
                                fieldNames = append(fieldNames, string(f.Desc.Name()))
                        }</span>
                        <span class="cov0" title="0">errors = append(errors, ValidationError{
                                Service: serviceName,
                                Method:  methodName,
                                Message: fmt.Sprintf(
                                        "%s request has fields that are not bound to path or query parameters: %v. "+
                                                "%s requests cannot have a request body. "+
                                                "Either add [(sebuf.http.query)] annotations to these fields, "+
                                                "include them in the path as variables, or change the HTTP method to POST/PUT/PATCH.",
                                        httpMethod, fieldNames, httpMethod),
                        })</span>
                }
        }

        <span class="cov0" title="0">return errors</span>
}

// findFieldByProtoName finds a field in a message by its proto name.
func findFieldByProtoName(message *protogen.Message, fieldName string) *protogen.Field <span class="cov0" title="0">{
        for _, field := range message.Fields </span><span class="cov0" title="0">{
                if string(field.Desc.Name()) == fieldName </span><span class="cov0" title="0">{
                        return field
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// isPathParamCompatible checks if a field type can be used as a path parameter.
func isPathParamCompatible(field *protogen.Field) bool <span class="cov0" title="0">{
        switch field.Desc.Kind() </span>{
        case protoreflect.StringKind,
                protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind,
                protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind,
                protoreflect.Uint32Kind, protoreflect.Fixed32Kind,
                protoreflect.Uint64Kind, protoreflect.Fixed64Kind,
                protoreflect.BoolKind,
                protoreflect.FloatKind, protoreflect.DoubleKind:<span class="cov0" title="0">
                return true</span>
        case protoreflect.EnumKind, protoreflect.BytesKind, protoreflect.MessageKind, protoreflect.GroupKind:<span class="cov0" title="0">
                return false</span>
        }
        <span class="cov0" title="0">return false</span>
}

// getBodyFields returns fields that are not bound to path or query parameters.
func getBodyFields(message *protogen.Message, pathParams []string, queryParams []QueryParam) []*protogen.Field <span class="cov0" title="0">{
        pathParamSet := make(map[string]bool)
        for _, p := range pathParams </span><span class="cov0" title="0">{
                pathParamSet[p] = true
        }</span>

        <span class="cov0" title="0">queryParamSet := make(map[string]bool)
        for _, qp := range queryParams </span><span class="cov0" title="0">{
                queryParamSet[qp.FieldName] = true
        }</span>

        <span class="cov0" title="0">var bodyFields []*protogen.Field
        for _, field := range message.Fields </span><span class="cov0" title="0">{
                fieldName := string(field.Desc.Name())
                if !pathParamSet[fieldName] &amp;&amp; !queryParamSet[fieldName] </span><span class="cov0" title="0">{
                        bodyFields = append(bodyFields, field)
                }</span>
        }

        <span class="cov0" title="0">return bodyFields</span>
}

// ValidateService validates all methods in a service.
// Returns an error if any validation issues are found, stopping code generation.
func ValidateService(service *protogen.Service) error <span class="cov0" title="0">{
        for _, method := range service.Methods </span><span class="cov0" title="0">{
                errors := ValidateMethodConfig(service, method)
                if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                        // Return the first error to fail fast
                        err := errors[0]
                        return fmt.Errorf("%s.%s: %s", err.Service, err.Method, err.Message)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package openapiv3

import (
        "fmt"
        "strings"

        "google.golang.org/protobuf/proto"

        "github.com/pb33f/libopenapi/datamodel/high/base"
        v3 "github.com/pb33f/libopenapi/datamodel/high/v3"
        "github.com/pb33f/libopenapi/orderedmap"
        yaml "go.yaml.in/yaml/v4"
        "google.golang.org/protobuf/compiler/protogen"
        k8syaml "sigs.k8s.io/yaml"
)

// OutputFormat represents the output format for the OpenAPI document.
type OutputFormat string

const (
        FormatYAML OutputFormat = "yaml"
        FormatJSON OutputFormat = "json"
)

// Generator generates OpenAPI v3.1 documents from Protocol Buffer definitions.
type Generator struct {
        doc     *v3.Document
        schemas *orderedmap.Map[string, *base.SchemaProxy]
        format  OutputFormat
}

// NewGenerator creates a new OpenAPI generator with the specified output format.
func NewGenerator(format OutputFormat) *Generator <span class="cov5" title="4">{
        schemas := orderedmap.New[string, *base.SchemaProxy]()

        // Add built-in validation error schemas
        addValidationErrorSchemas(schemas)

        return &amp;Generator{
                format:  format,
                schemas: schemas,
                doc: &amp;v3.Document{
                        Version: "3.1.0",
                        Info: &amp;base.Info{
                                Title:   "Generated API",
                                Version: "1.0.0",
                        },
                        Paths: &amp;v3.Paths{
                                PathItems: orderedmap.New[string, *v3.PathItem](),
                        },
                        Components: &amp;v3.Components{
                                Schemas: schemas,
                        },
                },
        }
}</span>

// ProcessMessage processes a single message and adds it to the OpenAPI schemas.
// This is now exported to be called from main.go.
func (g *Generator) ProcessMessage(message *protogen.Message) <span class="cov0" title="0">{
        g.processMessage(message)
}</span>

// Format returns the output format of the generator.
func (g *Generator) Format() OutputFormat <span class="cov3" title="2">{
        return g.format
}</span>

// Doc returns the OpenAPI document.
func (g *Generator) Doc() *v3.Document <span class="cov10" title="20">{
        return g.doc
}</span>

// Schemas returns the schemas map.
func (g *Generator) Schemas() *orderedmap.Map[string, *base.SchemaProxy] <span class="cov3" title="2">{
        return g.schemas
}</span>

// ProcessService processes a single service and adds its paths to the OpenAPI document.
// This is now exported to be called from main.go.
func (g *Generator) ProcessService(service *protogen.Service) <span class="cov0" title="0">{
        // Update document info with service name
        g.doc.Info.Title = fmt.Sprintf("%s API", service.Desc.Name())

        // Process the service
        g.processService(service)
}</span>

// CollectReferencedMessages recursively collects all messages referenced by a service.
// This includes input/output messages and all their nested field types.
func (g *Generator) CollectReferencedMessages(service *protogen.Service) <span class="cov0" title="0">{
        // Track processed messages to avoid infinite recursion
        processed := make(map[string]bool)

        // Collect messages from all methods
        for _, method := range service.Methods </span><span class="cov0" title="0">{
                g.collectMessageRecursive(method.Input, processed)
                g.collectMessageRecursive(method.Output, processed)
        }</span>
}

// collectMessageRecursive recursively processes a message and all its dependencies.
func (g *Generator) collectMessageRecursive(message *protogen.Message, processed map[string]bool) <span class="cov0" title="0">{
        if message == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Use the fully qualified name as the key to avoid duplicates
        <span class="cov0" title="0">key := string(message.Desc.FullName())
        if processed[key] </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">processed[key] = true

        // Process this message
        g.processMessage(message)

        // Process all field types
        for _, field := range message.Fields </span><span class="cov0" title="0">{
                if field.Message != nil </span><span class="cov0" title="0">{
                        // Recursively process message fields
                        g.collectMessageRecursive(field.Message, processed)
                }</span>

                // For maps, the value type might be a message
                <span class="cov0" title="0">if field.Desc.IsMap() &amp;&amp; field.Message != nil </span><span class="cov0" title="0">{
                        // Map entry messages have a value field (field 2)
                        for _, mapField := range field.Message.Fields </span><span class="cov0" title="0">{
                                if mapField.Desc.Number() == 2 &amp;&amp; mapField.Message != nil </span><span class="cov0" title="0">{
                                        g.collectMessageRecursive(mapField.Message, processed)
                                }</span>
                        }
                }
        }

        // Process nested messages
        <span class="cov0" title="0">for _, nested := range message.Messages </span><span class="cov0" title="0">{
                g.collectMessageRecursive(nested, processed)
        }</span>
}

// getSchemaName generates a schema name for a protobuf message.
// Since each service generates its own OpenAPI file, we can use simple message names
// without package prefixes to avoid collisions.
func (g *Generator) getSchemaName(message *protogen.Message) string <span class="cov0" title="0">{
        return string(message.Desc.Name())
}</span>

// processMessage converts a protobuf message to an OpenAPI schema.
func (g *Generator) processMessage(message *protogen.Message) <span class="cov0" title="0">{
        schema := g.buildObjectSchema(message)
        schemaName := g.getSchemaName(message)
        g.schemas.Set(schemaName, schema)

        // Process nested messages recursively
        for _, nested := range message.Messages </span><span class="cov0" title="0">{
                g.processMessage(nested)
        }</span>
}

// buildObjectSchema creates an OpenAPI object schema from a protobuf message.
func (g *Generator) buildObjectSchema(message *protogen.Message) *base.SchemaProxy <span class="cov0" title="0">{
        properties := orderedmap.New[string, *base.SchemaProxy]()
        var required []string

        for _, field := range message.Fields </span><span class="cov0" title="0">{
                fieldSchema := g.convertField(field)
                fieldName := field.Desc.JSONName()
                properties.Set(fieldName, fieldSchema)

                // Check if field has the required constraint from buf.validate
                if checkIfFieldRequired(field) </span><span class="cov0" title="0">{
                        required = append(required, fieldName)
                }</span>
        }

        <span class="cov0" title="0">schema := &amp;base.Schema{
                Type:       []string{"object"},
                Properties: properties,
        }

        if len(required) &gt; 0 </span><span class="cov0" title="0">{
                schema.Required = required
        }</span>

        // Add description from comments
        <span class="cov0" title="0">if message.Comments.Leading != "" </span><span class="cov0" title="0">{
                schema.Description = strings.TrimSpace(string(message.Comments.Leading))
        }</span>

        <span class="cov0" title="0">return base.CreateSchemaProxy(schema)</span>
}

// processService converts a protobuf service to OpenAPI paths.
func (g *Generator) processService(service *protogen.Service) <span class="cov0" title="0">{
        for _, method := range service.Methods </span><span class="cov0" title="0">{
                g.processMethod(service, method)
        }</span>
}

// methodHTTPInfo holds extracted HTTP configuration for a method.
type methodHTTPInfo struct {
        path       string
        httpMethod string
        pathParams []string
}

// extractMethodHTTPInfo extracts HTTP configuration from service and method annotations.
func extractMethodHTTPInfo(service *protogen.Service, method *protogen.Method) methodHTTPInfo <span class="cov0" title="0">{
        serviceConfig := getServiceHTTPConfig(service)
        methodConfig := getMethodHTTPConfig(method)

        var path, httpMethod string
        var pathParams []string

        if serviceConfig != nil || methodConfig != nil </span><span class="cov0" title="0">{
                servicePath := ""
                methodPath := ""

                if serviceConfig != nil </span><span class="cov0" title="0">{
                        servicePath = serviceConfig.BasePath
                }</span>
                <span class="cov0" title="0">if methodConfig != nil </span><span class="cov0" title="0">{
                        methodPath = methodConfig.Path
                        httpMethod = methodConfig.Method
                        pathParams = methodConfig.PathParams
                }</span>

                <span class="cov0" title="0">path = buildHTTPPath(servicePath, methodPath)</span>
        } else<span class="cov0" title="0"> {
                path = fmt.Sprintf("/%s/%s", service.Desc.Name(), method.Desc.Name())
        }</span>

        <span class="cov0" title="0">if httpMethod == "" </span><span class="cov0" title="0">{
                httpMethod = httpMethodPost
        }</span>

        <span class="cov0" title="0">return methodHTTPInfo{path: path, httpMethod: httpMethod, pathParams: pathParams}</span>
}

// buildPathParameters creates OpenAPI path parameters from path variable names.
func (g *Generator) buildPathParameters(method *protogen.Method, pathParams []string) []*v3.Parameter <span class="cov0" title="0">{
        var parameters []*v3.Parameter
        for _, paramName := range pathParams </span><span class="cov0" title="0">{
                field := findFieldByName(method.Input, paramName)
                pathParam := &amp;v3.Parameter{
                        Name:     paramName,
                        In:       "path",
                        Required: proto.Bool(true),
                }
                if field != nil </span><span class="cov0" title="0">{
                        pathParam.Schema = g.createFieldSchema(field)
                        pathParam.Description = strings.TrimSpace(string(field.Comments.Leading))
                }</span> else<span class="cov0" title="0"> {
                        pathParam.Schema = base.CreateSchemaProxy(&amp;base.Schema{Type: []string{"string"}})
                }</span>
                <span class="cov0" title="0">parameters = append(parameters, pathParam)</span>
        }
        <span class="cov0" title="0">return parameters</span>
}

// buildQueryParameters creates OpenAPI query parameters from method input.
func (g *Generator) buildQueryParameters(method *protogen.Method) []*v3.Parameter <span class="cov0" title="0">{
        var parameters []*v3.Parameter
        queryParams := getQueryParams(method.Input)
        for _, qp := range queryParams </span><span class="cov0" title="0">{
                queryParam := &amp;v3.Parameter{
                        Name:     qp.ParamName,
                        In:       "query",
                        Required: &amp;qp.Required,
                }
                if qp.Field != nil </span><span class="cov0" title="0">{
                        queryParam.Schema = g.createFieldSchema(qp.Field)
                        queryParam.Description = strings.TrimSpace(string(qp.Field.Comments.Leading))
                }</span> else<span class="cov0" title="0"> {
                        queryParam.Schema = base.CreateSchemaProxy(&amp;base.Schema{Type: []string{"string"}})
                }</span>
                <span class="cov0" title="0">parameters = append(parameters, queryParam)</span>
        }
        <span class="cov0" title="0">return parameters</span>
}

// buildResponses creates the standard response map for an operation.
func (g *Generator) buildResponses(method *protogen.Method) *orderedmap.Map[string, *v3.Response] <span class="cov0" title="0">{
        responses := orderedmap.New[string, *v3.Response]()

        // Success response
        outputSchemaRef := fmt.Sprintf("#/components/schemas/%s", g.getSchemaName(method.Output))
        successResponse := &amp;v3.Response{
                Description: "Successful response",
                Content:     orderedmap.New[string, *v3.MediaType](),
        }
        successResponse.Content.Set("application/json", &amp;v3.MediaType{
                Schema: base.CreateSchemaProxyRef(outputSchemaRef),
        })
        responses.Set("200", successResponse)

        // Validation error response
        validationErrorResponse := &amp;v3.Response{
                Description: "Validation error",
                Content:     orderedmap.New[string, *v3.MediaType](),
        }
        validationErrorResponse.Content.Set("application/json", &amp;v3.MediaType{
                Schema: base.CreateSchemaProxyRef("#/components/schemas/ValidationError"),
        })
        responses.Set("400", validationErrorResponse)

        // Default error response
        errorProps := orderedmap.New[string, *base.SchemaProxy]()
        errorProps.Set("error", base.CreateSchemaProxy(&amp;base.Schema{Type: []string{"string"}}))
        errorProps.Set("code", base.CreateSchemaProxy(&amp;base.Schema{Type: []string{"integer"}}))
        errorSchema := base.CreateSchemaProxy(&amp;base.Schema{Type: []string{"object"}, Properties: errorProps})

        errorResponse := &amp;v3.Response{
                Description: "Error response",
                Content:     orderedmap.New[string, *v3.MediaType](),
        }
        errorResponse.Content.Set("application/json", &amp;v3.MediaType{Schema: errorSchema})
        responses.Set("default", errorResponse)

        return responses
}</span>

// assignOperationToPathItem assigns an operation to the correct HTTP method on a path item.
func assignOperationToPathItem(pathItem *v3.PathItem, httpMethod string, operation *v3.Operation) <span class="cov0" title="0">{
        switch httpMethod </span>{
        case httpMethodGet:<span class="cov0" title="0">
                pathItem.Get = operation</span>
        case httpMethodPost:<span class="cov0" title="0">
                pathItem.Post = operation</span>
        case httpMethodPut:<span class="cov0" title="0">
                pathItem.Put = operation</span>
        case httpMethodDelete:<span class="cov0" title="0">
                pathItem.Delete = operation</span>
        case httpMethodPatch:<span class="cov0" title="0">
                pathItem.Patch = operation</span>
        default:<span class="cov0" title="0">
                pathItem.Post = operation</span>
        }
}

// processMethod converts a protobuf RPC method to an OpenAPI operation.
func (g *Generator) processMethod(service *protogen.Service, method *protogen.Method) <span class="cov0" title="0">{
        info := extractMethodHTTPInfo(service, method)

        operation := &amp;v3.Operation{
                OperationId: string(method.Desc.Name()),
                Summary:     string(method.Desc.Name()),
                Tags:        []string{string(service.Desc.Name())},
        }

        if method.Comments.Leading != "" </span><span class="cov0" title="0">{
                operation.Description = strings.TrimSpace(string(method.Comments.Leading))
        }</span>

        // Build parameters
        <span class="cov0" title="0">var parameters []*v3.Parameter
        allHeaders := combineHeaders(getServiceHeaders(service), getMethodHeaders(method))
        if len(allHeaders) &gt; 0 </span><span class="cov0" title="0">{
                parameters = convertHeadersToParameters(allHeaders)
        }</span>
        <span class="cov0" title="0">parameters = append(parameters, g.buildPathParameters(method, info.pathParams)...)
        parameters = append(parameters, g.buildQueryParameters(method)...)

        if len(parameters) &gt; 0 </span><span class="cov0" title="0">{
                operation.Parameters = parameters
        }</span>

        // Add request body for POST, PUT, PATCH
        <span class="cov0" title="0">if info.httpMethod == httpMethodPost || info.httpMethod == httpMethodPut || info.httpMethod == httpMethodPatch </span><span class="cov0" title="0">{
                inputSchemaRef := fmt.Sprintf("#/components/schemas/%s", g.getSchemaName(method.Input))
                operation.RequestBody = &amp;v3.RequestBody{
                        Required: proto.Bool(true),
                        Content:  orderedmap.New[string, *v3.MediaType](),
                }
                operation.RequestBody.Content.Set("application/json", &amp;v3.MediaType{
                        Schema: base.CreateSchemaProxyRef(inputSchemaRef),
                })
        }</span>

        <span class="cov0" title="0">operation.Responses = &amp;v3.Responses{Codes: g.buildResponses(method)}

        // Add to path items
        existingPathItem, exists := g.doc.Paths.PathItems.Get(info.path)
        if !exists </span><span class="cov0" title="0">{
                existingPathItem = &amp;v3.PathItem{}
        }</span>
        <span class="cov0" title="0">assignOperationToPathItem(existingPathItem, info.httpMethod, operation)
        g.doc.Paths.PathItems.Set(info.path, existingPathItem)</span>
}

// findFieldByName finds a field in a message by its proto name.
func findFieldByName(message *protogen.Message, fieldName string) *protogen.Field <span class="cov0" title="0">{
        for _, field := range message.Fields </span><span class="cov0" title="0">{
                if string(field.Desc.Name()) == fieldName </span><span class="cov0" title="0">{
                        return field
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// createFieldSchema creates an OpenAPI schema for a protobuf field.
func (g *Generator) createFieldSchema(field *protogen.Field) *base.SchemaProxy <span class="cov0" title="0">{
        schema := &amp;base.Schema{}

        switch field.Desc.Kind().String() </span>{
        case headerTypeString:<span class="cov0" title="0">
                schema.Type = []string{headerTypeString}</span>
        case headerTypeInt32, "sint32", "sfixed32":<span class="cov0" title="0">
                schema.Type = []string{headerTypeInteger}
                schema.Format = headerTypeInt32</span>
        case headerTypeInt64, "sint64", "sfixed64":<span class="cov0" title="0">
                schema.Type = []string{headerTypeInteger}
                schema.Format = headerTypeInt64</span>
        case "uint32", "fixed32":<span class="cov0" title="0">
                schema.Type = []string{headerTypeInteger}
                schema.Format = headerTypeInt32</span>
        case "uint64", "fixed64":<span class="cov0" title="0">
                schema.Type = []string{headerTypeInteger}
                schema.Format = headerTypeInt64</span>
        case "bool":<span class="cov0" title="0">
                schema.Type = []string{"boolean"}</span>
        case headerTypeFloat:<span class="cov0" title="0">
                schema.Type = []string{headerTypeNumber}
                schema.Format = headerTypeFloat</span>
        case headerTypeDouble:<span class="cov0" title="0">
                schema.Type = []string{headerTypeNumber}
                schema.Format = headerTypeDouble</span>
        default:<span class="cov0" title="0">
                schema.Type = []string{headerTypeString}</span>
        }

        <span class="cov0" title="0">return base.CreateSchemaProxy(schema)</span>
}

// addValidationErrorSchemas adds the ValidationError and FieldViolation schemas to the components.
func addValidationErrorSchemas(schemas *orderedmap.Map[string, *base.SchemaProxy]) <span class="cov5" title="4">{
        // Add FieldViolation schema
        fieldViolationProps := orderedmap.New[string, *base.SchemaProxy]()
        fieldViolationProps.Set("field", base.CreateSchemaProxy(&amp;base.Schema{
                Type:        []string{"string"},
                Description: "The field path that failed validation (e.g., 'user.email' for nested fields). For header validation, this will be the header name (e.g., 'X-API-Key')",
        }))
        fieldViolationProps.Set("description", base.CreateSchemaProxy(&amp;base.Schema{
                Type:        []string{"string"},
                Description: "Human-readable description of the validation violation (e.g., 'must be a valid email address', 'required field missing')",
        }))

        fieldViolationSchema := base.CreateSchemaProxy(&amp;base.Schema{
                Type:        []string{"object"},
                Description: "FieldViolation describes a single validation error for a specific field.",
                Properties:  fieldViolationProps,
                Required:    []string{"field", "description"},
        })
        schemas.Set("FieldViolation", fieldViolationSchema)

        // Add ValidationError schema
        validationErrorProps := orderedmap.New[string, *base.SchemaProxy]()
        validationErrorProps.Set("violations", base.CreateSchemaProxy(&amp;base.Schema{
                Type:        []string{"array"},
                Description: "List of validation violations",
                Items: &amp;base.DynamicValue[*base.SchemaProxy, bool]{
                        A: base.CreateSchemaProxyRef("#/components/schemas/FieldViolation"),
                },
        }))

        validationErrorSchema := base.CreateSchemaProxy(&amp;base.Schema{
                Type:        []string{"object"},
                Description: "ValidationError is returned when request validation fails. It contains a list of field violations describing what went wrong.",
                Properties:  validationErrorProps,
                Required:    []string{"violations"},
        })
        schemas.Set("ValidationError", validationErrorSchema)
}</span>

// Render outputs the OpenAPI document in the specified format.
func (g *Generator) Render() ([]byte, error) <span class="cov3" title="2">{
        switch g.format </span>{
        case FormatJSON:<span class="cov1" title="1">
                // First marshal to YAML (which works correctly with libopenapi)
                yamlData, err := yaml.Marshal(g.doc)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal to YAML: %w", err)
                }</span>
                // Then convert YAML to JSON
                <span class="cov1" title="1">jsonData, err := k8syaml.YAMLToJSON(yamlData)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to convert YAML to JSON: %w", err)
                }</span>
                <span class="cov1" title="1">return jsonData, nil</span>
        case FormatYAML:<span class="cov1" title="1">
                return yaml.Marshal(g.doc)</span>
        default:<span class="cov0" title="0">
                return yaml.Marshal(g.doc)</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package openapiv3

import (
        "regexp"
        "strings"

        "github.com/pb33f/libopenapi/datamodel/high/base"
        v3 "github.com/pb33f/libopenapi/datamodel/high/v3"
        yaml "go.yaml.in/yaml/v4"
        "google.golang.org/protobuf/compiler/protogen"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/types/descriptorpb"

        "github.com/SebastienMelki/sebuf/http"
)

// pathParamRegex matches path variables like {user_id} or {id}.
var pathParamRegex = regexp.MustCompile(`\{([^}]+)\}`)

// HTTPConfig represents the HTTP configuration for a method.
type HTTPConfig struct {
        Path       string
        Method     string   // "GET", "POST", "PUT", "DELETE", "PATCH"
        PathParams []string // Path variable names extracted from path
}

// QueryParam represents a query parameter configuration extracted from a field.
type QueryParam struct {
        FieldName string
        ParamName string
        Required  bool
        Field     *protogen.Field
}

// ServiceHTTPConfig represents the HTTP configuration for a service.
type ServiceHTTPConfig struct {
        BasePath string
}

// getMethodHTTPConfig extracts HTTP configuration from method options.
func getMethodHTTPConfig(method *protogen.Method) *HTTPConfig <span class="cov0" title="0">{
        options := method.Desc.Options()
        if options == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the raw options
        <span class="cov0" title="0">methodOptions, ok := options.(*descriptorpb.MethodOptions)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract our custom extension using the generated code
        <span class="cov0" title="0">ext := proto.GetExtension(methodOptions, http.E_Config)
        if ext == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">httpConfig, ok := ext.(*http.HttpConfig)
        if !ok || httpConfig == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">path := httpConfig.GetPath()

        return &amp;HTTPConfig{
                Path:       path,
                Method:     httpMethodToString(httpConfig.GetMethod()),
                PathParams: extractPathParams(path),
        }</span>
}

// httpMethodToString converts HttpMethod enum to lowercase string for OpenAPI. Returns "post" for unspecified.
func httpMethodToString(m http.HttpMethod) string <span class="cov7" title="8">{
        switch m </span>{
        case http.HttpMethod_HTTP_METHOD_GET:<span class="cov1" title="1">
                return httpMethodGet</span>
        case http.HttpMethod_HTTP_METHOD_POST:<span class="cov1" title="1">
                return httpMethodPost</span>
        case http.HttpMethod_HTTP_METHOD_PUT:<span class="cov1" title="1">
                return httpMethodPut</span>
        case http.HttpMethod_HTTP_METHOD_DELETE:<span class="cov1" title="1">
                return httpMethodDelete</span>
        case http.HttpMethod_HTTP_METHOD_PATCH:<span class="cov1" title="1">
                return httpMethodPatch</span>
        case http.HttpMethod_HTTP_METHOD_UNSPECIFIED:<span class="cov1" title="1">
                // HTTP_METHOD_UNSPECIFIED defaults to POST for backward compatibility
                return httpMethodPost</span>
        }
        // Any unknown value defaults to POST for backward compatibility
        <span class="cov3" title="2">return httpMethodPost</span>
}

// extractPathParams parses path variables from a path string.
// Example: "/users/{user_id}/posts/{post_id}" -&gt; ["user_id", "post_id"].
func extractPathParams(path string) []string <span class="cov8" title="11">{
        matches := pathParamRegex.FindAllStringSubmatch(path, -1)
        if len(matches) == 0 </span><span class="cov5" title="5">{
                return nil
        }</span>

        <span class="cov6" title="6">params := make([]string, 0, len(matches))
        for _, match := range matches </span><span class="cov7" title="10">{
                if len(match) &gt; 1 </span><span class="cov7" title="10">{
                        params = append(params, match[1])
                }</span>
        }
        <span class="cov6" title="6">return params</span>
}

// getQueryParams extracts query parameter configurations from message fields.
func getQueryParams(message *protogen.Message) []QueryParam <span class="cov0" title="0">{
        var params []QueryParam

        for _, field := range message.Fields </span><span class="cov0" title="0">{
                options := field.Desc.Options()
                if options == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fieldOptions, ok := options.(*descriptorpb.FieldOptions)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">ext := proto.GetExtension(fieldOptions, http.E_Query)
                if ext == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">queryConfig, ok := ext.(*http.QueryConfig)
                if !ok || queryConfig == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Use the configured name, or default to the proto field name
                <span class="cov0" title="0">paramName := queryConfig.GetName()
                if paramName == "" </span><span class="cov0" title="0">{
                        paramName = string(field.Desc.Name())
                }</span>

                <span class="cov0" title="0">params = append(params, QueryParam{
                        FieldName: string(field.Desc.Name()),
                        ParamName: paramName,
                        Required:  queryConfig.GetRequired(),
                        Field:     field,
                })</span>
        }

        <span class="cov0" title="0">return params</span>
}

// getServiceHTTPConfig extracts HTTP configuration from service options.
func getServiceHTTPConfig(service *protogen.Service) *ServiceHTTPConfig <span class="cov0" title="0">{
        options := service.Desc.Options()
        if options == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the raw options
        <span class="cov0" title="0">serviceOptions, ok := options.(*descriptorpb.ServiceOptions)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract our custom extension using the generated code
        <span class="cov0" title="0">ext := proto.GetExtension(serviceOptions, http.E_ServiceConfig)
        if ext == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">serviceConfig, ok := ext.(*http.ServiceConfig)
        if !ok || serviceConfig == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;ServiceHTTPConfig{
                BasePath: serviceConfig.GetBasePath(),
        }</span>
}

// buildHTTPPath combines service base path with method path.
func buildHTTPPath(servicePath, methodPath string) string <span class="cov8" title="14">{
        // Handle empty paths
        if servicePath == "" &amp;&amp; methodPath == "" </span><span class="cov1" title="1">{
                return "/"
        }</span>
        <span class="cov8" title="13">if servicePath == "" </span><span class="cov3" title="2">{
                return ensureLeadingSlash(methodPath)
        }</span>
        <span class="cov8" title="11">if methodPath == "" </span><span class="cov3" title="2">{
                return ensureLeadingSlash(servicePath)
        }</span>

        // Clean and combine paths
        <span class="cov7" title="9">servicePath = strings.TrimSuffix(ensureLeadingSlash(servicePath), "/")
        methodPath = strings.TrimPrefix(methodPath, "/")

        return servicePath + "/" + methodPath</span>
}

// ensureLeadingSlash ensures a path starts with "/".
func ensureLeadingSlash(path string) string <span class="cov9" title="19">{
        if path == "" </span><span class="cov1" title="1">{
                return "/"
        }</span>
        <span class="cov9" title="18">if !strings.HasPrefix(path, "/") </span><span class="cov5" title="5">{
                return "/" + path
        }</span>
        <span class="cov8" title="13">return path</span>
}

// getServiceHeaders extracts header configuration from service options.
func getServiceHeaders(service *protogen.Service) []*http.Header <span class="cov0" title="0">{
        options := service.Desc.Options()
        if options == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the raw options
        <span class="cov0" title="0">serviceOptions, ok := options.(*descriptorpb.ServiceOptions)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract our custom extension using the generated code
        <span class="cov0" title="0">ext := proto.GetExtension(serviceOptions, http.E_ServiceHeaders)
        if ext == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">serviceHeaders, ok := ext.(*http.ServiceHeaders)
        if !ok || serviceHeaders == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return serviceHeaders.GetRequiredHeaders()</span>
}

// getMethodHeaders extracts header configuration from method options.
func getMethodHeaders(method *protogen.Method) []*http.Header <span class="cov0" title="0">{
        options := method.Desc.Options()
        if options == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the raw options
        <span class="cov0" title="0">methodOptions, ok := options.(*descriptorpb.MethodOptions)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract our custom extension using the generated code
        <span class="cov0" title="0">ext := proto.GetExtension(methodOptions, http.E_MethodHeaders)
        if ext == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">methodHeaders, ok := ext.(*http.MethodHeaders)
        if !ok || methodHeaders == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return methodHeaders.GetRequiredHeaders()</span>
}

// combineHeaders merges service headers with method headers, with method headers taking precedence.
func combineHeaders(serviceHeaders, methodHeaders []*http.Header) []*http.Header <span class="cov7" title="8">{
        if len(serviceHeaders) == 0 </span><span class="cov3" title="2">{
                return methodHeaders
        }</span>
        <span class="cov6" title="6">if len(methodHeaders) == 0 </span><span class="cov1" title="1">{
                return serviceHeaders
        }</span>

        // Create a map to track headers by name for deduplication
        <span class="cov5" title="5">headerMap := make(map[string]*http.Header)

        // Add service headers first
        for _, header := range serviceHeaders </span><span class="cov6" title="7">{
                if header.GetName() != "" </span><span class="cov6" title="6">{
                        headerMap[header.GetName()] = header
                }</span>
        }

        // Add method headers, overriding service headers with same name
        <span class="cov5" title="5">for _, header := range methodHeaders </span><span class="cov5" title="5">{
                if header.GetName() != "" </span><span class="cov5" title="5">{
                        headerMap[header.GetName()] = header
                }</span>
        }

        // Convert back to slice, sorted by header name for deterministic output
        <span class="cov5" title="5">result := make([]*http.Header, 0, len(headerMap))

        // Get sorted header names
        headerNames := make([]string, 0, len(headerMap))
        for name := range headerMap </span><span class="cov7" title="9">{
                headerNames = append(headerNames, name)
        }</span>

        // Sort header names to ensure deterministic order
        <span class="cov5" title="5">for i := 0; i &lt; len(headerNames); i++ </span><span class="cov7" title="9">{
                for j := i + 1; j &lt; len(headerNames); j++ </span><span class="cov5" title="5">{
                        if headerNames[i] &gt; headerNames[j] </span><span class="cov4" title="3">{
                                headerNames[i], headerNames[j] = headerNames[j], headerNames[i]
                        }</span>
                }
        }

        // Add headers in sorted order
        <span class="cov5" title="5">for _, name := range headerNames </span><span class="cov7" title="9">{
                result = append(result, headerMap[name])
        }</span>

        <span class="cov5" title="5">return result</span>
}

// convertHeadersToParameters converts proto headers to OpenAPI parameters.
func convertHeadersToParameters(headers []*http.Header) []*v3.Parameter <span class="cov0" title="0">{
        if len(headers) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">parameters := make([]*v3.Parameter, 0, len(headers))

        for _, header := range headers </span><span class="cov0" title="0">{
                if header.GetName() == "" </span><span class="cov0" title="0">{
                        continue</span> // Skip headers without names
                }

                // Create the schema for the header
                <span class="cov0" title="0">schema := &amp;base.Schema{
                        Type: []string{mapHeaderTypeToOpenAPI(header.GetType())},
                }

                // Add format if specified
                if header.GetFormat() != "" </span><span class="cov0" title="0">{
                        schema.Format = header.GetFormat()
                }</span>

                // Add example if specified
                <span class="cov0" title="0">if header.GetExample() != "" </span><span class="cov0" title="0">{
                        schema.Example = &amp;yaml.Node{
                                Kind:  yaml.ScalarNode,
                                Value: header.GetExample(),
                        }
                }</span>

                // Create the parameter
                <span class="cov0" title="0">parameter := &amp;v3.Parameter{
                        Name:        header.GetName(),
                        In:          "header",
                        Required:    &amp;header.Required,
                        Schema:      base.CreateSchemaProxy(schema),
                        Description: header.GetDescription(),
                }

                // Set deprecated if specified
                if header.GetDeprecated() </span><span class="cov0" title="0">{
                        parameter.Deprecated = true
                }</span>

                <span class="cov0" title="0">parameters = append(parameters, parameter)</span>
        }

        <span class="cov0" title="0">return parameters</span>
}

const (
        headerTypeString  = "string"
        headerTypeInt32   = "int32"
        headerTypeInt64   = "int64"
        headerTypeInteger = "integer"
        headerTypeNumber  = "number"
        headerTypeFloat   = "float"
        headerTypeDouble  = "double"
)

// HTTP method constants (lowercase for OpenAPI).
const (
        httpMethodGet    = "get"
        httpMethodPost   = "post"
        httpMethodPut    = "put"
        httpMethodDelete = "delete"
        httpMethodPatch  = "patch"
)

// mapHeaderTypeToOpenAPI maps proto header types to OpenAPI schema types.
func mapHeaderTypeToOpenAPI(headerType string) string <span class="cov10" title="21">{
        switch strings.ToLower(headerType) </span>{
        case headerTypeString, "":<span class="cov5" title="4">
                return headerTypeString</span>
        case headerTypeInteger, "int", headerTypeInt32, headerTypeInt64:<span class="cov5" title="5">
                return headerTypeInteger</span>
        case headerTypeNumber, headerTypeFloat, headerTypeDouble:<span class="cov5" title="4">
                return headerTypeNumber</span>
        case "boolean", "bool":<span class="cov4" title="3">
                return "boolean"</span>
        case "array":<span class="cov3" title="2">
                return "array"</span>
        default:<span class="cov4" title="3">
                // Default to string for unknown types
                return headerTypeString</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package openapiv3

import (
        "fmt"
        "strings"

        "github.com/pb33f/libopenapi/datamodel/high/base"
        yaml "go.yaml.in/yaml/v4"
        "google.golang.org/protobuf/compiler/protogen"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/reflect/protoreflect"
        "google.golang.org/protobuf/types/descriptorpb"

        "github.com/SebastienMelki/sebuf/http"
)

// convertField converts a protobuf field to an OpenAPI schema.
func (g *Generator) convertField(field *protogen.Field) *base.SchemaProxy <span class="cov0" title="0">{
        // Handle repeated fields (arrays)
        if field.Desc.IsList() </span><span class="cov0" title="0">{
                itemSchema := g.convertScalarField(field)
                arraySchema := &amp;base.Schema{
                        Type: []string{"array"},
                        Items: &amp;base.DynamicValue[*base.SchemaProxy, bool]{
                                A: itemSchema,
                        },
                }

                // Apply validation constraints for the array itself
                extractValidationConstraints(field, arraySchema)

                return base.CreateSchemaProxy(arraySchema)
        }</span>

        // Handle map fields
        <span class="cov0" title="0">if field.Desc.IsMap() </span><span class="cov0" title="0">{
                return g.convertMapField(field)
        }</span>

        // Handle optional fields (proto3 optional)
        <span class="cov0" title="0">schema := g.convertScalarField(field)
        if field.Desc.HasOptionalKeyword() </span><span class="cov0" title="0">{
                // For proto3 optional fields, we could add nullable: true
                // but OpenAPI 3.1 handles this differently than 3.0
                return schema
        }</span>

        <span class="cov0" title="0">return schema</span>
}

// convertScalarField handles scalar field types and message references.
func (g *Generator) convertScalarField(field *protogen.Field) *base.SchemaProxy <span class="cov0" title="0">{
        schema := &amp;base.Schema{}

        switch field.Desc.Kind() </span>{
        case protoreflect.BoolKind:<span class="cov0" title="0">
                schema.Type = []string{"boolean"}</span>

        case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:<span class="cov0" title="0">
                schema.Type = []string{headerTypeInteger}
                schema.Format = headerTypeInt32</span>

        case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:<span class="cov0" title="0">
                schema.Type = []string{headerTypeInteger}
                schema.Format = headerTypeInt64</span>

        case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:<span class="cov0" title="0">
                schema.Type = []string{headerTypeInteger}
                schema.Format = headerTypeInt32
                zero := 0.0
                schema.Minimum = &amp;zero</span>

        case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:<span class="cov0" title="0">
                schema.Type = []string{headerTypeInteger}
                schema.Format = headerTypeInt64
                zero := 0.0
                schema.Minimum = &amp;zero</span>

        case protoreflect.FloatKind:<span class="cov0" title="0">
                schema.Type = []string{headerTypeNumber}
                schema.Format = headerTypeFloat</span>

        case protoreflect.DoubleKind:<span class="cov0" title="0">
                schema.Type = []string{headerTypeNumber}
                schema.Format = headerTypeDouble</span>

        case protoreflect.StringKind:<span class="cov0" title="0">
                schema.Type = []string{"string"}</span>

        case protoreflect.BytesKind:<span class="cov0" title="0">
                schema.Type = []string{"string"}
                schema.Format = "byte"</span>

        case protoreflect.EnumKind:<span class="cov0" title="0">
                return g.convertEnumField(field)</span>

        case protoreflect.MessageKind:<span class="cov0" title="0">
                // Reference to another message
                return base.CreateSchemaProxyRef(fmt.Sprintf("#/components/schemas/%s", g.getSchemaName(field.Message)))</span>

        case protoreflect.GroupKind:<span class="cov0" title="0">
                // Groups are deprecated but still supported
                if field.Message != nil </span><span class="cov0" title="0">{
                        return base.CreateSchemaProxyRef(fmt.Sprintf("#/components/schemas/%s", g.getSchemaName(field.Message)))
                }</span>
                <span class="cov0" title="0">schema.Type = []string{"object"}</span>

        default:<span class="cov0" title="0">
                // Fallback for unknown types
                schema.Type = []string{"string"}</span>
        }

        // Add description from field comments
        <span class="cov0" title="0">if field.Comments.Leading != "" </span><span class="cov0" title="0">{
                schema.Description = strings.TrimSpace(string(field.Comments.Leading))
        }</span>

        // Apply buf.validate constraints
        <span class="cov0" title="0">extractValidationConstraints(field, schema)

        // Add field examples if available
        if examples := getFieldExamples(field); len(examples) &gt; 0 </span><span class="cov0" title="0">{
                // Set the first example as the default example
                schema.Example = &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: examples[0],
                }

                // Add all examples using OpenAPI 3.1 examples array format
                schema.Examples = make([]*yaml.Node, len(examples))
                for i, example := range examples </span><span class="cov0" title="0">{
                        schema.Examples[i] = &amp;yaml.Node{
                                Kind:  yaml.ScalarNode,
                                Value: example,
                        }
                }</span>
        }

        <span class="cov0" title="0">return base.CreateSchemaProxy(schema)</span>
}

// convertEnumField converts a protobuf enum field to an OpenAPI schema.
func (g *Generator) convertEnumField(field *protogen.Field) *base.SchemaProxy <span class="cov0" title="0">{
        if field.Enum == nil </span><span class="cov0" title="0">{
                // Fallback if enum is not available
                return base.CreateSchemaProxy(&amp;base.Schema{
                        Type: []string{"string"},
                })
        }</span>

        <span class="cov0" title="0">schema := &amp;base.Schema{
                Type: []string{"string"},
                Enum: make([]*yaml.Node, 0, len(field.Enum.Values)),
        }

        // Add enum values
        for _, value := range field.Enum.Values </span><span class="cov0" title="0">{
                schema.Enum = append(schema.Enum, &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: string(value.Desc.Name()),
                })
        }</span>

        // Add description from enum comments
        <span class="cov0" title="0">if field.Enum.Comments.Leading != "" </span><span class="cov0" title="0">{
                schema.Description = strings.TrimSpace(string(field.Enum.Comments.Leading))
        }</span>

        <span class="cov0" title="0">return base.CreateSchemaProxy(schema)</span>
}

// convertMapField converts a protobuf map field to an OpenAPI schema.
func (g *Generator) convertMapField(field *protogen.Field) *base.SchemaProxy <span class="cov0" title="0">{
        schema := &amp;base.Schema{
                Type: []string{"object"},
        }

        // For maps, we need to determine the value type
        if field.Message != nil &amp;&amp; len(field.Message.Fields) &gt;= 2 </span><span class="cov0" title="0">{
                // Map entry messages have exactly 2 fields: key (field 1) and value (field 2)
                var valueField *protogen.Field
                const mapValueFieldNumber = 2 // value field is always number 2 in protobuf map entries
                for _, f := range field.Message.Fields </span><span class="cov0" title="0">{
                        if f.Desc.Number() == mapValueFieldNumber </span><span class="cov0" title="0">{
                                valueField = f
                                break</span>
                        }
                }

                <span class="cov0" title="0">if valueField != nil </span><span class="cov0" title="0">{
                        valueSchema := g.convertScalarField(valueField)
                        schema.AdditionalProperties = &amp;base.DynamicValue[*base.SchemaProxy, bool]{
                                A: valueSchema,
                        }
                }</span>
        }

        // If we couldn't determine the value type, allow any type
        <span class="cov0" title="0">if schema.AdditionalProperties == nil </span><span class="cov0" title="0">{
                schema.AdditionalProperties = &amp;base.DynamicValue[*base.SchemaProxy, bool]{
                        B: true,
                }
        }</span>

        // Add description from field comments
        <span class="cov0" title="0">if field.Comments.Leading != "" </span><span class="cov0" title="0">{
                schema.Description = strings.TrimSpace(string(field.Comments.Leading))
        }</span>

        // Apply validation constraints for the map itself
        <span class="cov0" title="0">extractValidationConstraints(field, schema)

        return base.CreateSchemaProxy(schema)</span>
}

// getFieldExamples extracts example values from field options.
func getFieldExamples(field *protogen.Field) []string <span class="cov0" title="0">{
        options := field.Desc.Options()
        if options == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the raw options
        <span class="cov0" title="0">fieldOptions, ok := options.(*descriptorpb.FieldOptions)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract our custom extension using the generated code
        <span class="cov0" title="0">ext := proto.GetExtension(fieldOptions, http.E_FieldExamples)
        if ext == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">fieldExamples, ok := ext.(*http.FieldExamples)
        if !ok || fieldExamples == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return fieldExamples.GetValues()</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package openapiv3

import (
        "fmt"
        "strconv"

        "github.com/pb33f/libopenapi/datamodel/high/base"
        yaml "go.yaml.in/yaml/v4"
        "google.golang.org/protobuf/compiler/protogen"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/reflect/protoreflect"

        validate "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
)

// extractValidationConstraints extracts buf.validate field options and applies them to the schema.
func extractValidationConstraints(field *protogen.Field, schema *base.Schema) <span class="cov0" title="0">{
        // Get the field descriptor options
        fieldOptions := field.Desc.Options()
        if fieldOptions == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Extract the buf.validate field extension
        <span class="cov0" title="0">ext := proto.GetExtension(fieldOptions, validate.E_Field)
        if ext == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Type assert to FieldRules
        <span class="cov0" title="0">fieldConstraints, ok := ext.(*validate.FieldRules)
        if !ok || fieldConstraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Apply constraints based on field type
        <span class="cov0" title="0">switch field.Desc.Kind() </span>{
        case protoreflect.StringKind:<span class="cov0" title="0">
                applyStringConstraints(fieldConstraints, schema)</span>
        case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind,
                protoreflect.Uint32Kind, protoreflect.Fixed32Kind:<span class="cov0" title="0">
                applyInt32Constraints(fieldConstraints, schema)</span>
        case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind,
                protoreflect.Uint64Kind, protoreflect.Fixed64Kind:<span class="cov0" title="0">
                applyInt64Constraints(fieldConstraints, schema)</span>
        case protoreflect.FloatKind:<span class="cov0" title="0">
                applyFloatConstraints(fieldConstraints, schema)</span>
        case protoreflect.DoubleKind:<span class="cov0" title="0">
                applyDoubleConstraints(fieldConstraints, schema)</span>
        case protoreflect.BoolKind,
                protoreflect.EnumKind,
                protoreflect.BytesKind,
                protoreflect.MessageKind,
                protoreflect.GroupKind:<span class="cov0" title="0"></span>
                // No specific constraints for these types
        }

        // Handle repeated field constraints
        <span class="cov0" title="0">if field.Desc.IsList() </span><span class="cov0" title="0">{
                applyRepeatedConstraints(fieldConstraints, schema)
        }</span>

        // Handle map field constraints
        <span class="cov0" title="0">if field.Desc.IsMap() </span><span class="cov0" title="0">{
                applyMapConstraints(fieldConstraints, schema)
        }</span>

        // Handle required constraint
        // Note: Required is handled at the message level, not here
        // This is a marker for the parent message to add this field to required[]
        <span class="cov0" title="0">_ = fieldConstraints.GetRequired()</span>
}

// applyStringConstraints applies string validation constraints to the schema.
func applyStringConstraints(constraints *validate.FieldRules, schema *base.Schema) <span class="cov0" title="0">{
        stringConstraints := constraints.GetString()
        if stringConstraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Min and max length
        <span class="cov0" title="0">if stringConstraints.HasMinLen() </span><span class="cov0" title="0">{
                minLen := int64(stringConstraints.GetMinLen()) // #nosec G115
                schema.MinLength = &amp;minLen
        }</span>
        <span class="cov0" title="0">if stringConstraints.HasMaxLen() </span><span class="cov0" title="0">{
                maxLen := int64(stringConstraints.GetMaxLen()) // #nosec G115
                schema.MaxLength = &amp;maxLen
        }</span>

        // Pattern (regex)
        <span class="cov0" title="0">if stringConstraints.HasPattern() </span><span class="cov0" title="0">{
                schema.Pattern = stringConstraints.GetPattern()
        }</span>

        // Format constraints
        <span class="cov0" title="0">switch </span>{
        case stringConstraints.GetEmail():<span class="cov0" title="0">
                schema.Format = "email"</span>
        case stringConstraints.GetUuid():<span class="cov0" title="0">
                schema.Format = "uuid"</span>
        case stringConstraints.GetUri():<span class="cov0" title="0">
                schema.Format = "uri"</span>
        case stringConstraints.GetUriRef():<span class="cov0" title="0">
                schema.Format = "uri-reference"</span>
        case stringConstraints.GetAddress():<span class="cov0" title="0">
                // IPv4 or IPv6 address
                schema.Format = "ip"</span>
        case stringConstraints.GetHostname():<span class="cov0" title="0">
                schema.Format = "hostname"</span>
        case stringConstraints.GetIp():<span class="cov0" title="0">
                schema.Format = "ip"</span>
        case stringConstraints.GetIpv4():<span class="cov0" title="0">
                schema.Format = "ipv4"</span>
        case stringConstraints.GetIpv6():<span class="cov0" title="0">
                schema.Format = "ipv6"</span>
        }

        // Enum values (in constraint)
        <span class="cov0" title="0">if len(stringConstraints.GetIn()) &gt; 0 </span><span class="cov0" title="0">{
                schema.Enum = make([]*yaml.Node, 0, len(stringConstraints.GetIn()))
                for _, value := range stringConstraints.GetIn() </span><span class="cov0" title="0">{
                        schema.Enum = append(schema.Enum, &amp;yaml.Node{
                                Kind:  yaml.ScalarNode,
                                Value: value,
                        })
                }</span>
        }

        // Const value
        <span class="cov0" title="0">if stringConstraints.HasConst() </span><span class="cov0" title="0">{
                val := stringConstraints.GetConst()
                schema.Const = &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: val,
                }
        }</span>
}

// applyInt32Constraints applies int32 validation constraints to the schema.
func applyInt32Constraints(constraints *validate.FieldRules, schema *base.Schema) <span class="cov0" title="0">{
        int32Constraints := constraints.GetInt32()
        if int32Constraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Greater than or equal (minimum)
        <span class="cov0" title="0">if int32Constraints.HasGte() </span><span class="cov0" title="0">{
                minValue := float64(int32Constraints.GetGte())
                schema.Minimum = &amp;minValue
        }</span>

        // Greater than (exclusive minimum)
        <span class="cov0" title="0">if int32Constraints.HasGt() </span><span class="cov0" title="0">{
                minValue := float64(int32Constraints.GetGt())
                schema.ExclusiveMinimum = &amp;base.DynamicValue[bool, float64]{B: minValue}
        }</span>

        // Less than or equal (maximum)
        <span class="cov0" title="0">if int32Constraints.HasLte() </span><span class="cov0" title="0">{
                maxValue := float64(int32Constraints.GetLte())
                schema.Maximum = &amp;maxValue
        }</span>

        // Less than (exclusive maximum)
        <span class="cov0" title="0">if int32Constraints.HasLt() </span><span class="cov0" title="0">{
                maxValue := float64(int32Constraints.GetLt())
                schema.ExclusiveMaximum = &amp;base.DynamicValue[bool, float64]{B: maxValue}
        }</span>

        // Const value
        <span class="cov0" title="0">if int32Constraints.HasConst() </span><span class="cov0" title="0">{
                schema.Const = &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: strconv.Itoa(int(int32Constraints.GetConst())),
                }
        }</span>

        // Enum values (in constraint)
        <span class="cov0" title="0">if len(int32Constraints.GetIn()) &gt; 0 </span><span class="cov0" title="0">{
                schema.Enum = make([]*yaml.Node, 0, len(int32Constraints.GetIn()))
                for _, value := range int32Constraints.GetIn() </span><span class="cov0" title="0">{
                        schema.Enum = append(schema.Enum, &amp;yaml.Node{
                                Kind:  yaml.ScalarNode,
                                Value: strconv.Itoa(int(value)),
                        })
                }</span>
        }
}

// applyInt64Constraints applies int64 validation constraints to the schema.
func applyInt64Constraints(constraints *validate.FieldRules, schema *base.Schema) <span class="cov0" title="0">{
        int64Constraints := constraints.GetInt64()
        if int64Constraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Greater than or equal (minimum)
        <span class="cov0" title="0">if int64Constraints.HasGte() </span><span class="cov0" title="0">{
                minValue := float64(int64Constraints.GetGte())
                schema.Minimum = &amp;minValue
        }</span>

        // Greater than (exclusive minimum)
        <span class="cov0" title="0">if int64Constraints.HasGt() </span><span class="cov0" title="0">{
                minValue := float64(int64Constraints.GetGt())
                schema.ExclusiveMinimum = &amp;base.DynamicValue[bool, float64]{B: minValue}
        }</span>

        // Less than or equal (maximum)
        <span class="cov0" title="0">if int64Constraints.HasLte() </span><span class="cov0" title="0">{
                maxValue := float64(int64Constraints.GetLte())
                schema.Maximum = &amp;maxValue
        }</span>

        // Less than (exclusive maximum)
        <span class="cov0" title="0">if int64Constraints.HasLt() </span><span class="cov0" title="0">{
                maxValue := float64(int64Constraints.GetLt())
                schema.ExclusiveMaximum = &amp;base.DynamicValue[bool, float64]{B: maxValue}
        }</span>

        // Const value
        <span class="cov0" title="0">if int64Constraints.HasConst() </span><span class="cov0" title="0">{
                schema.Const = &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: strconv.FormatInt(int64Constraints.GetConst(), 10),
                }
        }</span>

        // Enum values (in constraint)
        <span class="cov0" title="0">if len(int64Constraints.GetIn()) &gt; 0 </span><span class="cov0" title="0">{
                schema.Enum = make([]*yaml.Node, 0, len(int64Constraints.GetIn()))
                for _, value := range int64Constraints.GetIn() </span><span class="cov0" title="0">{
                        schema.Enum = append(schema.Enum, &amp;yaml.Node{
                                Kind:  yaml.ScalarNode,
                                Value: strconv.FormatInt(value, 10),
                        })
                }</span>
        }
}

// applyFloatConstraints applies float validation constraints to the schema.
func applyFloatConstraints(constraints *validate.FieldRules, schema *base.Schema) <span class="cov0" title="0">{
        floatConstraints := constraints.GetFloat()
        if floatConstraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Greater than or equal (minimum)
        <span class="cov0" title="0">if floatConstraints.HasGte() </span><span class="cov0" title="0">{
                minValue := float64(floatConstraints.GetGte())
                schema.Minimum = &amp;minValue
        }</span>

        // Greater than (exclusive minimum)
        <span class="cov0" title="0">if floatConstraints.HasGt() </span><span class="cov0" title="0">{
                minValue := float64(floatConstraints.GetGt())
                schema.ExclusiveMinimum = &amp;base.DynamicValue[bool, float64]{B: minValue}
        }</span>

        // Less than or equal (maximum)
        <span class="cov0" title="0">if floatConstraints.HasLte() </span><span class="cov0" title="0">{
                maxValue := float64(floatConstraints.GetLte())
                schema.Maximum = &amp;maxValue
        }</span>

        // Less than (exclusive maximum)
        <span class="cov0" title="0">if floatConstraints.HasLt() </span><span class="cov0" title="0">{
                maxValue := float64(floatConstraints.GetLt())
                schema.ExclusiveMaximum = &amp;base.DynamicValue[bool, float64]{B: maxValue}
        }</span>

        // Const value
        <span class="cov0" title="0">if floatConstraints.HasConst() </span><span class="cov0" title="0">{
                schema.Const = &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: fmt.Sprintf("%g", floatConstraints.GetConst()),
                }
        }</span>

        // Enum values (in constraint)
        <span class="cov0" title="0">if len(floatConstraints.GetIn()) &gt; 0 </span><span class="cov0" title="0">{
                schema.Enum = make([]*yaml.Node, 0, len(floatConstraints.GetIn()))
                for _, value := range floatConstraints.GetIn() </span><span class="cov0" title="0">{
                        schema.Enum = append(schema.Enum, &amp;yaml.Node{
                                Kind:  yaml.ScalarNode,
                                Value: fmt.Sprintf("%g", value),
                        })
                }</span>
        }
}

// applyDoubleConstraints applies double validation constraints to the schema.
func applyDoubleConstraints(constraints *validate.FieldRules, schema *base.Schema) <span class="cov0" title="0">{
        doubleConstraints := constraints.GetDouble()
        if doubleConstraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Greater than or equal (minimum)
        <span class="cov0" title="0">if doubleConstraints.HasGte() </span><span class="cov0" title="0">{
                minValue := doubleConstraints.GetGte()
                schema.Minimum = &amp;minValue
        }</span>

        // Greater than (exclusive minimum)
        <span class="cov0" title="0">if doubleConstraints.HasGt() </span><span class="cov0" title="0">{
                minValue := doubleConstraints.GetGt()
                schema.ExclusiveMinimum = &amp;base.DynamicValue[bool, float64]{B: minValue}
        }</span>

        // Less than or equal (maximum)
        <span class="cov0" title="0">if doubleConstraints.HasLte() </span><span class="cov0" title="0">{
                maxValue := doubleConstraints.GetLte()
                schema.Maximum = &amp;maxValue
        }</span>

        // Less than (exclusive maximum)
        <span class="cov0" title="0">if doubleConstraints.HasLt() </span><span class="cov0" title="0">{
                maxValue := doubleConstraints.GetLt()
                schema.ExclusiveMaximum = &amp;base.DynamicValue[bool, float64]{B: maxValue}
        }</span>

        // Const value
        <span class="cov0" title="0">if doubleConstraints.HasConst() </span><span class="cov0" title="0">{
                schema.Const = &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: fmt.Sprintf("%g", doubleConstraints.GetConst()),
                }
        }</span>

        // Enum values (in constraint)
        <span class="cov0" title="0">if len(doubleConstraints.GetIn()) &gt; 0 </span><span class="cov0" title="0">{
                schema.Enum = make([]*yaml.Node, 0, len(doubleConstraints.GetIn()))
                for _, value := range doubleConstraints.GetIn() </span><span class="cov0" title="0">{
                        schema.Enum = append(schema.Enum, &amp;yaml.Node{
                                Kind:  yaml.ScalarNode,
                                Value: fmt.Sprintf("%g", value),
                        })
                }</span>
        }
}

// applyRepeatedConstraints applies repeated field validation constraints to the schema.
func applyRepeatedConstraints(constraints *validate.FieldRules, schema *base.Schema) <span class="cov0" title="0">{
        repeatedConstraints := constraints.GetRepeated()
        if repeatedConstraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Min items
        <span class="cov0" title="0">if repeatedConstraints.HasMinItems() </span><span class="cov0" title="0">{
                minItems := int64(repeatedConstraints.GetMinItems()) // #nosec G115
                schema.MinItems = &amp;minItems
        }</span>

        // Max items
        <span class="cov0" title="0">if repeatedConstraints.HasMaxItems() </span><span class="cov0" title="0">{
                maxItems := int64(repeatedConstraints.GetMaxItems()) // #nosec G115
                schema.MaxItems = &amp;maxItems
        }</span>

        // Unique items
        <span class="cov0" title="0">if repeatedConstraints.GetUnique() </span><span class="cov0" title="0">{
                uniqueItems := true
                schema.UniqueItems = &amp;uniqueItems
        }</span>
}

// applyMapConstraints applies map field validation constraints to the schema.
func applyMapConstraints(constraints *validate.FieldRules, schema *base.Schema) <span class="cov0" title="0">{
        mapConstraints := constraints.GetMap()
        if mapConstraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Min pairs (minProperties)
        <span class="cov0" title="0">if mapConstraints.HasMinPairs() </span><span class="cov0" title="0">{
                minProps := int64(mapConstraints.GetMinPairs()) // #nosec G115
                schema.MinProperties = &amp;minProps
        }</span>

        // Max pairs (maxProperties)
        <span class="cov0" title="0">if mapConstraints.HasMaxPairs() </span><span class="cov0" title="0">{
                maxProps := int64(mapConstraints.GetMaxPairs()) // #nosec G115
                schema.MaxProperties = &amp;maxProps
        }</span>
}

// checkIfFieldRequired checks if a field has the required constraint.
func checkIfFieldRequired(field *protogen.Field) bool <span class="cov0" title="0">{
        // Get the field descriptor options
        fieldOptions := field.Desc.Options()
        if fieldOptions == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Extract the buf.validate field extension
        <span class="cov0" title="0">ext := proto.GetExtension(fieldOptions, validate.E_Field)
        if ext == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Type assert to FieldRules
        <span class="cov0" title="0">fieldConstraints, ok := ext.(*validate.FieldRules)
        if !ok || fieldConstraints == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return fieldConstraints.GetRequired()</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
