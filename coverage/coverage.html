
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>http: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/SebastienMelki/sebuf/http/annotations.pb.go (7.9%)</option>
				
				<option value="file1">github.com/SebastienMelki/sebuf/http/errors.pb.go (24.2%)</option>
				
				<option value="file2">github.com/SebastienMelki/sebuf/http/errors_impl.go (100.0%)</option>
				
				<option value="file3">github.com/SebastienMelki/sebuf/http/headers.pb.go (9.1%)</option>
				
				<option value="file4">github.com/SebastienMelki/sebuf/internal/openapiv3/generator.go (13.0%)</option>
				
				<option value="file5">github.com/SebastienMelki/sebuf/internal/openapiv3/http_annotations.go (0.0%)</option>
				
				<option value="file6">github.com/SebastienMelki/sebuf/internal/openapiv3/types.go (0.0%)</option>
				
				<option value="file7">github.com/SebastienMelki/sebuf/internal/openapiv3/validation.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.9
//         protoc        v5.29.2
// source: proto/sebuf/http/annotations.proto

package http

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        descriptorpb "google.golang.org/protobuf/types/descriptorpb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// HttpMethod specifies the HTTP verb for an RPC method
type HttpMethod int32

const (
        // Unspecified defaults to POST for backward compatibility
        HttpMethod_HTTP_METHOD_UNSPECIFIED HttpMethod = 0
        HttpMethod_HTTP_METHOD_GET         HttpMethod = 1
        HttpMethod_HTTP_METHOD_POST        HttpMethod = 2
        HttpMethod_HTTP_METHOD_PUT         HttpMethod = 3
        HttpMethod_HTTP_METHOD_DELETE      HttpMethod = 4
        HttpMethod_HTTP_METHOD_PATCH       HttpMethod = 5
)

// Enum value maps for HttpMethod.
var (
        HttpMethod_name = map[int32]string{
                0: "HTTP_METHOD_UNSPECIFIED",
                1: "HTTP_METHOD_GET",
                2: "HTTP_METHOD_POST",
                3: "HTTP_METHOD_PUT",
                4: "HTTP_METHOD_DELETE",
                5: "HTTP_METHOD_PATCH",
        }
        HttpMethod_value = map[string]int32{
                "HTTP_METHOD_UNSPECIFIED": 0,
                "HTTP_METHOD_GET":         1,
                "HTTP_METHOD_POST":        2,
                "HTTP_METHOD_PUT":         3,
                "HTTP_METHOD_DELETE":      4,
                "HTTP_METHOD_PATCH":       5,
        }
)

func (x HttpMethod) Enum() *HttpMethod <span class="cov0" title="0">{
        p := new(HttpMethod)
        *p = x
        return p
}</span>

func (x HttpMethod) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (HttpMethod) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_proto_sebuf_http_annotations_proto_enumTypes[0].Descriptor()
}</span>

func (HttpMethod) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_proto_sebuf_http_annotations_proto_enumTypes[0]
}</span>

func (x HttpMethod) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use HttpMethod.Descriptor instead.
func (HttpMethod) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_annotations_proto_rawDescGZIP(), []int{0}
}</span>

// HttpConfig defines HTTP-specific configuration for an RPC method
type HttpConfig struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // The HTTP path for this method (supports path variables like /users/{id})
        Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
        // The HTTP method (GET, POST, PUT, DELETE, PATCH). Defaults to POST if unspecified.
        Method        HttpMethod `protobuf:"varint,2,opt,name=method,proto3,enum=sebuf.http.HttpMethod" json:"method,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *HttpConfig) Reset() <span class="cov0" title="0">{
        *x = HttpConfig{}
        mi := &amp;file_proto_sebuf_http_annotations_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *HttpConfig) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*HttpConfig) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *HttpConfig) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_sebuf_http_annotations_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use HttpConfig.ProtoReflect.Descriptor instead.
func (*HttpConfig) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_annotations_proto_rawDescGZIP(), []int{0}
}</span>

func (x *HttpConfig) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HttpConfig) GetMethod() HttpMethod <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Method
        }</span>
        <span class="cov0" title="0">return HttpMethod_HTTP_METHOD_UNSPECIFIED</span>
}

// ServiceConfig defines HTTP-specific configuration for an entire service
type ServiceConfig struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // Base path prefix for all methods in this service
        BasePath      string `protobuf:"bytes,1,opt,name=base_path,json=basePath,proto3" json:"base_path,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ServiceConfig) Reset() <span class="cov0" title="0">{
        *x = ServiceConfig{}
        mi := &amp;file_proto_sebuf_http_annotations_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ServiceConfig) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ServiceConfig) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ServiceConfig) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_sebuf_http_annotations_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ServiceConfig.ProtoReflect.Descriptor instead.
func (*ServiceConfig) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_annotations_proto_rawDescGZIP(), []int{1}
}</span>

func (x *ServiceConfig) GetBasePath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BasePath
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// FieldExamples defines example values for a field
type FieldExamples struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // List of example values for this field
        Values        []string `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *FieldExamples) Reset() <span class="cov0" title="0">{
        *x = FieldExamples{}
        mi := &amp;file_proto_sebuf_http_annotations_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *FieldExamples) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FieldExamples) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FieldExamples) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_sebuf_http_annotations_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FieldExamples.ProtoReflect.Descriptor instead.
func (*FieldExamples) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_annotations_proto_rawDescGZIP(), []int{2}
}</span>

func (x *FieldExamples) GetValues() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Values
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// QueryConfig defines query parameter configuration for a message field
type QueryConfig struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // The query parameter name in the URL (e.g., "page_size" for ?page_size=10)
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Whether this query parameter is required
        Required      bool `protobuf:"varint,2,opt,name=required,proto3" json:"required,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *QueryConfig) Reset() <span class="cov0" title="0">{
        *x = QueryConfig{}
        mi := &amp;file_proto_sebuf_http_annotations_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *QueryConfig) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*QueryConfig) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *QueryConfig) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_sebuf_http_annotations_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use QueryConfig.ProtoReflect.Descriptor instead.
func (*QueryConfig) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_annotations_proto_rawDescGZIP(), []int{3}
}</span>

func (x *QueryConfig) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *QueryConfig) GetRequired() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Required
        }</span>
        <span class="cov0" title="0">return false</span>
}

var file_proto_sebuf_http_annotations_proto_extTypes = []protoimpl.ExtensionInfo{
        {
                ExtendedType:  (*descriptorpb.MethodOptions)(nil),
                ExtensionType: (*HttpConfig)(nil),
                Field:         50003,
                Name:          "sebuf.http.config",
                Tag:           "bytes,50003,opt,name=config",
                Filename:      "proto/sebuf/http/annotations.proto",
        },
        {
                ExtendedType:  (*descriptorpb.ServiceOptions)(nil),
                ExtensionType: (*ServiceConfig)(nil),
                Field:         50004,
                Name:          "sebuf.http.service_config",
                Tag:           "bytes,50004,opt,name=service_config",
                Filename:      "proto/sebuf/http/annotations.proto",
        },
        {
                ExtendedType:  (*descriptorpb.FieldOptions)(nil),
                ExtensionType: (*FieldExamples)(nil),
                Field:         50007,
                Name:          "sebuf.http.field_examples",
                Tag:           "bytes,50007,opt,name=field_examples",
                Filename:      "proto/sebuf/http/annotations.proto",
        },
        {
                ExtendedType:  (*descriptorpb.FieldOptions)(nil),
                ExtensionType: (*QueryConfig)(nil),
                Field:         50008,
                Name:          "sebuf.http.query",
                Tag:           "bytes,50008,opt,name=query",
                Filename:      "proto/sebuf/http/annotations.proto",
        },
}

// Extension fields to descriptorpb.MethodOptions.
var (
        // optional sebuf.http.HttpConfig config = 50003;
        E_Config = &amp;file_proto_sebuf_http_annotations_proto_extTypes[0]
)

// Extension fields to descriptorpb.ServiceOptions.
var (
        // optional sebuf.http.ServiceConfig service_config = 50004;
        E_ServiceConfig = &amp;file_proto_sebuf_http_annotations_proto_extTypes[1]
)

// Extension fields to descriptorpb.FieldOptions.
var (
        // Example values for documentation/OpenAPI
        //
        // optional sebuf.http.FieldExamples field_examples = 50007;
        E_FieldExamples = &amp;file_proto_sebuf_http_annotations_proto_extTypes[2]
        // Query parameter configuration for a field
        //
        // optional sebuf.http.QueryConfig query = 50008;
        E_Query = &amp;file_proto_sebuf_http_annotations_proto_extTypes[3]
)

var File_proto_sebuf_http_annotations_proto protoreflect.FileDescriptor

const file_proto_sebuf_http_annotations_proto_rawDesc = "" +
        "\n" +
        "\"proto/sebuf/http/annotations.proto\x12\n" +
        "sebuf.http\x1a google/protobuf/descriptor.proto\"P\n" +
        "\n" +
        "HttpConfig\x12\x12\n" +
        "\x04path\x18\x01 \x01(\tR\x04path\x12.\n" +
        "\x06method\x18\x02 \x01(\x0e2\x16.sebuf.http.HttpMethodR\x06method\",\n" +
        "\rServiceConfig\x12\x1b\n" +
        "\tbase_path\x18\x01 \x01(\tR\bbasePath\"'\n" +
        "\rFieldExamples\x12\x16\n" +
        "\x06values\x18\x01 \x03(\tR\x06values\"=\n" +
        "\vQueryConfig\x12\x12\n" +
        "\x04name\x18\x01 \x01(\tR\x04name\x12\x1a\n" +
        "\brequired\x18\x02 \x01(\bR\brequired*\x98\x01\n" +
        "\n" +
        "HttpMethod\x12\x1b\n" +
        "\x17HTTP_METHOD_UNSPECIFIED\x10\x00\x12\x13\n" +
        "\x0fHTTP_METHOD_GET\x10\x01\x12\x14\n" +
        "\x10HTTP_METHOD_POST\x10\x02\x12\x13\n" +
        "\x0fHTTP_METHOD_PUT\x10\x03\x12\x16\n" +
        "\x12HTTP_METHOD_DELETE\x10\x04\x12\x15\n" +
        "\x11HTTP_METHOD_PATCH\x10\x05:P\n" +
        "\x06config\x12\x1e.google.protobuf.MethodOptions\x18ӆ\x03 \x01(\v2\x16.sebuf.http.HttpConfigR\x06config:c\n" +
        "\x0eservice_config\x12\x1f.google.protobuf.ServiceOptions\x18Ԇ\x03 \x01(\v2\x19.sebuf.http.ServiceConfigR\rserviceConfig:a\n" +
        "\x0efield_examples\x12\x1d.google.protobuf.FieldOptions\x18׆\x03 \x01(\v2\x19.sebuf.http.FieldExamplesR\rfieldExamples:N\n" +
        "\x05query\x12\x1d.google.protobuf.FieldOptions\x18؆\x03 \x01(\v2\x17.sebuf.http.QueryConfigR\x05queryB+Z)github.com/SebastienMelki/sebuf/http;httpb\x06proto3"

var (
        file_proto_sebuf_http_annotations_proto_rawDescOnce sync.Once
        file_proto_sebuf_http_annotations_proto_rawDescData []byte
)

func file_proto_sebuf_http_annotations_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_sebuf_http_annotations_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_sebuf_http_annotations_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_sebuf_http_annotations_proto_rawDesc), len(file_proto_sebuf_http_annotations_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_proto_sebuf_http_annotations_proto_rawDescData</span>
}

var file_proto_sebuf_http_annotations_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_proto_sebuf_http_annotations_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_proto_sebuf_http_annotations_proto_goTypes = []any{
        (HttpMethod)(0),                     // 0: sebuf.http.HttpMethod
        (*HttpConfig)(nil),                  // 1: sebuf.http.HttpConfig
        (*ServiceConfig)(nil),               // 2: sebuf.http.ServiceConfig
        (*FieldExamples)(nil),               // 3: sebuf.http.FieldExamples
        (*QueryConfig)(nil),                 // 4: sebuf.http.QueryConfig
        (*descriptorpb.MethodOptions)(nil),  // 5: google.protobuf.MethodOptions
        (*descriptorpb.ServiceOptions)(nil), // 6: google.protobuf.ServiceOptions
        (*descriptorpb.FieldOptions)(nil),   // 7: google.protobuf.FieldOptions
}
var file_proto_sebuf_http_annotations_proto_depIdxs = []int32{
        0, // 0: sebuf.http.HttpConfig.method:type_name -&gt; sebuf.http.HttpMethod
        5, // 1: sebuf.http.config:extendee -&gt; google.protobuf.MethodOptions
        6, // 2: sebuf.http.service_config:extendee -&gt; google.protobuf.ServiceOptions
        7, // 3: sebuf.http.field_examples:extendee -&gt; google.protobuf.FieldOptions
        7, // 4: sebuf.http.query:extendee -&gt; google.protobuf.FieldOptions
        1, // 5: sebuf.http.config:type_name -&gt; sebuf.http.HttpConfig
        2, // 6: sebuf.http.service_config:type_name -&gt; sebuf.http.ServiceConfig
        3, // 7: sebuf.http.field_examples:type_name -&gt; sebuf.http.FieldExamples
        4, // 8: sebuf.http.query:type_name -&gt; sebuf.http.QueryConfig
        9, // [9:9] is the sub-list for method output_type
        9, // [9:9] is the sub-list for method input_type
        5, // [5:9] is the sub-list for extension type_name
        1, // [1:5] is the sub-list for extension extendee
        0, // [0:1] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_proto_sebuf_http_annotations_proto_init() }</span>
func file_proto_sebuf_http_annotations_proto_init() <span class="cov8" title="1">{
        if File_proto_sebuf_http_annotations_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_sebuf_http_annotations_proto_rawDesc), len(file_proto_sebuf_http_annotations_proto_rawDesc)),
                        NumEnums:      1,
                        NumMessages:   4,
                        NumExtensions: 4,
                        NumServices:   0,
                },
                GoTypes:           file_proto_sebuf_http_annotations_proto_goTypes,
                DependencyIndexes: file_proto_sebuf_http_annotations_proto_depIdxs,
                EnumInfos:         file_proto_sebuf_http_annotations_proto_enumTypes,
                MessageInfos:      file_proto_sebuf_http_annotations_proto_msgTypes,
                ExtensionInfos:    file_proto_sebuf_http_annotations_proto_extTypes,
        }.Build()
        File_proto_sebuf_http_annotations_proto = out.File
        file_proto_sebuf_http_annotations_proto_goTypes = nil
        file_proto_sebuf_http_annotations_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.9
//         protoc        v5.29.2
// source: proto/sebuf/http/errors.proto

package http

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ValidationError is returned when request validation fails.
// It contains a list of field violations describing what went wrong.
type ValidationError struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // List of validation violations
        Violations    []*FieldViolation `protobuf:"bytes,1,rep,name=violations,proto3" json:"violations,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ValidationError) Reset() <span class="cov0" title="0">{
        *x = ValidationError{}
        mi := &amp;file_proto_sebuf_http_errors_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ValidationError) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ValidationError) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ValidationError) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_sebuf_http_errors_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ValidationError.ProtoReflect.Descriptor instead.
func (*ValidationError) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_errors_proto_rawDescGZIP(), []int{0}
}</span>

func (x *ValidationError) GetViolations() []*FieldViolation <span class="cov10" title="15">{
        if x != nil </span><span class="cov10" title="15">{
                return x.Violations
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Error is returned when a handler encounters an error.
// It contains a simple error message that the developer can customize.
type Error struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // Error message (e.g., "user not found", "database connection failed")
        Message       string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Error) Reset() <span class="cov0" title="0">{
        *x = Error{}
        mi := &amp;file_proto_sebuf_http_errors_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Error) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Error) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Error) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_sebuf_http_errors_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Error.ProtoReflect.Descriptor instead.
func (*Error) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_errors_proto_rawDescGZIP(), []int{1}
}</span>

func (x *Error) GetMessage() string <span class="cov7" title="8">{
        if x != nil </span><span class="cov7" title="8">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// FieldViolation describes a single validation error for a specific field.
type FieldViolation struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // The field path that failed validation (e.g., "user.email" for nested fields)
        // For header validation, this will be the header name (e.g., "X-API-Key")
        Field string `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
        // Human-readable description of the validation violation
        // (e.g., "must be a valid email address", "required field missing")
        Description   string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *FieldViolation) Reset() <span class="cov0" title="0">{
        *x = FieldViolation{}
        mi := &amp;file_proto_sebuf_http_errors_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *FieldViolation) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FieldViolation) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FieldViolation) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_sebuf_http_errors_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FieldViolation.ProtoReflect.Descriptor instead.
func (*FieldViolation) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_errors_proto_rawDescGZIP(), []int{2}
}</span>

func (x *FieldViolation) GetField() string <span class="cov6" title="6">{
        if x != nil </span><span class="cov6" title="6">{
                return x.Field
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FieldViolation) GetDescription() string <span class="cov6" title="5">{
        if x != nil </span><span class="cov6" title="5">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_proto_sebuf_http_errors_proto protoreflect.FileDescriptor

const file_proto_sebuf_http_errors_proto_rawDesc = "" +
        "\n" +
        "\x1dproto/sebuf/http/errors.proto\x12\n" +
        "sebuf.http\"M\n" +
        "\x0fValidationError\x12:\n" +
        "\n" +
        "violations\x18\x01 \x03(\v2\x1a.sebuf.http.FieldViolationR\n" +
        "violations\"!\n" +
        "\x05Error\x12\x18\n" +
        "\amessage\x18\x01 \x01(\tR\amessage\"H\n" +
        "\x0eFieldViolation\x12\x14\n" +
        "\x05field\x18\x01 \x01(\tR\x05field\x12 \n" +
        "\vdescription\x18\x02 \x01(\tR\vdescriptionB+Z)github.com/SebastienMelki/sebuf/http;httpb\x06proto3"

var (
        file_proto_sebuf_http_errors_proto_rawDescOnce sync.Once
        file_proto_sebuf_http_errors_proto_rawDescData []byte
)

func file_proto_sebuf_http_errors_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_sebuf_http_errors_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_sebuf_http_errors_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_sebuf_http_errors_proto_rawDesc), len(file_proto_sebuf_http_errors_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_proto_sebuf_http_errors_proto_rawDescData</span>
}

var file_proto_sebuf_http_errors_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_proto_sebuf_http_errors_proto_goTypes = []any{
        (*ValidationError)(nil), // 0: sebuf.http.ValidationError
        (*Error)(nil),           // 1: sebuf.http.Error
        (*FieldViolation)(nil),  // 2: sebuf.http.FieldViolation
}
var file_proto_sebuf_http_errors_proto_depIdxs = []int32{
        2, // 0: sebuf.http.ValidationError.violations:type_name -&gt; sebuf.http.FieldViolation
        1, // [1:1] is the sub-list for method output_type
        1, // [1:1] is the sub-list for method input_type
        1, // [1:1] is the sub-list for extension type_name
        1, // [1:1] is the sub-list for extension extendee
        0, // [0:1] is the sub-list for field type_name
}

func init() <span class="cov1" title="1">{ file_proto_sebuf_http_errors_proto_init() }</span>
func file_proto_sebuf_http_errors_proto_init() <span class="cov1" title="1">{
        if File_proto_sebuf_http_errors_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_sebuf_http_errors_proto_rawDesc), len(file_proto_sebuf_http_errors_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   3,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_proto_sebuf_http_errors_proto_goTypes,
                DependencyIndexes: file_proto_sebuf_http_errors_proto_depIdxs,
                MessageInfos:      file_proto_sebuf_http_errors_proto_msgTypes,
        }.Build()
        File_proto_sebuf_http_errors_proto = out.File
        file_proto_sebuf_http_errors_proto_goTypes = nil
        file_proto_sebuf_http_errors_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package http

import (
        "fmt"
        "strings"
)

// Error implements the error interface for ValidationError.
// This allows ValidationError to be used with errors.As() and errors.Is().
func (e *ValidationError) Error() string <span class="cov10" title="6">{
        if e == nil </span><span class="cov1" title="1">{
                return "validation error: &lt;nil&gt;"
        }</span>

        <span class="cov9" title="5">if len(e.GetViolations()) == 0 </span><span class="cov1" title="1">{
                return "validation error: no violations"
        }</span>

        <span class="cov7" title="4">if len(e.GetViolations()) == 1 </span><span class="cov6" title="3">{
                v := e.GetViolations()[0]
                return fmt.Sprintf("validation error: %s: %s", v.GetField(), v.GetDescription())
        }</span>

        // Multiple violations
        <span class="cov1" title="1">var violations []string
        for _, v := range e.GetViolations() </span><span class="cov4" title="2">{
                violations = append(violations, fmt.Sprintf("%s: %s", v.GetField(), v.GetDescription()))
        }</span>

        <span class="cov1" title="1">return fmt.Sprintf("validation error: [%s]", strings.Join(violations, ", "))</span>
}

// Error implements the error interface for Error.
// This allows Error to be used with errors.As() and errors.Is().
func (e *Error) Error() string <span class="cov9" title="5">{
        if e == nil </span><span class="cov1" title="1">{
                return "error: &lt;nil&gt;"
        }</span>

        <span class="cov7" title="4">if e.GetMessage() == "" </span><span class="cov1" title="1">{
                return "error: empty message"
        }</span>

        <span class="cov6" title="3">return e.GetMessage()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.9
//         protoc        v5.29.2
// source: proto/sebuf/http/headers.proto

package http

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        descriptorpb "google.golang.org/protobuf/types/descriptorpb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Header definition for OpenAPI specification
type Header struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // Name of the header parameter
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Description of the header parameter
        Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        // Type of the header parameter (string, integer, number, boolean, array)
        Type string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
        // Whether the header is required
        Required bool `protobuf:"varint,4,opt,name=required,proto3" json:"required,omitempty"`
        // Schema format (e.g. "uuid", "email", "date-time")
        Format string `protobuf:"bytes,5,opt,name=format,proto3" json:"format,omitempty"`
        // Example value for the header
        Example string `protobuf:"bytes,6,opt,name=example,proto3" json:"example,omitempty"`
        // Whether the header is deprecated
        Deprecated    bool `protobuf:"varint,7,opt,name=deprecated,proto3" json:"deprecated,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Header) Reset() <span class="cov0" title="0">{
        *x = Header{}
        mi := &amp;file_proto_sebuf_http_headers_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Header) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Header) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Header) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_sebuf_http_headers_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Header.ProtoReflect.Descriptor instead.
func (*Header) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_headers_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Header) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetRequired() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Required
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Header) GetFormat() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Format
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetExample() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Example
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetDeprecated() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Deprecated
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Service-level headers configuration
type ServiceHeaders struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // List of required headers for all RPCs in the service
        RequiredHeaders []*Header `protobuf:"bytes,1,rep,name=required_headers,json=requiredHeaders,proto3" json:"required_headers,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *ServiceHeaders) Reset() <span class="cov0" title="0">{
        *x = ServiceHeaders{}
        mi := &amp;file_proto_sebuf_http_headers_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ServiceHeaders) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ServiceHeaders) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ServiceHeaders) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_sebuf_http_headers_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ServiceHeaders.ProtoReflect.Descriptor instead.
func (*ServiceHeaders) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_headers_proto_rawDescGZIP(), []int{1}
}</span>

func (x *ServiceHeaders) GetRequiredHeaders() []*Header <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RequiredHeaders
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Method-level headers configuration
type MethodHeaders struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // List of required headers for this specific RPC
        RequiredHeaders []*Header `protobuf:"bytes,1,rep,name=required_headers,json=requiredHeaders,proto3" json:"required_headers,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *MethodHeaders) Reset() <span class="cov0" title="0">{
        *x = MethodHeaders{}
        mi := &amp;file_proto_sebuf_http_headers_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *MethodHeaders) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MethodHeaders) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MethodHeaders) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_sebuf_http_headers_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MethodHeaders.ProtoReflect.Descriptor instead.
func (*MethodHeaders) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_sebuf_http_headers_proto_rawDescGZIP(), []int{2}
}</span>

func (x *MethodHeaders) GetRequiredHeaders() []*Header <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RequiredHeaders
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var file_proto_sebuf_http_headers_proto_extTypes = []protoimpl.ExtensionInfo{
        {
                ExtendedType:  (*descriptorpb.ServiceOptions)(nil),
                ExtensionType: (*ServiceHeaders)(nil),
                Field:         50005,
                Name:          "sebuf.http.service_headers",
                Tag:           "bytes,50005,opt,name=service_headers",
                Filename:      "proto/sebuf/http/headers.proto",
        },
        {
                ExtendedType:  (*descriptorpb.MethodOptions)(nil),
                ExtensionType: (*MethodHeaders)(nil),
                Field:         50006,
                Name:          "sebuf.http.method_headers",
                Tag:           "bytes,50006,opt,name=method_headers",
                Filename:      "proto/sebuf/http/headers.proto",
        },
}

// Extension fields to descriptorpb.ServiceOptions.
var (
        // optional sebuf.http.ServiceHeaders service_headers = 50005;
        E_ServiceHeaders = &amp;file_proto_sebuf_http_headers_proto_extTypes[0]
)

// Extension fields to descriptorpb.MethodOptions.
var (
        // optional sebuf.http.MethodHeaders method_headers = 50006;
        E_MethodHeaders = &amp;file_proto_sebuf_http_headers_proto_extTypes[1]
)

var File_proto_sebuf_http_headers_proto protoreflect.FileDescriptor

const file_proto_sebuf_http_headers_proto_rawDesc = "" +
        "\n" +
        "\x1eproto/sebuf/http/headers.proto\x12\n" +
        "sebuf.http\x1a google/protobuf/descriptor.proto\"\xc0\x01\n" +
        "\x06Header\x12\x12\n" +
        "\x04name\x18\x01 \x01(\tR\x04name\x12 \n" +
        "\vdescription\x18\x02 \x01(\tR\vdescription\x12\x12\n" +
        "\x04type\x18\x03 \x01(\tR\x04type\x12\x1a\n" +
        "\brequired\x18\x04 \x01(\bR\brequired\x12\x16\n" +
        "\x06format\x18\x05 \x01(\tR\x06format\x12\x18\n" +
        "\aexample\x18\x06 \x01(\tR\aexample\x12\x1e\n" +
        "\n" +
        "deprecated\x18\a \x01(\bR\n" +
        "deprecated\"O\n" +
        "\x0eServiceHeaders\x12=\n" +
        "\x10required_headers\x18\x01 \x03(\v2\x12.sebuf.http.HeaderR\x0frequiredHeaders\"N\n" +
        "\rMethodHeaders\x12=\n" +
        "\x10required_headers\x18\x01 \x03(\v2\x12.sebuf.http.HeaderR\x0frequiredHeaders:f\n" +
        "\x0fservice_headers\x12\x1f.google.protobuf.ServiceOptions\x18Ն\x03 \x01(\v2\x1a.sebuf.http.ServiceHeadersR\x0eserviceHeaders:b\n" +
        "\x0emethod_headers\x12\x1e.google.protobuf.MethodOptions\x18ֆ\x03 \x01(\v2\x19.sebuf.http.MethodHeadersR\rmethodHeadersB+Z)github.com/SebastienMelki/sebuf/http;httpb\x06proto3"

var (
        file_proto_sebuf_http_headers_proto_rawDescOnce sync.Once
        file_proto_sebuf_http_headers_proto_rawDescData []byte
)

func file_proto_sebuf_http_headers_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_sebuf_http_headers_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_sebuf_http_headers_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_sebuf_http_headers_proto_rawDesc), len(file_proto_sebuf_http_headers_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_proto_sebuf_http_headers_proto_rawDescData</span>
}

var file_proto_sebuf_http_headers_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_proto_sebuf_http_headers_proto_goTypes = []any{
        (*Header)(nil),                      // 0: sebuf.http.Header
        (*ServiceHeaders)(nil),              // 1: sebuf.http.ServiceHeaders
        (*MethodHeaders)(nil),               // 2: sebuf.http.MethodHeaders
        (*descriptorpb.ServiceOptions)(nil), // 3: google.protobuf.ServiceOptions
        (*descriptorpb.MethodOptions)(nil),  // 4: google.protobuf.MethodOptions
}
var file_proto_sebuf_http_headers_proto_depIdxs = []int32{
        0, // 0: sebuf.http.ServiceHeaders.required_headers:type_name -&gt; sebuf.http.Header
        0, // 1: sebuf.http.MethodHeaders.required_headers:type_name -&gt; sebuf.http.Header
        3, // 2: sebuf.http.service_headers:extendee -&gt; google.protobuf.ServiceOptions
        4, // 3: sebuf.http.method_headers:extendee -&gt; google.protobuf.MethodOptions
        1, // 4: sebuf.http.service_headers:type_name -&gt; sebuf.http.ServiceHeaders
        2, // 5: sebuf.http.method_headers:type_name -&gt; sebuf.http.MethodHeaders
        6, // [6:6] is the sub-list for method output_type
        6, // [6:6] is the sub-list for method input_type
        4, // [4:6] is the sub-list for extension type_name
        2, // [2:4] is the sub-list for extension extendee
        0, // [0:2] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_proto_sebuf_http_headers_proto_init() }</span>
func file_proto_sebuf_http_headers_proto_init() <span class="cov8" title="1">{
        if File_proto_sebuf_http_headers_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_sebuf_http_headers_proto_rawDesc), len(file_proto_sebuf_http_headers_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   3,
                        NumExtensions: 2,
                        NumServices:   0,
                },
                GoTypes:           file_proto_sebuf_http_headers_proto_goTypes,
                DependencyIndexes: file_proto_sebuf_http_headers_proto_depIdxs,
                MessageInfos:      file_proto_sebuf_http_headers_proto_msgTypes,
                ExtensionInfos:    file_proto_sebuf_http_headers_proto_extTypes,
        }.Build()
        File_proto_sebuf_http_headers_proto = out.File
        file_proto_sebuf_http_headers_proto_goTypes = nil
        file_proto_sebuf_http_headers_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package openapiv3

import (
        "fmt"
        "strings"

        "google.golang.org/protobuf/proto"

        "github.com/pb33f/libopenapi/datamodel/high/base"
        v3 "github.com/pb33f/libopenapi/datamodel/high/v3"
        "github.com/pb33f/libopenapi/orderedmap"
        yaml "go.yaml.in/yaml/v4"
        "google.golang.org/protobuf/compiler/protogen"
        k8syaml "sigs.k8s.io/yaml"
)

// OutputFormat represents the output format for the OpenAPI document.
type OutputFormat string

const (
        FormatYAML OutputFormat = "yaml"
        FormatJSON OutputFormat = "json"
)

// Generator generates OpenAPI v3.1 documents from Protocol Buffer definitions.
type Generator struct {
        doc     *v3.Document
        schemas *orderedmap.Map[string, *base.SchemaProxy]
        format  OutputFormat
}

// NewGenerator creates a new OpenAPI generator with the specified output format.
func NewGenerator(format OutputFormat) *Generator <span class="cov5" title="4">{
        schemas := orderedmap.New[string, *base.SchemaProxy]()

        // Add built-in validation error schemas
        addValidationErrorSchemas(schemas)

        return &amp;Generator{
                format:  format,
                schemas: schemas,
                doc: &amp;v3.Document{
                        Version: "3.1.0",
                        Info: &amp;base.Info{
                                Title:   "Generated API",
                                Version: "1.0.0",
                        },
                        Paths: &amp;v3.Paths{
                                PathItems: orderedmap.New[string, *v3.PathItem](),
                        },
                        Components: &amp;v3.Components{
                                Schemas: schemas,
                        },
                },
        }
}</span>

// ProcessMessage processes a single message and adds it to the OpenAPI schemas.
// This is now exported to be called from main.go.
func (g *Generator) ProcessMessage(message *protogen.Message) <span class="cov0" title="0">{
        g.processMessage(message)
}</span>

// Format returns the output format of the generator.
func (g *Generator) Format() OutputFormat <span class="cov3" title="2">{
        return g.format
}</span>

// Doc returns the OpenAPI document.
func (g *Generator) Doc() *v3.Document <span class="cov10" title="20">{
        return g.doc
}</span>

// Schemas returns the schemas map.
func (g *Generator) Schemas() *orderedmap.Map[string, *base.SchemaProxy] <span class="cov3" title="2">{
        return g.schemas
}</span>

// ProcessService processes a single service and adds its paths to the OpenAPI document.
// This is now exported to be called from main.go.
func (g *Generator) ProcessService(service *protogen.Service) <span class="cov0" title="0">{
        // Update document info with service name
        g.doc.Info.Title = fmt.Sprintf("%s API", service.Desc.Name())

        // Process the service
        g.processService(service)
}</span>

// CollectReferencedMessages recursively collects all messages referenced by a service.
// This includes input/output messages and all their nested field types.
func (g *Generator) CollectReferencedMessages(service *protogen.Service) <span class="cov0" title="0">{
        // Track processed messages to avoid infinite recursion
        processed := make(map[string]bool)

        // Collect messages from all methods
        for _, method := range service.Methods </span><span class="cov0" title="0">{
                g.collectMessageRecursive(method.Input, processed)
                g.collectMessageRecursive(method.Output, processed)
        }</span>
}

// collectMessageRecursive recursively processes a message and all its dependencies.
func (g *Generator) collectMessageRecursive(message *protogen.Message, processed map[string]bool) <span class="cov0" title="0">{
        if message == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Use the fully qualified name as the key to avoid duplicates
        <span class="cov0" title="0">key := string(message.Desc.FullName())
        if processed[key] </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">processed[key] = true

        // Process this message
        g.processMessage(message)

        // Process all field types
        for _, field := range message.Fields </span><span class="cov0" title="0">{
                if field.Message != nil </span><span class="cov0" title="0">{
                        // Recursively process message fields
                        g.collectMessageRecursive(field.Message, processed)
                }</span>

                // For maps, the value type might be a message
                <span class="cov0" title="0">if field.Desc.IsMap() &amp;&amp; field.Message != nil </span><span class="cov0" title="0">{
                        // Map entry messages have a value field (field 2)
                        for _, mapField := range field.Message.Fields </span><span class="cov0" title="0">{
                                if mapField.Desc.Number() == 2 &amp;&amp; mapField.Message != nil </span><span class="cov0" title="0">{
                                        g.collectMessageRecursive(mapField.Message, processed)
                                }</span>
                        }
                }
        }

        // Process nested messages
        <span class="cov0" title="0">for _, nested := range message.Messages </span><span class="cov0" title="0">{
                g.collectMessageRecursive(nested, processed)
        }</span>
}

// getSchemaName generates a schema name for a protobuf message.
// Since each service generates its own OpenAPI file, we can use simple message names
// without package prefixes to avoid collisions.
func (g *Generator) getSchemaName(message *protogen.Message) string <span class="cov0" title="0">{
        return string(message.Desc.Name())
}</span>

// processMessage converts a protobuf message to an OpenAPI schema.
func (g *Generator) processMessage(message *protogen.Message) <span class="cov0" title="0">{
        schema := g.buildObjectSchema(message)
        schemaName := g.getSchemaName(message)
        g.schemas.Set(schemaName, schema)

        // Process nested messages recursively
        for _, nested := range message.Messages </span><span class="cov0" title="0">{
                g.processMessage(nested)
        }</span>
}

// buildObjectSchema creates an OpenAPI object schema from a protobuf message.
func (g *Generator) buildObjectSchema(message *protogen.Message) *base.SchemaProxy <span class="cov0" title="0">{
        properties := orderedmap.New[string, *base.SchemaProxy]()
        var required []string

        for _, field := range message.Fields </span><span class="cov0" title="0">{
                fieldSchema := g.convertField(field)
                fieldName := field.Desc.JSONName()
                properties.Set(fieldName, fieldSchema)

                // Check if field has the required constraint from buf.validate
                if checkIfFieldRequired(field) </span><span class="cov0" title="0">{
                        required = append(required, fieldName)
                }</span>
        }

        <span class="cov0" title="0">schema := &amp;base.Schema{
                Type:       []string{"object"},
                Properties: properties,
        }

        if len(required) &gt; 0 </span><span class="cov0" title="0">{
                schema.Required = required
        }</span>

        // Add description from comments
        <span class="cov0" title="0">if message.Comments.Leading != "" </span><span class="cov0" title="0">{
                schema.Description = strings.TrimSpace(string(message.Comments.Leading))
        }</span>

        <span class="cov0" title="0">return base.CreateSchemaProxy(schema)</span>
}

// processService converts a protobuf service to OpenAPI paths.
func (g *Generator) processService(service *protogen.Service) <span class="cov0" title="0">{
        for _, method := range service.Methods </span><span class="cov0" title="0">{
                g.processMethod(service, method)
        }</span>
}

// processMethod converts a protobuf RPC method to an OpenAPI operation.
func (g *Generator) processMethod(service *protogen.Service, method *protogen.Method) <span class="cov0" title="0">{
        // Extract HTTP configuration from annotations
        var path string
        var httpMethod string
        var pathParams []string

        serviceConfig := getServiceHTTPConfig(service)
        methodConfig := getMethodHTTPConfig(method)

        if serviceConfig != nil || methodConfig != nil </span><span class="cov0" title="0">{
                // Use sebuf.http annotations
                servicePath := ""
                methodPath := ""

                if serviceConfig != nil </span><span class="cov0" title="0">{
                        servicePath = serviceConfig.BasePath
                }</span>
                <span class="cov0" title="0">if methodConfig != nil </span><span class="cov0" title="0">{
                        methodPath = methodConfig.Path
                        httpMethod = methodConfig.Method
                        pathParams = methodConfig.PathParams
                }</span>

                <span class="cov0" title="0">path = buildHTTPPath(servicePath, methodPath)</span>
        } else<span class="cov0" title="0"> {
                // Fallback to gRPC-style path
                path = fmt.Sprintf("/%s/%s", service.Desc.Name(), method.Desc.Name())
        }</span>

        // Default to POST for backward compatibility
        <span class="cov0" title="0">if httpMethod == "" </span><span class="cov0" title="0">{
                httpMethod = "post"
        }</span>

        // Create operation
        <span class="cov0" title="0">operation := &amp;v3.Operation{
                OperationId: string(method.Desc.Name()),
                Summary:     string(method.Desc.Name()),
                Tags:        []string{string(service.Desc.Name())},
        }

        // Add description from comments
        if method.Comments.Leading != "" </span><span class="cov0" title="0">{
                operation.Description = strings.TrimSpace(string(method.Comments.Leading))
        }</span>

        // Extract and add header parameters
        <span class="cov0" title="0">serviceHeaders := getServiceHeaders(service)
        methodHeaders := getMethodHeaders(method)
        allHeaders := combineHeaders(serviceHeaders, methodHeaders)

        var parameters []*v3.Parameter
        if len(allHeaders) &gt; 0 </span><span class="cov0" title="0">{
                parameters = convertHeadersToParameters(allHeaders)
        }</span>

        // Add path parameters
        <span class="cov0" title="0">for _, paramName := range pathParams </span><span class="cov0" title="0">{
                field := findFieldByName(method.Input, paramName)
                pathParam := &amp;v3.Parameter{
                        Name:     paramName,
                        In:       "path",
                        Required: proto.Bool(true), // Path parameters are always required
                }
                if field != nil </span><span class="cov0" title="0">{
                        pathParam.Schema = g.createFieldSchema(field)
                        pathParam.Description = strings.TrimSpace(string(field.Comments.Leading))
                }</span> else<span class="cov0" title="0"> {
                        // Default to string if field not found
                        pathParam.Schema = base.CreateSchemaProxy(&amp;base.Schema{
                                Type: []string{"string"},
                        })
                }</span>
                <span class="cov0" title="0">parameters = append(parameters, pathParam)</span>
        }

        // Add query parameters
        <span class="cov0" title="0">queryParams := getQueryParams(method.Input)
        for _, qp := range queryParams </span><span class="cov0" title="0">{
                queryParam := &amp;v3.Parameter{
                        Name:     qp.ParamName,
                        In:       "query",
                        Required: &amp;qp.Required,
                }
                if qp.Field != nil </span><span class="cov0" title="0">{
                        queryParam.Schema = g.createFieldSchema(qp.Field)
                        queryParam.Description = strings.TrimSpace(string(qp.Field.Comments.Leading))
                }</span> else<span class="cov0" title="0"> {
                        queryParam.Schema = base.CreateSchemaProxy(&amp;base.Schema{
                                Type: []string{"string"},
                        })
                }</span>
                <span class="cov0" title="0">parameters = append(parameters, queryParam)</span>
        }

        <span class="cov0" title="0">if len(parameters) &gt; 0 </span><span class="cov0" title="0">{
                operation.Parameters = parameters
        }</span>

        // Add request body only for POST, PUT, PATCH methods
        <span class="cov0" title="0">if httpMethod == "post" || httpMethod == "put" || httpMethod == "patch" </span><span class="cov0" title="0">{
                inputSchemaRef := fmt.Sprintf("#/components/schemas/%s", g.getSchemaName(method.Input))
                operation.RequestBody = &amp;v3.RequestBody{
                        Required: proto.Bool(true),
                        Content:  orderedmap.New[string, *v3.MediaType](),
                }
                operation.RequestBody.Content.Set("application/json", &amp;v3.MediaType{
                        Schema: base.CreateSchemaProxyRef(inputSchemaRef),
                })
        }</span>

        // Add response for the output message
        <span class="cov0" title="0">outputSchemaRef := fmt.Sprintf("#/components/schemas/%s", g.getSchemaName(method.Output))
        responses := orderedmap.New[string, *v3.Response]()

        successResponse := &amp;v3.Response{
                Description: "Successful response",
                Content:     orderedmap.New[string, *v3.MediaType](),
        }
        successResponse.Content.Set("application/json", &amp;v3.MediaType{
                Schema: base.CreateSchemaProxyRef(outputSchemaRef),
        })
        responses.Set("200", successResponse)

        // Add validation error response (400)
        validationErrorResponse := &amp;v3.Response{
                Description: "Validation error",
                Content:     orderedmap.New[string, *v3.MediaType](),
        }
        validationErrorResponse.Content.Set("application/json", &amp;v3.MediaType{
                Schema: base.CreateSchemaProxyRef("#/components/schemas/ValidationError"),
        })
        responses.Set("400", validationErrorResponse)

        // Add default error response
        errorSchema := base.CreateSchemaProxy(&amp;base.Schema{
                Type: []string{"object"},
                Properties: func() *orderedmap.Map[string, *base.SchemaProxy] </span><span class="cov0" title="0">{
                        props := orderedmap.New[string, *base.SchemaProxy]()
                        props.Set("error", base.CreateSchemaProxy(&amp;base.Schema{
                                Type: []string{"string"},
                        }))
                        props.Set("code", base.CreateSchemaProxy(&amp;base.Schema{
                                Type: []string{"integer"},
                        }))
                        return props
                }</span>(),
        })

        <span class="cov0" title="0">errorResponse := &amp;v3.Response{
                Description: "Error response",
                Content:     orderedmap.New[string, *v3.MediaType](),
        }
        errorResponse.Content.Set("application/json", &amp;v3.MediaType{
                Schema: errorSchema,
        })
        responses.Set("default", errorResponse)

        operation.Responses = &amp;v3.Responses{
                Codes: responses,
        }

        // Create path item and add to document
        // Check if path already exists (multiple methods on same path)
        existingPathItem, exists := g.doc.Paths.PathItems.Get(path)
        if !exists </span><span class="cov0" title="0">{
                existingPathItem = &amp;v3.PathItem{}
        }</span>

        // Assign operation to the correct HTTP method
        <span class="cov0" title="0">switch httpMethod </span>{
        case "get":<span class="cov0" title="0">
                existingPathItem.Get = operation</span>
        case "post":<span class="cov0" title="0">
                existingPathItem.Post = operation</span>
        case "put":<span class="cov0" title="0">
                existingPathItem.Put = operation</span>
        case "delete":<span class="cov0" title="0">
                existingPathItem.Delete = operation</span>
        case "patch":<span class="cov0" title="0">
                existingPathItem.Patch = operation</span>
        default:<span class="cov0" title="0">
                existingPathItem.Post = operation</span> // Fallback to POST
        }

        <span class="cov0" title="0">g.doc.Paths.PathItems.Set(path, existingPathItem)</span>
}

// findFieldByName finds a field in a message by its proto name.
func findFieldByName(message *protogen.Message, fieldName string) *protogen.Field <span class="cov0" title="0">{
        for _, field := range message.Fields </span><span class="cov0" title="0">{
                if string(field.Desc.Name()) == fieldName </span><span class="cov0" title="0">{
                        return field
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// createFieldSchema creates an OpenAPI schema for a protobuf field.
func (g *Generator) createFieldSchema(field *protogen.Field) *base.SchemaProxy <span class="cov0" title="0">{
        schema := &amp;base.Schema{}

        switch field.Desc.Kind().String() </span>{
        case "string":<span class="cov0" title="0">
                schema.Type = []string{"string"}</span>
        case "int32", "sint32", "sfixed32":<span class="cov0" title="0">
                schema.Type = []string{"integer"}
                schema.Format = "int32"</span>
        case "int64", "sint64", "sfixed64":<span class="cov0" title="0">
                schema.Type = []string{"integer"}
                schema.Format = "int64"</span>
        case "uint32", "fixed32":<span class="cov0" title="0">
                schema.Type = []string{"integer"}
                schema.Format = "int32"</span>
        case "uint64", "fixed64":<span class="cov0" title="0">
                schema.Type = []string{"integer"}
                schema.Format = "int64"</span>
        case "bool":<span class="cov0" title="0">
                schema.Type = []string{"boolean"}</span>
        case "float":<span class="cov0" title="0">
                schema.Type = []string{"number"}
                schema.Format = "float"</span>
        case "double":<span class="cov0" title="0">
                schema.Type = []string{"number"}
                schema.Format = "double"</span>
        default:<span class="cov0" title="0">
                schema.Type = []string{"string"}</span>
        }

        <span class="cov0" title="0">return base.CreateSchemaProxy(schema)</span>
}

// addValidationErrorSchemas adds the ValidationError and FieldViolation schemas to the components.
func addValidationErrorSchemas(schemas *orderedmap.Map[string, *base.SchemaProxy]) <span class="cov5" title="4">{
        // Add FieldViolation schema
        fieldViolationProps := orderedmap.New[string, *base.SchemaProxy]()
        fieldViolationProps.Set("field", base.CreateSchemaProxy(&amp;base.Schema{
                Type:        []string{"string"},
                Description: "The field path that failed validation (e.g., 'user.email' for nested fields). For header validation, this will be the header name (e.g., 'X-API-Key')",
        }))
        fieldViolationProps.Set("description", base.CreateSchemaProxy(&amp;base.Schema{
                Type:        []string{"string"},
                Description: "Human-readable description of the validation violation (e.g., 'must be a valid email address', 'required field missing')",
        }))

        fieldViolationSchema := base.CreateSchemaProxy(&amp;base.Schema{
                Type:        []string{"object"},
                Description: "FieldViolation describes a single validation error for a specific field.",
                Properties:  fieldViolationProps,
                Required:    []string{"field", "description"},
        })
        schemas.Set("FieldViolation", fieldViolationSchema)

        // Add ValidationError schema
        validationErrorProps := orderedmap.New[string, *base.SchemaProxy]()
        validationErrorProps.Set("violations", base.CreateSchemaProxy(&amp;base.Schema{
                Type:        []string{"array"},
                Description: "List of validation violations",
                Items: &amp;base.DynamicValue[*base.SchemaProxy, bool]{
                        A: base.CreateSchemaProxyRef("#/components/schemas/FieldViolation"),
                },
        }))

        validationErrorSchema := base.CreateSchemaProxy(&amp;base.Schema{
                Type:        []string{"object"},
                Description: "ValidationError is returned when request validation fails. It contains a list of field violations describing what went wrong.",
                Properties:  validationErrorProps,
                Required:    []string{"violations"},
        })
        schemas.Set("ValidationError", validationErrorSchema)
}</span>

// Render outputs the OpenAPI document in the specified format.
func (g *Generator) Render() ([]byte, error) <span class="cov3" title="2">{
        switch g.format </span>{
        case FormatJSON:<span class="cov1" title="1">
                // First marshal to YAML (which works correctly with libopenapi)
                yamlData, err := yaml.Marshal(g.doc)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal to YAML: %w", err)
                }</span>
                // Then convert YAML to JSON
                <span class="cov1" title="1">jsonData, err := k8syaml.YAMLToJSON(yamlData)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to convert YAML to JSON: %w", err)
                }</span>
                <span class="cov1" title="1">return jsonData, nil</span>
        case FormatYAML:<span class="cov1" title="1">
                return yaml.Marshal(g.doc)</span>
        default:<span class="cov0" title="0">
                return yaml.Marshal(g.doc)</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package openapiv3

import (
        "regexp"
        "strings"

        "github.com/pb33f/libopenapi/datamodel/high/base"
        v3 "github.com/pb33f/libopenapi/datamodel/high/v3"
        yaml "go.yaml.in/yaml/v4"
        "google.golang.org/protobuf/compiler/protogen"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/types/descriptorpb"

        "github.com/SebastienMelki/sebuf/http"
)

// pathParamRegex matches path variables like {user_id} or {id}
var pathParamRegex = regexp.MustCompile(`\{([^}]+)\}`)

// HTTPConfig represents the HTTP configuration for a method.
type HTTPConfig struct {
        Path       string
        Method     string   // "GET", "POST", "PUT", "DELETE", "PATCH"
        PathParams []string // Path variable names extracted from path
}

// QueryParam represents a query parameter configuration extracted from a field.
type QueryParam struct {
        FieldName string
        ParamName string
        Required  bool
        Field     *protogen.Field
}

// ServiceHTTPConfig represents the HTTP configuration for a service.
type ServiceHTTPConfig struct {
        BasePath string
}

// getMethodHTTPConfig extracts HTTP configuration from method options.
func getMethodHTTPConfig(method *protogen.Method) *HTTPConfig <span class="cov0" title="0">{
        options := method.Desc.Options()
        if options == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the raw options
        <span class="cov0" title="0">methodOptions, ok := options.(*descriptorpb.MethodOptions)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract our custom extension using the generated code
        <span class="cov0" title="0">ext := proto.GetExtension(methodOptions, http.E_Config)
        if ext == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">httpConfig, ok := ext.(*http.HttpConfig)
        if !ok || httpConfig == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">path := httpConfig.GetPath()

        return &amp;HTTPConfig{
                Path:       path,
                Method:     httpMethodToString(httpConfig.GetMethod()),
                PathParams: extractPathParams(path),
        }</span>
}

// httpMethodToString converts HttpMethod enum to lowercase string for OpenAPI. Returns "post" for unspecified.
func httpMethodToString(m http.HttpMethod) string <span class="cov0" title="0">{
        switch m </span>{
        case http.HttpMethod_HTTP_METHOD_GET:<span class="cov0" title="0">
                return "get"</span>
        case http.HttpMethod_HTTP_METHOD_POST:<span class="cov0" title="0">
                return "post"</span>
        case http.HttpMethod_HTTP_METHOD_PUT:<span class="cov0" title="0">
                return "put"</span>
        case http.HttpMethod_HTTP_METHOD_DELETE:<span class="cov0" title="0">
                return "delete"</span>
        case http.HttpMethod_HTTP_METHOD_PATCH:<span class="cov0" title="0">
                return "patch"</span>
        default:<span class="cov0" title="0">
                // HTTP_METHOD_UNSPECIFIED defaults to POST for backward compatibility
                return "post"</span>
        }
}

// extractPathParams parses path variables from a path string.
// Example: "/users/{user_id}/posts/{post_id}" -&gt; ["user_id", "post_id"]
func extractPathParams(path string) []string <span class="cov0" title="0">{
        matches := pathParamRegex.FindAllStringSubmatch(path, -1)
        if len(matches) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">params := make([]string, 0, len(matches))
        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt; 1 </span><span class="cov0" title="0">{
                        params = append(params, match[1])
                }</span>
        }
        <span class="cov0" title="0">return params</span>
}

// getQueryParams extracts query parameter configurations from message fields.
func getQueryParams(message *protogen.Message) []QueryParam <span class="cov0" title="0">{
        var params []QueryParam

        for _, field := range message.Fields </span><span class="cov0" title="0">{
                options := field.Desc.Options()
                if options == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fieldOptions, ok := options.(*descriptorpb.FieldOptions)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">ext := proto.GetExtension(fieldOptions, http.E_Query)
                if ext == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">queryConfig, ok := ext.(*http.QueryConfig)
                if !ok || queryConfig == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Use the configured name, or default to the proto field name
                <span class="cov0" title="0">paramName := queryConfig.GetName()
                if paramName == "" </span><span class="cov0" title="0">{
                        paramName = string(field.Desc.Name())
                }</span>

                <span class="cov0" title="0">params = append(params, QueryParam{
                        FieldName: string(field.Desc.Name()),
                        ParamName: paramName,
                        Required:  queryConfig.GetRequired(),
                        Field:     field,
                })</span>
        }

        <span class="cov0" title="0">return params</span>
}

// getServiceHTTPConfig extracts HTTP configuration from service options.
func getServiceHTTPConfig(service *protogen.Service) *ServiceHTTPConfig <span class="cov0" title="0">{
        options := service.Desc.Options()
        if options == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the raw options
        <span class="cov0" title="0">serviceOptions, ok := options.(*descriptorpb.ServiceOptions)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract our custom extension using the generated code
        <span class="cov0" title="0">ext := proto.GetExtension(serviceOptions, http.E_ServiceConfig)
        if ext == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">serviceConfig, ok := ext.(*http.ServiceConfig)
        if !ok || serviceConfig == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;ServiceHTTPConfig{
                BasePath: serviceConfig.GetBasePath(),
        }</span>
}

// buildHTTPPath combines service base path with method path.
func buildHTTPPath(servicePath, methodPath string) string <span class="cov0" title="0">{
        // Handle empty paths
        if servicePath == "" &amp;&amp; methodPath == "" </span><span class="cov0" title="0">{
                return "/"
        }</span>
        <span class="cov0" title="0">if servicePath == "" </span><span class="cov0" title="0">{
                return ensureLeadingSlash(methodPath)
        }</span>
        <span class="cov0" title="0">if methodPath == "" </span><span class="cov0" title="0">{
                return ensureLeadingSlash(servicePath)
        }</span>

        // Clean and combine paths
        <span class="cov0" title="0">servicePath = strings.TrimSuffix(ensureLeadingSlash(servicePath), "/")
        methodPath = strings.TrimPrefix(methodPath, "/")

        return servicePath + "/" + methodPath</span>
}

// ensureLeadingSlash ensures a path starts with "/".
func ensureLeadingSlash(path string) string <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                return "/"
        }</span>
        <span class="cov0" title="0">if !strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                return "/" + path
        }</span>
        <span class="cov0" title="0">return path</span>
}

// getServiceHeaders extracts header configuration from service options.
func getServiceHeaders(service *protogen.Service) []*http.Header <span class="cov0" title="0">{
        options := service.Desc.Options()
        if options == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the raw options
        <span class="cov0" title="0">serviceOptions, ok := options.(*descriptorpb.ServiceOptions)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract our custom extension using the generated code
        <span class="cov0" title="0">ext := proto.GetExtension(serviceOptions, http.E_ServiceHeaders)
        if ext == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">serviceHeaders, ok := ext.(*http.ServiceHeaders)
        if !ok || serviceHeaders == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return serviceHeaders.GetRequiredHeaders()</span>
}

// getMethodHeaders extracts header configuration from method options.
func getMethodHeaders(method *protogen.Method) []*http.Header <span class="cov0" title="0">{
        options := method.Desc.Options()
        if options == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the raw options
        <span class="cov0" title="0">methodOptions, ok := options.(*descriptorpb.MethodOptions)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract our custom extension using the generated code
        <span class="cov0" title="0">ext := proto.GetExtension(methodOptions, http.E_MethodHeaders)
        if ext == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">methodHeaders, ok := ext.(*http.MethodHeaders)
        if !ok || methodHeaders == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return methodHeaders.GetRequiredHeaders()</span>
}

// combineHeaders merges service headers with method headers, with method headers taking precedence.
func combineHeaders(serviceHeaders, methodHeaders []*http.Header) []*http.Header <span class="cov0" title="0">{
        if len(serviceHeaders) == 0 </span><span class="cov0" title="0">{
                return methodHeaders
        }</span>
        <span class="cov0" title="0">if len(methodHeaders) == 0 </span><span class="cov0" title="0">{
                return serviceHeaders
        }</span>

        // Create a map to track headers by name for deduplication
        <span class="cov0" title="0">headerMap := make(map[string]*http.Header)

        // Add service headers first
        for _, header := range serviceHeaders </span><span class="cov0" title="0">{
                if header.GetName() != "" </span><span class="cov0" title="0">{
                        headerMap[header.GetName()] = header
                }</span>
        }

        // Add method headers, overriding service headers with same name
        <span class="cov0" title="0">for _, header := range methodHeaders </span><span class="cov0" title="0">{
                if header.GetName() != "" </span><span class="cov0" title="0">{
                        headerMap[header.GetName()] = header
                }</span>
        }

        // Convert back to slice, sorted by header name for deterministic output
        <span class="cov0" title="0">result := make([]*http.Header, 0, len(headerMap))

        // Get sorted header names
        headerNames := make([]string, 0, len(headerMap))
        for name := range headerMap </span><span class="cov0" title="0">{
                headerNames = append(headerNames, name)
        }</span>

        // Sort header names to ensure deterministic order
        <span class="cov0" title="0">for i := 0; i &lt; len(headerNames); i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(headerNames); j++ </span><span class="cov0" title="0">{
                        if headerNames[i] &gt; headerNames[j] </span><span class="cov0" title="0">{
                                headerNames[i], headerNames[j] = headerNames[j], headerNames[i]
                        }</span>
                }
        }

        // Add headers in sorted order
        <span class="cov0" title="0">for _, name := range headerNames </span><span class="cov0" title="0">{
                result = append(result, headerMap[name])
        }</span>

        <span class="cov0" title="0">return result</span>
}

// convertHeadersToParameters converts proto headers to OpenAPI parameters.
func convertHeadersToParameters(headers []*http.Header) []*v3.Parameter <span class="cov0" title="0">{
        if len(headers) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">parameters := make([]*v3.Parameter, 0, len(headers))

        for _, header := range headers </span><span class="cov0" title="0">{
                if header.GetName() == "" </span><span class="cov0" title="0">{
                        continue</span> // Skip headers without names
                }

                // Create the schema for the header
                <span class="cov0" title="0">schema := &amp;base.Schema{
                        Type: []string{mapHeaderTypeToOpenAPI(header.GetType())},
                }

                // Add format if specified
                if header.GetFormat() != "" </span><span class="cov0" title="0">{
                        schema.Format = header.GetFormat()
                }</span>

                // Add example if specified
                <span class="cov0" title="0">if header.GetExample() != "" </span><span class="cov0" title="0">{
                        schema.Example = &amp;yaml.Node{
                                Kind:  yaml.ScalarNode,
                                Value: header.GetExample(),
                        }
                }</span>

                // Create the parameter
                <span class="cov0" title="0">parameter := &amp;v3.Parameter{
                        Name:        header.GetName(),
                        In:          "header",
                        Required:    &amp;header.Required,
                        Schema:      base.CreateSchemaProxy(schema),
                        Description: header.GetDescription(),
                }

                // Set deprecated if specified
                if header.GetDeprecated() </span><span class="cov0" title="0">{
                        parameter.Deprecated = true
                }</span>

                <span class="cov0" title="0">parameters = append(parameters, parameter)</span>
        }

        <span class="cov0" title="0">return parameters</span>
}

const (
        headerTypeString  = "string"
        headerTypeInt32   = "int32"
        headerTypeInt64   = "int64"
        headerTypeInteger = "integer"
)

// mapHeaderTypeToOpenAPI maps proto header types to OpenAPI schema types.
func mapHeaderTypeToOpenAPI(headerType string) string <span class="cov0" title="0">{
        switch strings.ToLower(headerType) </span>{
        case headerTypeString, "":<span class="cov0" title="0">
                return headerTypeString</span>
        case headerTypeInteger, "int", headerTypeInt32, headerTypeInt64:<span class="cov0" title="0">
                return headerTypeInteger</span>
        case "number", "float", "double":<span class="cov0" title="0">
                return "number"</span>
        case "boolean", "bool":<span class="cov0" title="0">
                return "boolean"</span>
        case "array":<span class="cov0" title="0">
                return "array"</span>
        default:<span class="cov0" title="0">
                // Default to string for unknown types
                return headerTypeString</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package openapiv3

import (
        "fmt"
        "strings"

        "github.com/pb33f/libopenapi/datamodel/high/base"
        yaml "go.yaml.in/yaml/v4"
        "google.golang.org/protobuf/compiler/protogen"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/reflect/protoreflect"
        "google.golang.org/protobuf/types/descriptorpb"

        "github.com/SebastienMelki/sebuf/http"
)

// convertField converts a protobuf field to an OpenAPI schema.
func (g *Generator) convertField(field *protogen.Field) *base.SchemaProxy <span class="cov0" title="0">{
        // Handle repeated fields (arrays)
        if field.Desc.IsList() </span><span class="cov0" title="0">{
                itemSchema := g.convertScalarField(field)
                arraySchema := &amp;base.Schema{
                        Type: []string{"array"},
                        Items: &amp;base.DynamicValue[*base.SchemaProxy, bool]{
                                A: itemSchema,
                        },
                }

                // Apply validation constraints for the array itself
                extractValidationConstraints(field, arraySchema)

                return base.CreateSchemaProxy(arraySchema)
        }</span>

        // Handle map fields
        <span class="cov0" title="0">if field.Desc.IsMap() </span><span class="cov0" title="0">{
                return g.convertMapField(field)
        }</span>

        // Handle optional fields (proto3 optional)
        <span class="cov0" title="0">schema := g.convertScalarField(field)
        if field.Desc.HasOptionalKeyword() </span><span class="cov0" title="0">{
                // For proto3 optional fields, we could add nullable: true
                // but OpenAPI 3.1 handles this differently than 3.0
                return schema
        }</span>

        <span class="cov0" title="0">return schema</span>
}

// convertScalarField handles scalar field types and message references.
func (g *Generator) convertScalarField(field *protogen.Field) *base.SchemaProxy <span class="cov0" title="0">{
        schema := &amp;base.Schema{}

        switch field.Desc.Kind() </span>{
        case protoreflect.BoolKind:<span class="cov0" title="0">
                schema.Type = []string{"boolean"}</span>

        case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:<span class="cov0" title="0">
                schema.Type = []string{"integer"}
                schema.Format = "int32"</span>

        case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:<span class="cov0" title="0">
                schema.Type = []string{"integer"}
                schema.Format = "int64"</span>

        case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:<span class="cov0" title="0">
                schema.Type = []string{"integer"}
                schema.Format = "int32"
                zero := 0.0
                schema.Minimum = &amp;zero</span>

        case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:<span class="cov0" title="0">
                schema.Type = []string{"integer"}
                schema.Format = "int64"
                zero := 0.0
                schema.Minimum = &amp;zero</span>

        case protoreflect.FloatKind:<span class="cov0" title="0">
                schema.Type = []string{"number"}
                schema.Format = "float"</span>

        case protoreflect.DoubleKind:<span class="cov0" title="0">
                schema.Type = []string{"number"}
                schema.Format = "double"</span>

        case protoreflect.StringKind:<span class="cov0" title="0">
                schema.Type = []string{"string"}</span>

        case protoreflect.BytesKind:<span class="cov0" title="0">
                schema.Type = []string{"string"}
                schema.Format = "byte"</span>

        case protoreflect.EnumKind:<span class="cov0" title="0">
                return g.convertEnumField(field)</span>

        case protoreflect.MessageKind:<span class="cov0" title="0">
                // Reference to another message
                return base.CreateSchemaProxyRef(fmt.Sprintf("#/components/schemas/%s", g.getSchemaName(field.Message)))</span>

        case protoreflect.GroupKind:<span class="cov0" title="0">
                // Groups are deprecated but still supported
                if field.Message != nil </span><span class="cov0" title="0">{
                        return base.CreateSchemaProxyRef(fmt.Sprintf("#/components/schemas/%s", g.getSchemaName(field.Message)))
                }</span>
                <span class="cov0" title="0">schema.Type = []string{"object"}</span>

        default:<span class="cov0" title="0">
                // Fallback for unknown types
                schema.Type = []string{"string"}</span>
        }

        // Add description from field comments
        <span class="cov0" title="0">if field.Comments.Leading != "" </span><span class="cov0" title="0">{
                schema.Description = strings.TrimSpace(string(field.Comments.Leading))
        }</span>

        // Apply buf.validate constraints
        <span class="cov0" title="0">extractValidationConstraints(field, schema)

        // Add field examples if available
        if examples := getFieldExamples(field); len(examples) &gt; 0 </span><span class="cov0" title="0">{
                // Set the first example as the default example
                schema.Example = &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: examples[0],
                }

                // Add all examples using OpenAPI 3.1 examples array format
                schema.Examples = make([]*yaml.Node, len(examples))
                for i, example := range examples </span><span class="cov0" title="0">{
                        schema.Examples[i] = &amp;yaml.Node{
                                Kind:  yaml.ScalarNode,
                                Value: example,
                        }
                }</span>
        }

        <span class="cov0" title="0">return base.CreateSchemaProxy(schema)</span>
}

// convertEnumField converts a protobuf enum field to an OpenAPI schema.
func (g *Generator) convertEnumField(field *protogen.Field) *base.SchemaProxy <span class="cov0" title="0">{
        if field.Enum == nil </span><span class="cov0" title="0">{
                // Fallback if enum is not available
                return base.CreateSchemaProxy(&amp;base.Schema{
                        Type: []string{"string"},
                })
        }</span>

        <span class="cov0" title="0">schema := &amp;base.Schema{
                Type: []string{"string"},
                Enum: make([]*yaml.Node, 0, len(field.Enum.Values)),
        }

        // Add enum values
        for _, value := range field.Enum.Values </span><span class="cov0" title="0">{
                schema.Enum = append(schema.Enum, &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: string(value.Desc.Name()),
                })
        }</span>

        // Add description from enum comments
        <span class="cov0" title="0">if field.Enum.Comments.Leading != "" </span><span class="cov0" title="0">{
                schema.Description = strings.TrimSpace(string(field.Enum.Comments.Leading))
        }</span>

        <span class="cov0" title="0">return base.CreateSchemaProxy(schema)</span>
}

// convertMapField converts a protobuf map field to an OpenAPI schema.
func (g *Generator) convertMapField(field *protogen.Field) *base.SchemaProxy <span class="cov0" title="0">{
        schema := &amp;base.Schema{
                Type: []string{"object"},
        }

        // For maps, we need to determine the value type
        if field.Message != nil &amp;&amp; len(field.Message.Fields) &gt;= 2 </span><span class="cov0" title="0">{
                // Map entry messages have exactly 2 fields: key (field 1) and value (field 2)
                var valueField *protogen.Field
                const mapValueFieldNumber = 2 // value field is always number 2 in protobuf map entries
                for _, f := range field.Message.Fields </span><span class="cov0" title="0">{
                        if f.Desc.Number() == mapValueFieldNumber </span><span class="cov0" title="0">{
                                valueField = f
                                break</span>
                        }
                }

                <span class="cov0" title="0">if valueField != nil </span><span class="cov0" title="0">{
                        valueSchema := g.convertScalarField(valueField)
                        schema.AdditionalProperties = &amp;base.DynamicValue[*base.SchemaProxy, bool]{
                                A: valueSchema,
                        }
                }</span>
        }

        // If we couldn't determine the value type, allow any type
        <span class="cov0" title="0">if schema.AdditionalProperties == nil </span><span class="cov0" title="0">{
                schema.AdditionalProperties = &amp;base.DynamicValue[*base.SchemaProxy, bool]{
                        B: true,
                }
        }</span>

        // Add description from field comments
        <span class="cov0" title="0">if field.Comments.Leading != "" </span><span class="cov0" title="0">{
                schema.Description = strings.TrimSpace(string(field.Comments.Leading))
        }</span>

        // Apply validation constraints for the map itself
        <span class="cov0" title="0">extractValidationConstraints(field, schema)

        return base.CreateSchemaProxy(schema)</span>
}

// getFieldExamples extracts example values from field options.
func getFieldExamples(field *protogen.Field) []string <span class="cov0" title="0">{
        options := field.Desc.Options()
        if options == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the raw options
        <span class="cov0" title="0">fieldOptions, ok := options.(*descriptorpb.FieldOptions)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract our custom extension using the generated code
        <span class="cov0" title="0">ext := proto.GetExtension(fieldOptions, http.E_FieldExamples)
        if ext == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">fieldExamples, ok := ext.(*http.FieldExamples)
        if !ok || fieldExamples == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return fieldExamples.GetValues()</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package openapiv3

import (
        "fmt"
        "strconv"

        "github.com/pb33f/libopenapi/datamodel/high/base"
        yaml "go.yaml.in/yaml/v4"
        "google.golang.org/protobuf/compiler/protogen"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/reflect/protoreflect"

        validate "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
)

// extractValidationConstraints extracts buf.validate field options and applies them to the schema.
func extractValidationConstraints(field *protogen.Field, schema *base.Schema) <span class="cov0" title="0">{
        // Get the field descriptor options
        fieldOptions := field.Desc.Options()
        if fieldOptions == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Extract the buf.validate field extension
        <span class="cov0" title="0">ext := proto.GetExtension(fieldOptions, validate.E_Field)
        if ext == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Type assert to FieldRules
        <span class="cov0" title="0">fieldConstraints, ok := ext.(*validate.FieldRules)
        if !ok || fieldConstraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Apply constraints based on field type
        <span class="cov0" title="0">switch field.Desc.Kind() </span>{
        case protoreflect.StringKind:<span class="cov0" title="0">
                applyStringConstraints(fieldConstraints, schema)</span>
        case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind,
                protoreflect.Uint32Kind, protoreflect.Fixed32Kind:<span class="cov0" title="0">
                applyInt32Constraints(fieldConstraints, schema)</span>
        case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind,
                protoreflect.Uint64Kind, protoreflect.Fixed64Kind:<span class="cov0" title="0">
                applyInt64Constraints(fieldConstraints, schema)</span>
        case protoreflect.FloatKind:<span class="cov0" title="0">
                applyFloatConstraints(fieldConstraints, schema)</span>
        case protoreflect.DoubleKind:<span class="cov0" title="0">
                applyDoubleConstraints(fieldConstraints, schema)</span>
        case protoreflect.BoolKind,
                protoreflect.EnumKind,
                protoreflect.BytesKind,
                protoreflect.MessageKind,
                protoreflect.GroupKind:<span class="cov0" title="0"></span>
                // No specific constraints for these types
        }

        // Handle repeated field constraints
        <span class="cov0" title="0">if field.Desc.IsList() </span><span class="cov0" title="0">{
                applyRepeatedConstraints(fieldConstraints, schema)
        }</span>

        // Handle map field constraints
        <span class="cov0" title="0">if field.Desc.IsMap() </span><span class="cov0" title="0">{
                applyMapConstraints(fieldConstraints, schema)
        }</span>

        // Handle required constraint
        // Note: Required is handled at the message level, not here
        // This is a marker for the parent message to add this field to required[]
        <span class="cov0" title="0">_ = fieldConstraints.GetRequired()</span>
}

// applyStringConstraints applies string validation constraints to the schema.
func applyStringConstraints(constraints *validate.FieldRules, schema *base.Schema) <span class="cov0" title="0">{
        stringConstraints := constraints.GetString()
        if stringConstraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Min and max length
        <span class="cov0" title="0">if stringConstraints.HasMinLen() </span><span class="cov0" title="0">{
                minLen := int64(stringConstraints.GetMinLen()) // #nosec G115
                schema.MinLength = &amp;minLen
        }</span>
        <span class="cov0" title="0">if stringConstraints.HasMaxLen() </span><span class="cov0" title="0">{
                maxLen := int64(stringConstraints.GetMaxLen()) // #nosec G115
                schema.MaxLength = &amp;maxLen
        }</span>

        // Pattern (regex)
        <span class="cov0" title="0">if stringConstraints.HasPattern() </span><span class="cov0" title="0">{
                schema.Pattern = stringConstraints.GetPattern()
        }</span>

        // Format constraints
        <span class="cov0" title="0">switch </span>{
        case stringConstraints.GetEmail():<span class="cov0" title="0">
                schema.Format = "email"</span>
        case stringConstraints.GetUuid():<span class="cov0" title="0">
                schema.Format = "uuid"</span>
        case stringConstraints.GetUri():<span class="cov0" title="0">
                schema.Format = "uri"</span>
        case stringConstraints.GetUriRef():<span class="cov0" title="0">
                schema.Format = "uri-reference"</span>
        case stringConstraints.GetAddress():<span class="cov0" title="0">
                // IPv4 or IPv6 address
                schema.Format = "ip"</span>
        case stringConstraints.GetHostname():<span class="cov0" title="0">
                schema.Format = "hostname"</span>
        case stringConstraints.GetIp():<span class="cov0" title="0">
                schema.Format = "ip"</span>
        case stringConstraints.GetIpv4():<span class="cov0" title="0">
                schema.Format = "ipv4"</span>
        case stringConstraints.GetIpv6():<span class="cov0" title="0">
                schema.Format = "ipv6"</span>
        }

        // Enum values (in constraint)
        <span class="cov0" title="0">if len(stringConstraints.GetIn()) &gt; 0 </span><span class="cov0" title="0">{
                schema.Enum = make([]*yaml.Node, 0, len(stringConstraints.GetIn()))
                for _, value := range stringConstraints.GetIn() </span><span class="cov0" title="0">{
                        schema.Enum = append(schema.Enum, &amp;yaml.Node{
                                Kind:  yaml.ScalarNode,
                                Value: value,
                        })
                }</span>
        }

        // Const value
        <span class="cov0" title="0">if stringConstraints.HasConst() </span><span class="cov0" title="0">{
                val := stringConstraints.GetConst()
                schema.Const = &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: val,
                }
        }</span>
}

// applyInt32Constraints applies int32 validation constraints to the schema.
func applyInt32Constraints(constraints *validate.FieldRules, schema *base.Schema) <span class="cov0" title="0">{
        int32Constraints := constraints.GetInt32()
        if int32Constraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Greater than or equal (minimum)
        <span class="cov0" title="0">if int32Constraints.HasGte() </span><span class="cov0" title="0">{
                minValue := float64(int32Constraints.GetGte())
                schema.Minimum = &amp;minValue
        }</span>

        // Greater than (exclusive minimum)
        <span class="cov0" title="0">if int32Constraints.HasGt() </span><span class="cov0" title="0">{
                minValue := float64(int32Constraints.GetGt())
                schema.ExclusiveMinimum = &amp;base.DynamicValue[bool, float64]{B: minValue}
        }</span>

        // Less than or equal (maximum)
        <span class="cov0" title="0">if int32Constraints.HasLte() </span><span class="cov0" title="0">{
                maxValue := float64(int32Constraints.GetLte())
                schema.Maximum = &amp;maxValue
        }</span>

        // Less than (exclusive maximum)
        <span class="cov0" title="0">if int32Constraints.HasLt() </span><span class="cov0" title="0">{
                maxValue := float64(int32Constraints.GetLt())
                schema.ExclusiveMaximum = &amp;base.DynamicValue[bool, float64]{B: maxValue}
        }</span>

        // Const value
        <span class="cov0" title="0">if int32Constraints.HasConst() </span><span class="cov0" title="0">{
                schema.Const = &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: strconv.Itoa(int(int32Constraints.GetConst())),
                }
        }</span>

        // Enum values (in constraint)
        <span class="cov0" title="0">if len(int32Constraints.GetIn()) &gt; 0 </span><span class="cov0" title="0">{
                schema.Enum = make([]*yaml.Node, 0, len(int32Constraints.GetIn()))
                for _, value := range int32Constraints.GetIn() </span><span class="cov0" title="0">{
                        schema.Enum = append(schema.Enum, &amp;yaml.Node{
                                Kind:  yaml.ScalarNode,
                                Value: strconv.Itoa(int(value)),
                        })
                }</span>
        }
}

// applyInt64Constraints applies int64 validation constraints to the schema.
func applyInt64Constraints(constraints *validate.FieldRules, schema *base.Schema) <span class="cov0" title="0">{
        int64Constraints := constraints.GetInt64()
        if int64Constraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Greater than or equal (minimum)
        <span class="cov0" title="0">if int64Constraints.HasGte() </span><span class="cov0" title="0">{
                minValue := float64(int64Constraints.GetGte())
                schema.Minimum = &amp;minValue
        }</span>

        // Greater than (exclusive minimum)
        <span class="cov0" title="0">if int64Constraints.HasGt() </span><span class="cov0" title="0">{
                minValue := float64(int64Constraints.GetGt())
                schema.ExclusiveMinimum = &amp;base.DynamicValue[bool, float64]{B: minValue}
        }</span>

        // Less than or equal (maximum)
        <span class="cov0" title="0">if int64Constraints.HasLte() </span><span class="cov0" title="0">{
                maxValue := float64(int64Constraints.GetLte())
                schema.Maximum = &amp;maxValue
        }</span>

        // Less than (exclusive maximum)
        <span class="cov0" title="0">if int64Constraints.HasLt() </span><span class="cov0" title="0">{
                maxValue := float64(int64Constraints.GetLt())
                schema.ExclusiveMaximum = &amp;base.DynamicValue[bool, float64]{B: maxValue}
        }</span>

        // Const value
        <span class="cov0" title="0">if int64Constraints.HasConst() </span><span class="cov0" title="0">{
                schema.Const = &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: strconv.FormatInt(int64Constraints.GetConst(), 10),
                }
        }</span>

        // Enum values (in constraint)
        <span class="cov0" title="0">if len(int64Constraints.GetIn()) &gt; 0 </span><span class="cov0" title="0">{
                schema.Enum = make([]*yaml.Node, 0, len(int64Constraints.GetIn()))
                for _, value := range int64Constraints.GetIn() </span><span class="cov0" title="0">{
                        schema.Enum = append(schema.Enum, &amp;yaml.Node{
                                Kind:  yaml.ScalarNode,
                                Value: strconv.FormatInt(value, 10),
                        })
                }</span>
        }
}

// applyFloatConstraints applies float validation constraints to the schema.
func applyFloatConstraints(constraints *validate.FieldRules, schema *base.Schema) <span class="cov0" title="0">{
        floatConstraints := constraints.GetFloat()
        if floatConstraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Greater than or equal (minimum)
        <span class="cov0" title="0">if floatConstraints.HasGte() </span><span class="cov0" title="0">{
                minValue := float64(floatConstraints.GetGte())
                schema.Minimum = &amp;minValue
        }</span>

        // Greater than (exclusive minimum)
        <span class="cov0" title="0">if floatConstraints.HasGt() </span><span class="cov0" title="0">{
                minValue := float64(floatConstraints.GetGt())
                schema.ExclusiveMinimum = &amp;base.DynamicValue[bool, float64]{B: minValue}
        }</span>

        // Less than or equal (maximum)
        <span class="cov0" title="0">if floatConstraints.HasLte() </span><span class="cov0" title="0">{
                maxValue := float64(floatConstraints.GetLte())
                schema.Maximum = &amp;maxValue
        }</span>

        // Less than (exclusive maximum)
        <span class="cov0" title="0">if floatConstraints.HasLt() </span><span class="cov0" title="0">{
                maxValue := float64(floatConstraints.GetLt())
                schema.ExclusiveMaximum = &amp;base.DynamicValue[bool, float64]{B: maxValue}
        }</span>

        // Const value
        <span class="cov0" title="0">if floatConstraints.HasConst() </span><span class="cov0" title="0">{
                schema.Const = &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: fmt.Sprintf("%g", floatConstraints.GetConst()),
                }
        }</span>

        // Enum values (in constraint)
        <span class="cov0" title="0">if len(floatConstraints.GetIn()) &gt; 0 </span><span class="cov0" title="0">{
                schema.Enum = make([]*yaml.Node, 0, len(floatConstraints.GetIn()))
                for _, value := range floatConstraints.GetIn() </span><span class="cov0" title="0">{
                        schema.Enum = append(schema.Enum, &amp;yaml.Node{
                                Kind:  yaml.ScalarNode,
                                Value: fmt.Sprintf("%g", value),
                        })
                }</span>
        }
}

// applyDoubleConstraints applies double validation constraints to the schema.
func applyDoubleConstraints(constraints *validate.FieldRules, schema *base.Schema) <span class="cov0" title="0">{
        doubleConstraints := constraints.GetDouble()
        if doubleConstraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Greater than or equal (minimum)
        <span class="cov0" title="0">if doubleConstraints.HasGte() </span><span class="cov0" title="0">{
                minValue := doubleConstraints.GetGte()
                schema.Minimum = &amp;minValue
        }</span>

        // Greater than (exclusive minimum)
        <span class="cov0" title="0">if doubleConstraints.HasGt() </span><span class="cov0" title="0">{
                minValue := doubleConstraints.GetGt()
                schema.ExclusiveMinimum = &amp;base.DynamicValue[bool, float64]{B: minValue}
        }</span>

        // Less than or equal (maximum)
        <span class="cov0" title="0">if doubleConstraints.HasLte() </span><span class="cov0" title="0">{
                maxValue := doubleConstraints.GetLte()
                schema.Maximum = &amp;maxValue
        }</span>

        // Less than (exclusive maximum)
        <span class="cov0" title="0">if doubleConstraints.HasLt() </span><span class="cov0" title="0">{
                maxValue := doubleConstraints.GetLt()
                schema.ExclusiveMaximum = &amp;base.DynamicValue[bool, float64]{B: maxValue}
        }</span>

        // Const value
        <span class="cov0" title="0">if doubleConstraints.HasConst() </span><span class="cov0" title="0">{
                schema.Const = &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: fmt.Sprintf("%g", doubleConstraints.GetConst()),
                }
        }</span>

        // Enum values (in constraint)
        <span class="cov0" title="0">if len(doubleConstraints.GetIn()) &gt; 0 </span><span class="cov0" title="0">{
                schema.Enum = make([]*yaml.Node, 0, len(doubleConstraints.GetIn()))
                for _, value := range doubleConstraints.GetIn() </span><span class="cov0" title="0">{
                        schema.Enum = append(schema.Enum, &amp;yaml.Node{
                                Kind:  yaml.ScalarNode,
                                Value: fmt.Sprintf("%g", value),
                        })
                }</span>
        }
}

// applyRepeatedConstraints applies repeated field validation constraints to the schema.
func applyRepeatedConstraints(constraints *validate.FieldRules, schema *base.Schema) <span class="cov0" title="0">{
        repeatedConstraints := constraints.GetRepeated()
        if repeatedConstraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Min items
        <span class="cov0" title="0">if repeatedConstraints.HasMinItems() </span><span class="cov0" title="0">{
                minItems := int64(repeatedConstraints.GetMinItems()) // #nosec G115
                schema.MinItems = &amp;minItems
        }</span>

        // Max items
        <span class="cov0" title="0">if repeatedConstraints.HasMaxItems() </span><span class="cov0" title="0">{
                maxItems := int64(repeatedConstraints.GetMaxItems()) // #nosec G115
                schema.MaxItems = &amp;maxItems
        }</span>

        // Unique items
        <span class="cov0" title="0">if repeatedConstraints.GetUnique() </span><span class="cov0" title="0">{
                uniqueItems := true
                schema.UniqueItems = &amp;uniqueItems
        }</span>
}

// applyMapConstraints applies map field validation constraints to the schema.
func applyMapConstraints(constraints *validate.FieldRules, schema *base.Schema) <span class="cov0" title="0">{
        mapConstraints := constraints.GetMap()
        if mapConstraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Min pairs (minProperties)
        <span class="cov0" title="0">if mapConstraints.HasMinPairs() </span><span class="cov0" title="0">{
                minProps := int64(mapConstraints.GetMinPairs()) // #nosec G115
                schema.MinProperties = &amp;minProps
        }</span>

        // Max pairs (maxProperties)
        <span class="cov0" title="0">if mapConstraints.HasMaxPairs() </span><span class="cov0" title="0">{
                maxProps := int64(mapConstraints.GetMaxPairs()) // #nosec G115
                schema.MaxProperties = &amp;maxProps
        }</span>
}

// checkIfFieldRequired checks if a field has the required constraint.
func checkIfFieldRequired(field *protogen.Field) bool <span class="cov0" title="0">{
        // Get the field descriptor options
        fieldOptions := field.Desc.Options()
        if fieldOptions == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Extract the buf.validate field extension
        <span class="cov0" title="0">ext := proto.GetExtension(fieldOptions, validate.E_Field)
        if ext == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Type assert to FieldRules
        <span class="cov0" title="0">fieldConstraints, ok := ext.(*validate.FieldRules)
        if !ok || fieldConstraints == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return fieldConstraints.GetRequired()</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
