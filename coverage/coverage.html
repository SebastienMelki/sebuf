
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>oneofhelper: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/SebastienMelki/sebuf/internal/oneofhelper/generator.go (41.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package oneofhelper provides helper functions for protobuf messages with oneof fields.
package oneofhelper

import (
        "fmt"
        "strings"

        "google.golang.org/protobuf/compiler/protogen"
        "google.golang.org/protobuf/reflect/protoreflect"
)

const (
        goString            = "string"
        goInt32             = "int32"
        goInt64             = "int64"
        goUint32            = "uint32"
        goUint64            = "uint64"
        goBool              = "bool"
        goFloat32           = "float32"
        goFloat64           = "float64"
        goBytes             = "[]byte"
        goInterface         = "interface{}"
        mapValueFieldNumber = 2
)

// GenerateHelpers generates helper functions for all messages with oneofs in the given file.
func GenerateHelpers(plugin *protogen.Plugin, file *protogen.File) <span class="cov4" title="3">{
        filename := file.GeneratedFilenamePrefix + "_helpers.pb.go"
        g := plugin.NewGeneratedFile(filename, file.GoImportPath)

        // Write package header
        g.P("// Code generated by protoc-gen-go-oneof-helper. DO NOT EDIT.")
        g.P()
        g.P("package ", file.GoPackageName)
        g.P()

        // Generate helpers for each message with oneofs
        // The GeneratedFile will automatically handle imports for us
        for _, message := range file.Messages </span><span class="cov3" title="2">{
                GenerateMessageHelpers(g, message)
        }</span>
}

// GenerateMessageHelpers generates helper functions for a single message and its nested messages.
func GenerateMessageHelpers(g *protogen.GeneratedFile, message *protogen.Message) <span class="cov6" title="5">{
        // Look for oneofs
        for _, oneof := range message.Oneofs </span><span class="cov3" title="2">{
                // Generate a helper for each field in the oneof
                for _, field := range oneof.Fields </span><span class="cov4" title="3">{
                        GenerateOneofHelper(g, message, oneof, field)
                }</span>
        }

        // Recurse into nested messages
        <span class="cov6" title="5">for _, nested := range message.Messages </span><span class="cov4" title="3">{
                GenerateMessageHelpers(g, nested)
        }</span>
}

// GenerateOneofHelper generates a helper function for a specific oneof field.
func GenerateOneofHelper(g *protogen.GeneratedFile, message *protogen.Message,
        oneof *protogen.Oneof, field *protogen.Field,
) <span class="cov4" title="3">{
        // Generate helper function name
        helperName := fmt.Sprintf("New%s%s", message.GoIdent.GoName, field.GoName)

        // Get the wrapper type name (e.g., LoginMethod_Email)
        wrapperType := fmt.Sprintf("%s_%s", message.GoIdent.GoName, field.GoName)

        // Check if this field is a message type that might have fields
        if field.Message != nil </span><span class="cov4" title="3">{
                // Build parameter list from the nested message fields
                var params []string

                var paramAssignments []string

                for _, nestedField := range field.Message.Fields </span><span class="cov6" title="5">{
                        paramName := lowerFirst(nestedField.GoName)
                        paramType := GetFieldType(g, nestedField)
                        params = append(params, fmt.Sprintf("%s %s", paramName, paramType))
                        paramAssignments = append(paramAssignments,
                                fmt.Sprintf("\t\t\t%s: %s,", nestedField.GoName, paramName))
                }</span>

                // Generate the helper function
                <span class="cov4" title="3">g.P("// ", helperName, " creates a new ", message.GoIdent.GoName,
                        " with ", field.GoName, " set")
                g.P("func ", helperName, "(", strings.Join(params, ", "), ") *",
                        message.GoIdent.GoName, " {")
                g.P("\treturn &amp;", message.GoIdent.GoName, "{")
                g.P("\t\t", oneof.GoName, ": &amp;", wrapperType, "{")
                g.P("\t\t\t", field.GoName, ": &amp;", g.QualifiedGoIdent(field.Message.GoIdent), "{")

                for _, assignment := range paramAssignments </span><span class="cov6" title="5">{
                        g.P(assignment)
                }</span>

                <span class="cov4" title="3">g.P("\t\t\t},")
                g.P("\t\t},")
                g.P("\t}")
                g.P("}")
                g.P()</span>
        }
}

// LowerFirst converts the first character of a string to lowercase
// This function is exported for testing purposes.
func LowerFirst(s string) string <span class="cov8" title="12">{
        return lowerFirst(s)
}</span>

// lowerFirst is the internal implementation.
func lowerFirst(s string) string <span class="cov10" title="17">{
        if s == "" </span><span class="cov3" title="2">{
                return ""
        }</span>

        <span class="cov9" title="15">return strings.ToLower(s[:1]) + s[1:]</span>
}

// GetFieldType determines the Go type for a protobuf field.
func GetFieldType(g *protogen.GeneratedFile, field *protogen.Field) string <span class="cov6" title="5">{
        // Handle repeated fields
        if field.Desc.IsList() </span><span class="cov0" title="0">{
                return "[]" + getSingleFieldType(g, field)
        }</span>

        // Handle map fields
        <span class="cov6" title="5">if field.Desc.IsMap() </span><span class="cov0" title="0">{
                return getMapType(g, field)
        }</span>

        // Handle optional fields (proto3 optional)
        <span class="cov6" title="5">if field.Desc.HasOptionalKeyword() </span><span class="cov0" title="0">{
                return "*" + getSingleFieldType(g, field)
        }</span>

        <span class="cov6" title="5">return getSingleFieldType(g, field)</span>
}

func getMapType(g *protogen.GeneratedFile, field *protogen.Field) string <span class="cov0" title="0">{
        // For map keys, we need to handle the key type specially
        keyType := getMapKeyType(field.Desc.MapKey())
        valueType := getMapValueType(g, field)

        return "map[" + keyType + "]" + valueType
}</span>

func getMapValueType(g *protogen.GeneratedFile, field *protogen.Field) string <span class="cov0" title="0">{
        switch field.Desc.MapValue().Kind() </span>{
        case protoreflect.BoolKind:<span class="cov0" title="0">
                return goBool</span>
        case protoreflect.EnumKind:<span class="cov0" title="0">
                return goInt32</span>
        case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:<span class="cov0" title="0">
                return goInt32</span>
        case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:<span class="cov0" title="0">
                return goUint32</span>
        case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:<span class="cov0" title="0">
                return goInt64</span>
        case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:<span class="cov0" title="0">
                return goUint64</span>
        case protoreflect.FloatKind:<span class="cov0" title="0">
                return goFloat32</span>
        case protoreflect.DoubleKind:<span class="cov0" title="0">
                return goFloat64</span>
        case protoreflect.StringKind:<span class="cov0" title="0">
                return goString</span>
        case protoreflect.BytesKind:<span class="cov0" title="0">
                return goBytes</span>
        case protoreflect.GroupKind, protoreflect.MessageKind:<span class="cov0" title="0">
                return getMapMessageValueType(g, field)</span>
        default:<span class="cov0" title="0">
                // For non-message types, use a temporary field
                tempField := &amp;protogen.Field{
                        Desc: field.Desc.MapValue(),
                }
                return getSingleFieldType(g, tempField)</span>
        }
}

func getMapMessageValueType(g *protogen.GeneratedFile, field *protogen.Field) string <span class="cov0" title="0">{
        // Find the actual message type for the map value
        if field.Message != nil &amp;&amp; field.Message.Fields != nil &amp;&amp; len(field.Message.Fields) &gt; 1 </span><span class="cov0" title="0">{
                // Map entry messages have exactly 2 fields: key and value
                for _, f := range field.Message.Fields </span><span class="cov0" title="0">{
                        if f.Desc.Number() == mapValueFieldNumber </span><span class="cov0" title="0">{ // value field is always number 2
                                return getSingleFieldType(g, f)
                        }</span>
                }
        }

        <span class="cov0" title="0">return goInterface</span>
}

func getMapKeyType(desc protoreflect.FieldDescriptor) string <span class="cov0" title="0">{
        switch desc.Kind() </span>{
        case protoreflect.StringKind:<span class="cov0" title="0">
                return goString</span>
        case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:<span class="cov0" title="0">
                return goInt32</span>
        case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:<span class="cov0" title="0">
                return goInt64</span>
        case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:<span class="cov0" title="0">
                return goUint32</span>
        case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:<span class="cov0" title="0">
                return goUint64</span>
        case protoreflect.BoolKind:<span class="cov0" title="0">
                return goBool</span>
        case protoreflect.EnumKind:<span class="cov0" title="0">
                return goInt32</span>
        case protoreflect.FloatKind:<span class="cov0" title="0">
                return goFloat32</span>
        case protoreflect.DoubleKind:<span class="cov0" title="0">
                return goFloat64</span>
        case protoreflect.BytesKind:<span class="cov0" title="0">
                return goBytes</span>
        case protoreflect.MessageKind:<span class="cov0" title="0">
                return goInterface</span>
        case protoreflect.GroupKind:<span class="cov0" title="0">
                return goInterface</span>
        default:<span class="cov0" title="0">
                return goString</span>
        }
}

func getSingleFieldType(g *protogen.GeneratedFile, field *protogen.Field) string <span class="cov6" title="5">{
        switch field.Desc.Kind() </span>{
        // String types
        case protoreflect.StringKind:<span class="cov6" title="5">
                return goString</span>

        // Boolean type
        case protoreflect.BoolKind:<span class="cov0" title="0">
                return goBool</span>

        // Integer types
        case protoreflect.Int32Kind:<span class="cov0" title="0">
                return goInt32</span>
        case protoreflect.Int64Kind:<span class="cov0" title="0">
                return goInt64</span>
        case protoreflect.Sint32Kind:<span class="cov0" title="0">
                return goInt32</span>
        case protoreflect.Sint64Kind:<span class="cov0" title="0">
                return goInt64</span>
        case protoreflect.Sfixed32Kind:<span class="cov0" title="0">
                return goInt32</span>
        case protoreflect.Sfixed64Kind:<span class="cov0" title="0">
                return goInt64</span>

        // Unsigned integer types
        case protoreflect.Uint32Kind:<span class="cov0" title="0">
                return goUint32</span>
        case protoreflect.Uint64Kind:<span class="cov0" title="0">
                return goUint64</span>
        case protoreflect.Fixed32Kind:<span class="cov0" title="0">
                return goUint32</span>
        case protoreflect.Fixed64Kind:<span class="cov0" title="0">
                return goUint64</span>

        // Floating point types
        case protoreflect.FloatKind:<span class="cov0" title="0">
                return goFloat32</span>
        case protoreflect.DoubleKind:<span class="cov0" title="0">
                return goFloat64</span>

        // Bytes type
        case protoreflect.BytesKind:<span class="cov0" title="0">
                return goBytes</span>

        // Enum type
        case protoreflect.EnumKind:<span class="cov0" title="0">
                if field.Enum != nil </span><span class="cov0" title="0">{
                        return g.QualifiedGoIdent(field.Enum.GoIdent)
                }</span>

                <span class="cov0" title="0">return goInt32</span> // fallback for enums

        // Message type
        case protoreflect.MessageKind:<span class="cov0" title="0">
                if field.Message != nil </span><span class="cov0" title="0">{
                        return "*" + g.QualifiedGoIdent(field.Message.GoIdent)
                }</span>

                <span class="cov0" title="0">return "*interface{}"</span> // fallback

        // Group type (deprecated but still supported)
        case protoreflect.GroupKind:<span class="cov0" title="0">
                if field.Message != nil </span><span class="cov0" title="0">{
                        return "*" + g.QualifiedGoIdent(field.Message.GoIdent)
                }</span>

                <span class="cov0" title="0">return "*interface{}"</span>

        default:<span class="cov0" title="0">
                return goInterface</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
