
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>oneofhelper: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/SebastienMelki/sebuf/internal/oneofhelper/generator.go (41.7%)</option>
				
				<option value="file1">github.com/SebastienMelki/sebuf/internal/openapiv3/generator.go (11.8%)</option>
				
				<option value="file2">github.com/SebastienMelki/sebuf/internal/openapiv3/http_annotations.go (0.0%)</option>
				
				<option value="file3">github.com/SebastienMelki/sebuf/internal/openapiv3/types.go (0.0%)</option>
				
				<option value="file4">github.com/SebastienMelki/sebuf/internal/openapiv3/validation.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package oneofhelper provides helper functions for protobuf messages with oneof fields.
package oneofhelper

import (
        "fmt"
        "strings"

        "google.golang.org/protobuf/compiler/protogen"
        "google.golang.org/protobuf/reflect/protoreflect"
)

const (
        goString            = "string"
        goInt32             = "int32"
        goInt64             = "int64"
        goUint32            = "uint32"
        goUint64            = "uint64"
        goBool              = "bool"
        goFloat32           = "float32"
        goFloat64           = "float64"
        goBytes             = "[]byte"
        goInterface         = "interface{}"
        mapValueFieldNumber = 2
)

// GenerateHelpers generates helper functions for all messages with oneofs in the given file.
func GenerateHelpers(plugin *protogen.Plugin, file *protogen.File) <span class="cov4" title="3">{
        filename := file.GeneratedFilenamePrefix + "_helpers.pb.go"
        g := plugin.NewGeneratedFile(filename, file.GoImportPath)

        // Write package header
        g.P("// Code generated by protoc-gen-go-oneof-helper. DO NOT EDIT.")
        g.P()
        g.P("package ", file.GoPackageName)
        g.P()

        // Generate helpers for each message with oneofs
        // The GeneratedFile will automatically handle imports for us
        for _, message := range file.Messages </span><span class="cov3" title="2">{
                GenerateMessageHelpers(g, message)
        }</span>
}

// GenerateMessageHelpers generates helper functions for a single message and its nested messages.
func GenerateMessageHelpers(g *protogen.GeneratedFile, message *protogen.Message) <span class="cov6" title="5">{
        // Look for oneofs
        for _, oneof := range message.Oneofs </span><span class="cov3" title="2">{
                // Generate a helper for each field in the oneof
                for _, field := range oneof.Fields </span><span class="cov4" title="3">{
                        GenerateOneofHelper(g, message, oneof, field)
                }</span>
        }

        // Recurse into nested messages
        <span class="cov6" title="5">for _, nested := range message.Messages </span><span class="cov4" title="3">{
                GenerateMessageHelpers(g, nested)
        }</span>
}

// GenerateOneofHelper generates a helper function for a specific oneof field.
func GenerateOneofHelper(g *protogen.GeneratedFile, message *protogen.Message,
        oneof *protogen.Oneof, field *protogen.Field,
) <span class="cov4" title="3">{
        // Generate helper function name
        helperName := fmt.Sprintf("New%s%s", message.GoIdent.GoName, field.GoName)

        // Get the wrapper type name (e.g., LoginMethod_Email)
        wrapperType := fmt.Sprintf("%s_%s", message.GoIdent.GoName, field.GoName)

        // Check if this field is a message type that might have fields
        if field.Message != nil </span><span class="cov4" title="3">{
                // Build parameter list from the nested message fields
                var params []string

                var paramAssignments []string

                for _, nestedField := range field.Message.Fields </span><span class="cov6" title="5">{
                        paramName := lowerFirst(nestedField.GoName)
                        paramType := GetFieldType(g, nestedField)
                        params = append(params, fmt.Sprintf("%s %s", paramName, paramType))
                        paramAssignments = append(paramAssignments,
                                fmt.Sprintf("\t\t\t%s: %s,", nestedField.GoName, paramName))
                }</span>

                // Generate the helper function
                <span class="cov4" title="3">g.P("// ", helperName, " creates a new ", message.GoIdent.GoName,
                        " with ", field.GoName, " set")
                g.P("func ", helperName, "(", strings.Join(params, ", "), ") *",
                        message.GoIdent.GoName, " {")
                g.P("\treturn &amp;", message.GoIdent.GoName, "{")
                g.P("\t\t", oneof.GoName, ": &amp;", wrapperType, "{")
                g.P("\t\t\t", field.GoName, ": &amp;", g.QualifiedGoIdent(field.Message.GoIdent), "{")

                for _, assignment := range paramAssignments </span><span class="cov6" title="5">{
                        g.P(assignment)
                }</span>

                <span class="cov4" title="3">g.P("\t\t\t},")
                g.P("\t\t},")
                g.P("\t}")
                g.P("}")
                g.P()</span>
        }
}

// LowerFirst converts the first character of a string to lowercase
// This function is exported for testing purposes.
func LowerFirst(s string) string <span class="cov8" title="12">{
        return lowerFirst(s)
}</span>

// lowerFirst is the internal implementation.
func lowerFirst(s string) string <span class="cov10" title="17">{
        if s == "" </span><span class="cov3" title="2">{
                return ""
        }</span>

        <span class="cov9" title="15">return strings.ToLower(s[:1]) + s[1:]</span>
}

// GetFieldType determines the Go type for a protobuf field.
func GetFieldType(g *protogen.GeneratedFile, field *protogen.Field) string <span class="cov6" title="5">{
        // Handle repeated fields
        if field.Desc.IsList() </span><span class="cov0" title="0">{
                return "[]" + getSingleFieldType(g, field)
        }</span>

        // Handle map fields
        <span class="cov6" title="5">if field.Desc.IsMap() </span><span class="cov0" title="0">{
                return getMapType(g, field)
        }</span>

        // Handle optional fields (proto3 optional)
        <span class="cov6" title="5">if field.Desc.HasOptionalKeyword() </span><span class="cov0" title="0">{
                return "*" + getSingleFieldType(g, field)
        }</span>

        <span class="cov6" title="5">return getSingleFieldType(g, field)</span>
}

func getMapType(g *protogen.GeneratedFile, field *protogen.Field) string <span class="cov0" title="0">{
        // For map keys, we need to handle the key type specially
        keyType := getMapKeyType(field.Desc.MapKey())
        valueType := getMapValueType(g, field)

        return "map[" + keyType + "]" + valueType
}</span>

func getMapValueType(g *protogen.GeneratedFile, field *protogen.Field) string <span class="cov0" title="0">{
        switch field.Desc.MapValue().Kind() </span>{
        case protoreflect.BoolKind:<span class="cov0" title="0">
                return goBool</span>
        case protoreflect.EnumKind:<span class="cov0" title="0">
                return goInt32</span>
        case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:<span class="cov0" title="0">
                return goInt32</span>
        case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:<span class="cov0" title="0">
                return goUint32</span>
        case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:<span class="cov0" title="0">
                return goInt64</span>
        case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:<span class="cov0" title="0">
                return goUint64</span>
        case protoreflect.FloatKind:<span class="cov0" title="0">
                return goFloat32</span>
        case protoreflect.DoubleKind:<span class="cov0" title="0">
                return goFloat64</span>
        case protoreflect.StringKind:<span class="cov0" title="0">
                return goString</span>
        case protoreflect.BytesKind:<span class="cov0" title="0">
                return goBytes</span>
        case protoreflect.GroupKind, protoreflect.MessageKind:<span class="cov0" title="0">
                return getMapMessageValueType(g, field)</span>
        default:<span class="cov0" title="0">
                // For non-message types, use a temporary field
                tempField := &amp;protogen.Field{
                        Desc: field.Desc.MapValue(),
                }
                return getSingleFieldType(g, tempField)</span>
        }
}

func getMapMessageValueType(g *protogen.GeneratedFile, field *protogen.Field) string <span class="cov0" title="0">{
        // Find the actual message type for the map value
        if field.Message != nil &amp;&amp; field.Message.Fields != nil &amp;&amp; len(field.Message.Fields) &gt; 1 </span><span class="cov0" title="0">{
                // Map entry messages have exactly 2 fields: key and value
                for _, f := range field.Message.Fields </span><span class="cov0" title="0">{
                        if f.Desc.Number() == mapValueFieldNumber </span><span class="cov0" title="0">{ // value field is always number 2
                                return getSingleFieldType(g, f)
                        }</span>
                }
        }

        <span class="cov0" title="0">return goInterface</span>
}

func getMapKeyType(desc protoreflect.FieldDescriptor) string <span class="cov0" title="0">{
        switch desc.Kind() </span>{
        case protoreflect.StringKind:<span class="cov0" title="0">
                return goString</span>
        case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:<span class="cov0" title="0">
                return goInt32</span>
        case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:<span class="cov0" title="0">
                return goInt64</span>
        case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:<span class="cov0" title="0">
                return goUint32</span>
        case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:<span class="cov0" title="0">
                return goUint64</span>
        case protoreflect.BoolKind:<span class="cov0" title="0">
                return goBool</span>
        case protoreflect.EnumKind:<span class="cov0" title="0">
                return goInt32</span>
        case protoreflect.FloatKind:<span class="cov0" title="0">
                return goFloat32</span>
        case protoreflect.DoubleKind:<span class="cov0" title="0">
                return goFloat64</span>
        case protoreflect.BytesKind:<span class="cov0" title="0">
                return goBytes</span>
        case protoreflect.MessageKind:<span class="cov0" title="0">
                return goInterface</span>
        case protoreflect.GroupKind:<span class="cov0" title="0">
                return goInterface</span>
        default:<span class="cov0" title="0">
                return goString</span>
        }
}

func getSingleFieldType(g *protogen.GeneratedFile, field *protogen.Field) string <span class="cov6" title="5">{
        switch field.Desc.Kind() </span>{
        // String types
        case protoreflect.StringKind:<span class="cov6" title="5">
                return goString</span>

        // Boolean type
        case protoreflect.BoolKind:<span class="cov0" title="0">
                return goBool</span>

        // Integer types
        case protoreflect.Int32Kind:<span class="cov0" title="0">
                return goInt32</span>
        case protoreflect.Int64Kind:<span class="cov0" title="0">
                return goInt64</span>
        case protoreflect.Sint32Kind:<span class="cov0" title="0">
                return goInt32</span>
        case protoreflect.Sint64Kind:<span class="cov0" title="0">
                return goInt64</span>
        case protoreflect.Sfixed32Kind:<span class="cov0" title="0">
                return goInt32</span>
        case protoreflect.Sfixed64Kind:<span class="cov0" title="0">
                return goInt64</span>

        // Unsigned integer types
        case protoreflect.Uint32Kind:<span class="cov0" title="0">
                return goUint32</span>
        case protoreflect.Uint64Kind:<span class="cov0" title="0">
                return goUint64</span>
        case protoreflect.Fixed32Kind:<span class="cov0" title="0">
                return goUint32</span>
        case protoreflect.Fixed64Kind:<span class="cov0" title="0">
                return goUint64</span>

        // Floating point types
        case protoreflect.FloatKind:<span class="cov0" title="0">
                return goFloat32</span>
        case protoreflect.DoubleKind:<span class="cov0" title="0">
                return goFloat64</span>

        // Bytes type
        case protoreflect.BytesKind:<span class="cov0" title="0">
                return goBytes</span>

        // Enum type
        case protoreflect.EnumKind:<span class="cov0" title="0">
                if field.Enum != nil </span><span class="cov0" title="0">{
                        return g.QualifiedGoIdent(field.Enum.GoIdent)
                }</span>

                <span class="cov0" title="0">return goInt32</span> // fallback for enums

        // Message type
        case protoreflect.MessageKind:<span class="cov0" title="0">
                if field.Message != nil </span><span class="cov0" title="0">{
                        return "*" + g.QualifiedGoIdent(field.Message.GoIdent)
                }</span>

                <span class="cov0" title="0">return "*interface{}"</span> // fallback

        // Group type (deprecated but still supported)
        case protoreflect.GroupKind:<span class="cov0" title="0">
                if field.Message != nil </span><span class="cov0" title="0">{
                        return "*" + g.QualifiedGoIdent(field.Message.GoIdent)
                }</span>

                <span class="cov0" title="0">return "*interface{}"</span>

        default:<span class="cov0" title="0">
                return goInterface</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package openapiv3

import (
        "fmt"
        "google.golang.org/protobuf/proto"
        "strings"

        "github.com/pb33f/libopenapi/datamodel/high/base"
        v3 "github.com/pb33f/libopenapi/datamodel/high/v3"
        "github.com/pb33f/libopenapi/orderedmap"
        "google.golang.org/protobuf/compiler/protogen"
        "gopkg.in/yaml.v3"
        k8syaml "sigs.k8s.io/yaml"
)

// OutputFormat represents the output format for the OpenAPI document.
type OutputFormat string

const (
        FormatYAML OutputFormat = "yaml"
        FormatJSON OutputFormat = "json"
)

// Generator generates OpenAPI v3.1 documents from Protocol Buffer definitions.
type Generator struct {
        doc     *v3.Document
        schemas *orderedmap.Map[string, *base.SchemaProxy]
        format  OutputFormat
}

// NewGenerator creates a new OpenAPI generator with the specified output format.
func NewGenerator(format OutputFormat) *Generator <span class="cov10" title="4">{
        schemas := orderedmap.New[string, *base.SchemaProxy]()

        return &amp;Generator{
                format:  format,
                schemas: schemas,
                doc: &amp;v3.Document{
                        Version: "3.1.0",
                        Info: &amp;base.Info{
                                Title:   "Generated API",
                                Version: "1.0.0",
                        },
                        Paths: &amp;v3.Paths{
                                PathItems: orderedmap.New[string, *v3.PathItem](),
                        },
                        Components: &amp;v3.Components{
                                Schemas: schemas,
                        },
                },
        }
}</span>

// ProcessMessage processes a single message and adds it to the OpenAPI schemas.
// This is now exported to be called from main.go
func (g *Generator) ProcessMessage(message *protogen.Message) <span class="cov0" title="0">{
        g.processMessage(message)
}</span>

// ProcessService processes a single service and adds its paths to the OpenAPI document.
// This is now exported to be called from main.go
func (g *Generator) ProcessService(service *protogen.Service) <span class="cov0" title="0">{
        // Update document info with service name
        g.doc.Info.Title = fmt.Sprintf("%s API", service.Desc.Name())
        
        // Process the service
        g.processService(service)
}</span>

// processMessage converts a protobuf message to an OpenAPI schema.
func (g *Generator) processMessage(message *protogen.Message) <span class="cov0" title="0">{
        schema := g.buildObjectSchema(message)
        schemaName := string(message.Desc.Name())
        g.schemas.Set(schemaName, schema)

        // Process nested messages recursively
        for _, nested := range message.Messages </span><span class="cov0" title="0">{
                g.processMessage(nested)
        }</span>
}

// buildObjectSchema creates an OpenAPI object schema from a protobuf message.
func (g *Generator) buildObjectSchema(message *protogen.Message) *base.SchemaProxy <span class="cov0" title="0">{
        properties := orderedmap.New[string, *base.SchemaProxy]()
        var required []string

        for _, field := range message.Fields </span><span class="cov0" title="0">{
                fieldSchema := g.convertField(field)
                fieldName := field.Desc.JSONName()
                properties.Set(fieldName, fieldSchema)

                // Check if field has the required constraint from buf.validate
                if checkIfFieldRequired(field) </span><span class="cov0" title="0">{
                        required = append(required, fieldName)
                }</span>
        }

        <span class="cov0" title="0">schema := &amp;base.Schema{
                Type:       []string{"object"},
                Properties: properties,
        }

        if len(required) &gt; 0 </span><span class="cov0" title="0">{
                schema.Required = required
        }</span>

        // Add description from comments
        <span class="cov0" title="0">if message.Comments.Leading != "" </span><span class="cov0" title="0">{
                schema.Description = strings.TrimSpace(string(message.Comments.Leading))
        }</span>

        <span class="cov0" title="0">return base.CreateSchemaProxy(schema)</span>
}

// processService converts a protobuf service to OpenAPI paths.
func (g *Generator) processService(service *protogen.Service) <span class="cov0" title="0">{
        for _, method := range service.Methods </span><span class="cov0" title="0">{
                g.processMethod(service, method)
        }</span>
}

// processMethod converts a protobuf RPC method to an OpenAPI operation.
func (g *Generator) processMethod(service *protogen.Service, method *protogen.Method) <span class="cov0" title="0">{
        // Extract HTTP configuration from annotations
        var path string
        serviceConfig := getServiceHTTPConfig(service)
        methodConfig := getMethodHTTPConfig(method)

        if serviceConfig != nil || methodConfig != nil </span><span class="cov0" title="0">{
                // Use sebuf.http annotations
                servicePath := ""
                methodPath := ""

                if serviceConfig != nil </span><span class="cov0" title="0">{
                        servicePath = serviceConfig.BasePath
                }</span>
                <span class="cov0" title="0">if methodConfig != nil </span><span class="cov0" title="0">{
                        methodPath = methodConfig.Path
                }</span>

                <span class="cov0" title="0">path = buildHTTPPath(servicePath, methodPath)</span>
        } else<span class="cov0" title="0"> {
                // Fallback to gRPC-style path
                path = fmt.Sprintf("/%s/%s", service.Desc.Name(), method.Desc.Name())
        }</span>

        // Create operation
        <span class="cov0" title="0">operation := &amp;v3.Operation{
                OperationId: string(method.Desc.Name()),
                Summary:     string(method.Desc.Name()),
                Tags:        []string{string(service.Desc.Name())},
        }

        // Add description from comments
        if method.Comments.Leading != "" </span><span class="cov0" title="0">{
                operation.Description = strings.TrimSpace(string(method.Comments.Leading))
        }</span>

        // Extract and add header parameters
        <span class="cov0" title="0">serviceHeaders := getServiceHeaders(service)
        methodHeaders := getMethodHeaders(method)
        allHeaders := combineHeaders(serviceHeaders, methodHeaders)

        if len(allHeaders) &gt; 0 </span><span class="cov0" title="0">{
                headerParameters := convertHeadersToParameters(allHeaders)
                operation.Parameters = headerParameters
        }</span>

        // Add request body for the input message
        <span class="cov0" title="0">inputSchemaRef := fmt.Sprintf("#/components/schemas/%s", method.Input.Desc.Name())
        operation.RequestBody = &amp;v3.RequestBody{
                Required: proto.Bool(true), // Convert bool to *bool
                Content:  orderedmap.New[string, *v3.MediaType](),
        }
        operation.RequestBody.Content.Set("application/json", &amp;v3.MediaType{
                Schema: base.CreateSchemaProxyRef(inputSchemaRef),
        })

        // Add response for the output message
        outputSchemaRef := fmt.Sprintf("#/components/schemas/%s", method.Output.Desc.Name())
        responses := orderedmap.New[string, *v3.Response]()

        successResponse := &amp;v3.Response{
                Description: "Successful response",
                Content:     orderedmap.New[string, *v3.MediaType](),
        }
        successResponse.Content.Set("application/json", &amp;v3.MediaType{
                Schema: base.CreateSchemaProxyRef(outputSchemaRef),
        })
        responses.Set("200", successResponse)

        // Add default error response
        errorSchema := base.CreateSchemaProxy(&amp;base.Schema{
                Type: []string{"object"},
                Properties: func() *orderedmap.Map[string, *base.SchemaProxy] </span><span class="cov0" title="0">{
                        props := orderedmap.New[string, *base.SchemaProxy]()
                        props.Set("error", base.CreateSchemaProxy(&amp;base.Schema{
                                Type: []string{"string"},
                        }))
                        props.Set("code", base.CreateSchemaProxy(&amp;base.Schema{
                                Type: []string{"integer"},
                        }))
                        return props
                }</span>(),
        })

        <span class="cov0" title="0">errorResponse := &amp;v3.Response{
                Description: "Error response",
                Content:     orderedmap.New[string, *v3.MediaType](),
        }
        errorResponse.Content.Set("application/json", &amp;v3.MediaType{
                Schema: errorSchema,
        })
        responses.Set("default", errorResponse)

        operation.Responses = &amp;v3.Responses{
                Codes: responses,
        }

        // Create path item and add to document
        pathItem := &amp;v3.PathItem{
                Post: operation, // Default to POST for gRPC-style operations
        }

        g.doc.Paths.PathItems.Set(path, pathItem)</span>
}

// Render outputs the OpenAPI document in the specified format.
func (g *Generator) Render() ([]byte, error) <span class="cov5" title="2">{
        switch g.format </span>{
        case FormatJSON:<span class="cov1" title="1">
                // First marshal to YAML (which works correctly with libopenapi)
                yamlData, err := yaml.Marshal(g.doc)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal to YAML: %w", err)
                }</span>
                // Then convert YAML to JSON
                <span class="cov1" title="1">jsonData, err := k8syaml.YAMLToJSON(yamlData)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to convert YAML to JSON: %w", err)
                }</span>
                <span class="cov1" title="1">return jsonData, nil</span>
        case FormatYAML:<span class="cov1" title="1">
                return yaml.Marshal(g.doc)</span>
        default:<span class="cov0" title="0">
                return yaml.Marshal(g.doc)</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package openapiv3

import (
        "strings"

        "github.com/pb33f/libopenapi/datamodel/high/base"
        v3 "github.com/pb33f/libopenapi/datamodel/high/v3"
        "google.golang.org/protobuf/compiler/protogen"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/types/descriptorpb"
        "gopkg.in/yaml.v3"

        "github.com/SebastienMelki/sebuf/http"
)

// HTTPConfig represents the HTTP configuration for a method.
type HTTPConfig struct {
        Path string
}

// ServiceHTTPConfig represents the HTTP configuration for a service.
type ServiceHTTPConfig struct {
        BasePath string
}

// getMethodHTTPConfig extracts HTTP configuration from method options.
func getMethodHTTPConfig(method *protogen.Method) *HTTPConfig <span class="cov0" title="0">{
        options := method.Desc.Options()
        if options == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the raw options
        <span class="cov0" title="0">methodOptions, ok := options.(*descriptorpb.MethodOptions)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract our custom extension using the generated code
        <span class="cov0" title="0">ext := proto.GetExtension(methodOptions, http.E_Config)
        if ext == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">httpConfig, ok := ext.(*http.HttpConfig)
        if !ok || httpConfig == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;HTTPConfig{
                Path: httpConfig.GetPath(),
        }</span>
}

// getServiceHTTPConfig extracts HTTP configuration from service options.
func getServiceHTTPConfig(service *protogen.Service) *ServiceHTTPConfig <span class="cov0" title="0">{
        options := service.Desc.Options()
        if options == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the raw options
        <span class="cov0" title="0">serviceOptions, ok := options.(*descriptorpb.ServiceOptions)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract our custom extension using the generated code
        <span class="cov0" title="0">ext := proto.GetExtension(serviceOptions, http.E_ServiceConfig)
        if ext == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">serviceConfig, ok := ext.(*http.ServiceConfig)
        if !ok || serviceConfig == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;ServiceHTTPConfig{
                BasePath: serviceConfig.GetBasePath(),
        }</span>
}

// buildHTTPPath combines service base path with method path
func buildHTTPPath(servicePath, methodPath string) string <span class="cov0" title="0">{
        // Handle empty paths
        if servicePath == "" &amp;&amp; methodPath == "" </span><span class="cov0" title="0">{
                return "/"
        }</span>
        <span class="cov0" title="0">if servicePath == "" </span><span class="cov0" title="0">{
                return ensureLeadingSlash(methodPath)
        }</span>
        <span class="cov0" title="0">if methodPath == "" </span><span class="cov0" title="0">{
                return ensureLeadingSlash(servicePath)
        }</span>

        // Clean and combine paths
        <span class="cov0" title="0">servicePath = strings.TrimSuffix(ensureLeadingSlash(servicePath), "/")
        methodPath = strings.TrimPrefix(methodPath, "/")

        return servicePath + "/" + methodPath</span>
}

// ensureLeadingSlash ensures a path starts with "/"
func ensureLeadingSlash(path string) string <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                return "/"
        }</span>
        <span class="cov0" title="0">if !strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                return "/" + path
        }</span>
        <span class="cov0" title="0">return path</span>
}

// getServiceHeaders extracts header configuration from service options.
func getServiceHeaders(service *protogen.Service) []*http.Header <span class="cov0" title="0">{
        options := service.Desc.Options()
        if options == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the raw options
        <span class="cov0" title="0">serviceOptions, ok := options.(*descriptorpb.ServiceOptions)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract our custom extension using the generated code
        <span class="cov0" title="0">ext := proto.GetExtension(serviceOptions, http.E_ServiceHeaders)
        if ext == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">serviceHeaders, ok := ext.(*http.ServiceHeaders)
        if !ok || serviceHeaders == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return serviceHeaders.GetRequiredHeaders()</span>
}

// getMethodHeaders extracts header configuration from method options.
func getMethodHeaders(method *protogen.Method) []*http.Header <span class="cov0" title="0">{
        options := method.Desc.Options()
        if options == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the raw options
        <span class="cov0" title="0">methodOptions, ok := options.(*descriptorpb.MethodOptions)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract our custom extension using the generated code
        <span class="cov0" title="0">ext := proto.GetExtension(methodOptions, http.E_MethodHeaders)
        if ext == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">methodHeaders, ok := ext.(*http.MethodHeaders)
        if !ok || methodHeaders == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return methodHeaders.GetRequiredHeaders()</span>
}

// combineHeaders merges service headers with method headers, with method headers taking precedence
func combineHeaders(serviceHeaders, methodHeaders []*http.Header) []*http.Header <span class="cov0" title="0">{
        if len(serviceHeaders) == 0 </span><span class="cov0" title="0">{
                return methodHeaders
        }</span>
        <span class="cov0" title="0">if len(methodHeaders) == 0 </span><span class="cov0" title="0">{
                return serviceHeaders
        }</span>

        // Create a map to track headers by name for deduplication
        <span class="cov0" title="0">headerMap := make(map[string]*http.Header)

        // Add service headers first
        for _, header := range serviceHeaders </span><span class="cov0" title="0">{
                if header.GetName() != "" </span><span class="cov0" title="0">{
                        headerMap[header.GetName()] = header
                }</span>
        }

        // Add method headers, overriding service headers with same name
        <span class="cov0" title="0">for _, header := range methodHeaders </span><span class="cov0" title="0">{
                if header.GetName() != "" </span><span class="cov0" title="0">{
                        headerMap[header.GetName()] = header
                }</span>
        }

        // Convert back to slice
        <span class="cov0" title="0">result := make([]*http.Header, 0, len(headerMap))
        for _, header := range headerMap </span><span class="cov0" title="0">{
                result = append(result, header)
        }</span>

        <span class="cov0" title="0">return result</span>
}

// convertHeadersToParameters converts proto headers to OpenAPI parameters
func convertHeadersToParameters(headers []*http.Header) []*v3.Parameter <span class="cov0" title="0">{
        if len(headers) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">parameters := make([]*v3.Parameter, 0, len(headers))

        for _, header := range headers </span><span class="cov0" title="0">{
                if header.GetName() == "" </span><span class="cov0" title="0">{
                        continue</span> // Skip headers without names
                }

                // Create the schema for the header
                <span class="cov0" title="0">schema := &amp;base.Schema{
                        Type: []string{mapHeaderTypeToOpenAPI(header.GetType())},
                }

                // Add format if specified
                if header.GetFormat() != "" </span><span class="cov0" title="0">{
                        schema.Format = header.GetFormat()
                }</span>

                // Add example if specified
                <span class="cov0" title="0">if header.GetExample() != "" </span><span class="cov0" title="0">{
                        schema.Example = &amp;yaml.Node{
                                Kind:  yaml.ScalarNode,
                                Value: header.GetExample(),
                        }
                }</span>

                // Create the parameter
                <span class="cov0" title="0">parameter := &amp;v3.Parameter{
                        Name:        header.GetName(),
                        In:          "header",
                        Required:    &amp;header.Required,
                        Schema:      base.CreateSchemaProxy(schema),
                        Description: header.GetDescription(),
                }

                // Set deprecated if specified
                if header.GetDeprecated() </span><span class="cov0" title="0">{
                        parameter.Deprecated = true
                }</span>

                <span class="cov0" title="0">parameters = append(parameters, parameter)</span>
        }

        <span class="cov0" title="0">return parameters</span>
}

// mapHeaderTypeToOpenAPI maps proto header types to OpenAPI schema types
func mapHeaderTypeToOpenAPI(headerType string) string <span class="cov0" title="0">{
        switch strings.ToLower(headerType) </span>{
        case "string", "":<span class="cov0" title="0">
                return "string"</span>
        case "integer", "int", "int32", "int64":<span class="cov0" title="0">
                return "integer"</span>
        case "number", "float", "double":<span class="cov0" title="0">
                return "number"</span>
        case "boolean", "bool":<span class="cov0" title="0">
                return "boolean"</span>
        case "array":<span class="cov0" title="0">
                return "array"</span>
        default:<span class="cov0" title="0">
                // Default to string for unknown types
                return "string"</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package openapiv3

import (
        "fmt"
        "strings"

        "github.com/pb33f/libopenapi/datamodel/high/base"
        "google.golang.org/protobuf/compiler/protogen"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/reflect/protoreflect"
        "google.golang.org/protobuf/types/descriptorpb"
        "gopkg.in/yaml.v3"

        "github.com/SebastienMelki/sebuf/http"
)

// convertField converts a protobuf field to an OpenAPI schema.
func (g *Generator) convertField(field *protogen.Field) *base.SchemaProxy <span class="cov0" title="0">{
        // Handle repeated fields (arrays)
        if field.Desc.IsList() </span><span class="cov0" title="0">{
                itemSchema := g.convertScalarField(field)
                arraySchema := &amp;base.Schema{
                        Type: []string{"array"},
                        Items: &amp;base.DynamicValue[*base.SchemaProxy, bool]{
                                A: itemSchema,
                        },
                }

                // Apply validation constraints for the array itself
                extractValidationConstraints(field, arraySchema)

                return base.CreateSchemaProxy(arraySchema)
        }</span>

        // Handle map fields
        <span class="cov0" title="0">if field.Desc.IsMap() </span><span class="cov0" title="0">{
                return g.convertMapField(field)
        }</span>

        // Handle optional fields (proto3 optional)
        <span class="cov0" title="0">schema := g.convertScalarField(field)
        if field.Desc.HasOptionalKeyword() </span><span class="cov0" title="0">{
                // For proto3 optional fields, we could add nullable: true
                // but OpenAPI 3.1 handles this differently than 3.0
                return schema
        }</span>

        <span class="cov0" title="0">return schema</span>
}

// convertScalarField handles scalar field types and message references.
func (g *Generator) convertScalarField(field *protogen.Field) *base.SchemaProxy <span class="cov0" title="0">{
        schema := &amp;base.Schema{}

        switch field.Desc.Kind() </span>{
        case protoreflect.BoolKind:<span class="cov0" title="0">
                schema.Type = []string{"boolean"}</span>

        case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:<span class="cov0" title="0">
                schema.Type = []string{"integer"}
                schema.Format = "int32"</span>

        case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:<span class="cov0" title="0">
                schema.Type = []string{"integer"}
                schema.Format = "int64"</span>

        case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:<span class="cov0" title="0">
                schema.Type = []string{"integer"}
                schema.Format = "int32"
                zero := 0.0
                schema.Minimum = &amp;zero</span>

        case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:<span class="cov0" title="0">
                schema.Type = []string{"integer"}
                schema.Format = "int64"
                zero := 0.0
                schema.Minimum = &amp;zero</span>

        case protoreflect.FloatKind:<span class="cov0" title="0">
                schema.Type = []string{"number"}
                schema.Format = "float"</span>

        case protoreflect.DoubleKind:<span class="cov0" title="0">
                schema.Type = []string{"number"}
                schema.Format = "double"</span>

        case protoreflect.StringKind:<span class="cov0" title="0">
                schema.Type = []string{"string"}</span>

        case protoreflect.BytesKind:<span class="cov0" title="0">
                schema.Type = []string{"string"}
                schema.Format = "byte"</span>

        case protoreflect.EnumKind:<span class="cov0" title="0">
                return g.convertEnumField(field)</span>

        case protoreflect.MessageKind:<span class="cov0" title="0">
                // Reference to another message
                return base.CreateSchemaProxyRef(fmt.Sprintf("#/components/schemas/%s", field.Message.Desc.Name()))</span>

        case protoreflect.GroupKind:<span class="cov0" title="0">
                // Groups are deprecated but still supported
                if field.Message != nil </span><span class="cov0" title="0">{
                        return base.CreateSchemaProxyRef(fmt.Sprintf("#/components/schemas/%s", field.Message.Desc.Name()))
                }</span>
                <span class="cov0" title="0">schema.Type = []string{"object"}</span>

        default:<span class="cov0" title="0">
                // Fallback for unknown types
                schema.Type = []string{"string"}</span>
        }

        // Add description from field comments
        <span class="cov0" title="0">if field.Comments.Leading != "" </span><span class="cov0" title="0">{
                schema.Description = strings.TrimSpace(string(field.Comments.Leading))
        }</span>

        // Apply buf.validate constraints
        <span class="cov0" title="0">extractValidationConstraints(field, schema)

        // Add field examples if available
        if examples := getFieldExamples(field); len(examples) &gt; 0 </span><span class="cov0" title="0">{
                // Set the first example as the default example
                schema.Example = &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: examples[0],
                }

                // Add all examples using OpenAPI 3.1 examples array format
                schema.Examples = make([]*yaml.Node, len(examples))
                for i, example := range examples </span><span class="cov0" title="0">{
                        schema.Examples[i] = &amp;yaml.Node{
                                Kind:  yaml.ScalarNode,
                                Value: example,
                        }
                }</span>
        }

        <span class="cov0" title="0">return base.CreateSchemaProxy(schema)</span>
}

// convertEnumField converts a protobuf enum field to an OpenAPI schema.
func (g *Generator) convertEnumField(field *protogen.Field) *base.SchemaProxy <span class="cov0" title="0">{
        if field.Enum == nil </span><span class="cov0" title="0">{
                // Fallback if enum is not available
                return base.CreateSchemaProxy(&amp;base.Schema{
                        Type: []string{"string"},
                })
        }</span>

        <span class="cov0" title="0">schema := &amp;base.Schema{
                Type: []string{"string"},
                Enum: make([]*yaml.Node, 0, len(field.Enum.Values)),
        }

        // Add enum values
        for _, value := range field.Enum.Values </span><span class="cov0" title="0">{
                schema.Enum = append(schema.Enum, &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: string(value.Desc.Name()),
                })
        }</span>

        // Add description from enum comments
        <span class="cov0" title="0">if field.Enum.Comments.Leading != "" </span><span class="cov0" title="0">{
                schema.Description = strings.TrimSpace(string(field.Enum.Comments.Leading))
        }</span>

        <span class="cov0" title="0">return base.CreateSchemaProxy(schema)</span>
}

// convertMapField converts a protobuf map field to an OpenAPI schema.
func (g *Generator) convertMapField(field *protogen.Field) *base.SchemaProxy <span class="cov0" title="0">{
        schema := &amp;base.Schema{
                Type: []string{"object"},
        }

        // For maps, we need to determine the value type
        if field.Message != nil &amp;&amp; len(field.Message.Fields) &gt;= 2 </span><span class="cov0" title="0">{
                // Map entry messages have exactly 2 fields: key (field 1) and value (field 2)
                var valueField *protogen.Field
                const mapValueFieldNumber = 2 // value field is always number 2 in protobuf map entries
                for _, f := range field.Message.Fields </span><span class="cov0" title="0">{
                        if f.Desc.Number() == mapValueFieldNumber </span><span class="cov0" title="0">{
                                valueField = f
                                break</span>
                        }
                }

                <span class="cov0" title="0">if valueField != nil </span><span class="cov0" title="0">{
                        valueSchema := g.convertScalarField(valueField)
                        schema.AdditionalProperties = &amp;base.DynamicValue[*base.SchemaProxy, bool]{
                                A: valueSchema,
                        }
                }</span>
        }

        // If we couldn't determine the value type, allow any type
        <span class="cov0" title="0">if schema.AdditionalProperties == nil </span><span class="cov0" title="0">{
                schema.AdditionalProperties = &amp;base.DynamicValue[*base.SchemaProxy, bool]{
                        B: true,
                }
        }</span>

        // Add description from field comments
        <span class="cov0" title="0">if field.Comments.Leading != "" </span><span class="cov0" title="0">{
                schema.Description = strings.TrimSpace(string(field.Comments.Leading))
        }</span>

        // Apply validation constraints for the map itself
        <span class="cov0" title="0">extractValidationConstraints(field, schema)

        return base.CreateSchemaProxy(schema)</span>
}

// getFieldExamples extracts example values from field options.
func getFieldExamples(field *protogen.Field) []string <span class="cov0" title="0">{
        options := field.Desc.Options()
        if options == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get the raw options
        <span class="cov0" title="0">fieldOptions, ok := options.(*descriptorpb.FieldOptions)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Extract our custom extension using the generated code
        <span class="cov0" title="0">ext := proto.GetExtension(fieldOptions, http.E_FieldExamples)
        if ext == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">fieldExamples, ok := ext.(*http.FieldExamples)
        if !ok || fieldExamples == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return fieldExamples.GetValues()</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package openapiv3

import (
        "fmt"

        "github.com/pb33f/libopenapi/datamodel/high/base"
        "google.golang.org/protobuf/compiler/protogen"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/reflect/protoreflect"
        "gopkg.in/yaml.v3"

        validate "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
)

// extractValidationConstraints extracts buf.validate field options and applies them to the schema
func extractValidationConstraints(field *protogen.Field, schema *base.Schema) <span class="cov0" title="0">{
        // Get the field descriptor options
        fieldOptions := field.Desc.Options()
        if fieldOptions == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Extract the buf.validate field extension
        <span class="cov0" title="0">ext := proto.GetExtension(fieldOptions, validate.E_Field)
        if ext == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Type assert to FieldRules
        <span class="cov0" title="0">fieldConstraints, ok := ext.(*validate.FieldRules)
        if !ok || fieldConstraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Apply constraints based on field type
        <span class="cov0" title="0">switch field.Desc.Kind() </span>{
        case protoreflect.StringKind:<span class="cov0" title="0">
                applyStringConstraints(fieldConstraints, schema)</span>
        case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind,
                protoreflect.Uint32Kind, protoreflect.Fixed32Kind:<span class="cov0" title="0">
                applyInt32Constraints(fieldConstraints, schema)</span>
        case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind,
                protoreflect.Uint64Kind, protoreflect.Fixed64Kind:<span class="cov0" title="0">
                applyInt64Constraints(fieldConstraints, schema)</span>
        case protoreflect.FloatKind:<span class="cov0" title="0">
                applyFloatConstraints(fieldConstraints, schema)</span>
        case protoreflect.DoubleKind:<span class="cov0" title="0">
                applyDoubleConstraints(fieldConstraints, schema)</span>
        }

        // Handle repeated field constraints
        <span class="cov0" title="0">if field.Desc.IsList() </span><span class="cov0" title="0">{
                applyRepeatedConstraints(fieldConstraints, schema)
        }</span>

        // Handle map field constraints
        <span class="cov0" title="0">if field.Desc.IsMap() </span><span class="cov0" title="0">{
                applyMapConstraints(fieldConstraints, schema)
        }</span>

        // Handle required constraint
        <span class="cov0" title="0">if fieldConstraints.GetRequired() </span>{<span class="cov0" title="0">
                // Note: Required is handled at the message level, not here
                // This is a marker for the parent message to add this field to required[]
        }</span>
}

// applyStringConstraints applies string validation constraints to the schema
func applyStringConstraints(constraints *validate.FieldRules, schema *base.Schema) <span class="cov0" title="0">{
        stringConstraints := constraints.GetString_()
        if stringConstraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Min and max length
        <span class="cov0" title="0">if stringConstraints.HasMinLen() </span><span class="cov0" title="0">{
                minLen := int64(stringConstraints.GetMinLen())
                schema.MinLength = &amp;minLen
        }</span>
        <span class="cov0" title="0">if stringConstraints.HasMaxLen() </span><span class="cov0" title="0">{
                maxLen := int64(stringConstraints.GetMaxLen())
                schema.MaxLength = &amp;maxLen
        }</span>

        // Pattern (regex)
        <span class="cov0" title="0">if stringConstraints.HasPattern() </span><span class="cov0" title="0">{
                schema.Pattern = stringConstraints.GetPattern()
        }</span>

        // Format constraints
        <span class="cov0" title="0">if stringConstraints.GetEmail() </span><span class="cov0" title="0">{
                schema.Format = "email"
        }</span> else<span class="cov0" title="0"> if stringConstraints.GetUuid() </span><span class="cov0" title="0">{
                schema.Format = "uuid"
        }</span> else<span class="cov0" title="0"> if stringConstraints.GetUri() </span><span class="cov0" title="0">{
                schema.Format = "uri"
        }</span> else<span class="cov0" title="0"> if stringConstraints.GetUriRef() </span><span class="cov0" title="0">{
                schema.Format = "uri-reference"
        }</span> else<span class="cov0" title="0"> if stringConstraints.GetAddress() </span><span class="cov0" title="0">{
                // IPv4 or IPv6 address
                schema.Format = "ip"
        }</span> else<span class="cov0" title="0"> if stringConstraints.GetHostname() </span><span class="cov0" title="0">{
                schema.Format = "hostname"
        }</span> else<span class="cov0" title="0"> if stringConstraints.GetIp() </span><span class="cov0" title="0">{
                schema.Format = "ip"
        }</span> else<span class="cov0" title="0"> if stringConstraints.GetIpv4() </span><span class="cov0" title="0">{
                schema.Format = "ipv4"
        }</span> else<span class="cov0" title="0"> if stringConstraints.GetIpv6() </span><span class="cov0" title="0">{
                schema.Format = "ipv6"
        }</span>

        // Enum values (in constraint)
        <span class="cov0" title="0">if len(stringConstraints.In) &gt; 0 </span><span class="cov0" title="0">{
                schema.Enum = make([]*yaml.Node, 0, len(stringConstraints.In))
                for _, value := range stringConstraints.In </span><span class="cov0" title="0">{
                        schema.Enum = append(schema.Enum, &amp;yaml.Node{
                                Kind:  yaml.ScalarNode,
                                Value: value,
                        })
                }</span>
        }

        // Const value
        <span class="cov0" title="0">if stringConstraints.HasConst() </span><span class="cov0" title="0">{
                val := stringConstraints.GetConst()
                schema.Const = &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: val,
                }
        }</span>
}

// applyInt32Constraints applies int32 validation constraints to the schema
func applyInt32Constraints(constraints *validate.FieldRules, schema *base.Schema) <span class="cov0" title="0">{
        int32Constraints := constraints.GetInt32()
        if int32Constraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Greater than or equal (minimum)
        <span class="cov0" title="0">if int32Constraints.HasGte() </span><span class="cov0" title="0">{
                min := float64(int32Constraints.GetGte())
                schema.Minimum = &amp;min
        }</span>

        // Greater than (exclusive minimum)
        <span class="cov0" title="0">if int32Constraints.HasGt() </span><span class="cov0" title="0">{
                min := float64(int32Constraints.GetGt())
                schema.ExclusiveMinimum = &amp;base.DynamicValue[bool, float64]{B: min}
        }</span>

        // Less than or equal (maximum)
        <span class="cov0" title="0">if int32Constraints.HasLte() </span><span class="cov0" title="0">{
                max := float64(int32Constraints.GetLte())
                schema.Maximum = &amp;max
        }</span>

        // Less than (exclusive maximum)
        <span class="cov0" title="0">if int32Constraints.HasLt() </span><span class="cov0" title="0">{
                max := float64(int32Constraints.GetLt())
                schema.ExclusiveMaximum = &amp;base.DynamicValue[bool, float64]{B: max}
        }</span>

        // Const value
        <span class="cov0" title="0">if int32Constraints.HasConst() </span><span class="cov0" title="0">{
                schema.Const = &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: fmt.Sprintf("%d", int32Constraints.GetConst()),
                }
        }</span>

        // Enum values (in constraint)
        <span class="cov0" title="0">if len(int32Constraints.In) &gt; 0 </span><span class="cov0" title="0">{
                schema.Enum = make([]*yaml.Node, 0, len(int32Constraints.In))
                for _, value := range int32Constraints.In </span><span class="cov0" title="0">{
                        schema.Enum = append(schema.Enum, &amp;yaml.Node{
                                Kind:  yaml.ScalarNode,
                                Value: fmt.Sprintf("%d", value),
                        })
                }</span>
        }
}

// applyInt64Constraints applies int64 validation constraints to the schema
func applyInt64Constraints(constraints *validate.FieldRules, schema *base.Schema) <span class="cov0" title="0">{
        int64Constraints := constraints.GetInt64()
        if int64Constraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Greater than or equal (minimum)
        <span class="cov0" title="0">if int64Constraints.HasGte() </span><span class="cov0" title="0">{
                min := float64(int64Constraints.GetGte())
                schema.Minimum = &amp;min
        }</span>

        // Greater than (exclusive minimum)
        <span class="cov0" title="0">if int64Constraints.HasGt() </span><span class="cov0" title="0">{
                min := float64(int64Constraints.GetGt())
                schema.ExclusiveMinimum = &amp;base.DynamicValue[bool, float64]{B: min}
        }</span>

        // Less than or equal (maximum)
        <span class="cov0" title="0">if int64Constraints.HasLte() </span><span class="cov0" title="0">{
                max := float64(int64Constraints.GetLte())
                schema.Maximum = &amp;max
        }</span>

        // Less than (exclusive maximum)
        <span class="cov0" title="0">if int64Constraints.HasLt() </span><span class="cov0" title="0">{
                max := float64(int64Constraints.GetLt())
                schema.ExclusiveMaximum = &amp;base.DynamicValue[bool, float64]{B: max}
        }</span>

        // Const value
        <span class="cov0" title="0">if int64Constraints.HasConst() </span><span class="cov0" title="0">{
                schema.Const = &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: fmt.Sprintf("%d", int64Constraints.GetConst()),
                }
        }</span>

        // Enum values (in constraint)
        <span class="cov0" title="0">if len(int64Constraints.In) &gt; 0 </span><span class="cov0" title="0">{
                schema.Enum = make([]*yaml.Node, 0, len(int64Constraints.In))
                for _, value := range int64Constraints.In </span><span class="cov0" title="0">{
                        schema.Enum = append(schema.Enum, &amp;yaml.Node{
                                Kind:  yaml.ScalarNode,
                                Value: fmt.Sprintf("%d", value),
                        })
                }</span>
        }
}

// applyFloatConstraints applies float validation constraints to the schema
func applyFloatConstraints(constraints *validate.FieldRules, schema *base.Schema) <span class="cov0" title="0">{
        floatConstraints := constraints.GetFloat()
        if floatConstraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Greater than or equal (minimum)
        <span class="cov0" title="0">if floatConstraints.HasGte() </span><span class="cov0" title="0">{
                min := float64(floatConstraints.GetGte())
                schema.Minimum = &amp;min
        }</span>

        // Greater than (exclusive minimum)
        <span class="cov0" title="0">if floatConstraints.HasGt() </span><span class="cov0" title="0">{
                min := float64(floatConstraints.GetGt())
                schema.ExclusiveMinimum = &amp;base.DynamicValue[bool, float64]{B: min}
        }</span>

        // Less than or equal (maximum)
        <span class="cov0" title="0">if floatConstraints.HasLte() </span><span class="cov0" title="0">{
                max := float64(floatConstraints.GetLte())
                schema.Maximum = &amp;max
        }</span>

        // Less than (exclusive maximum)
        <span class="cov0" title="0">if floatConstraints.HasLt() </span><span class="cov0" title="0">{
                max := float64(floatConstraints.GetLt())
                schema.ExclusiveMaximum = &amp;base.DynamicValue[bool, float64]{B: max}
        }</span>

        // Const value
        <span class="cov0" title="0">if floatConstraints.HasConst() </span><span class="cov0" title="0">{
                schema.Const = &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: fmt.Sprintf("%g", floatConstraints.GetConst()),
                }
        }</span>

        // Enum values (in constraint)
        <span class="cov0" title="0">if len(floatConstraints.In) &gt; 0 </span><span class="cov0" title="0">{
                schema.Enum = make([]*yaml.Node, 0, len(floatConstraints.In))
                for _, value := range floatConstraints.In </span><span class="cov0" title="0">{
                        schema.Enum = append(schema.Enum, &amp;yaml.Node{
                                Kind:  yaml.ScalarNode,
                                Value: fmt.Sprintf("%g", value),
                        })
                }</span>
        }
}

// applyDoubleConstraints applies double validation constraints to the schema
func applyDoubleConstraints(constraints *validate.FieldRules, schema *base.Schema) <span class="cov0" title="0">{
        doubleConstraints := constraints.GetDouble()
        if doubleConstraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Greater than or equal (minimum)
        <span class="cov0" title="0">if doubleConstraints.HasGte() </span><span class="cov0" title="0">{
                min := doubleConstraints.GetGte()
                schema.Minimum = &amp;min
        }</span>

        // Greater than (exclusive minimum)
        <span class="cov0" title="0">if doubleConstraints.HasGt() </span><span class="cov0" title="0">{
                min := doubleConstraints.GetGt()
                schema.ExclusiveMinimum = &amp;base.DynamicValue[bool, float64]{B: min}
        }</span>

        // Less than or equal (maximum)
        <span class="cov0" title="0">if doubleConstraints.HasLte() </span><span class="cov0" title="0">{
                max := doubleConstraints.GetLte()
                schema.Maximum = &amp;max
        }</span>

        // Less than (exclusive maximum)
        <span class="cov0" title="0">if doubleConstraints.HasLt() </span><span class="cov0" title="0">{
                max := doubleConstraints.GetLt()
                schema.ExclusiveMaximum = &amp;base.DynamicValue[bool, float64]{B: max}
        }</span>

        // Const value
        <span class="cov0" title="0">if doubleConstraints.HasConst() </span><span class="cov0" title="0">{
                schema.Const = &amp;yaml.Node{
                        Kind:  yaml.ScalarNode,
                        Value: fmt.Sprintf("%g", doubleConstraints.GetConst()),
                }
        }</span>

        // Enum values (in constraint)
        <span class="cov0" title="0">if len(doubleConstraints.In) &gt; 0 </span><span class="cov0" title="0">{
                schema.Enum = make([]*yaml.Node, 0, len(doubleConstraints.In))
                for _, value := range doubleConstraints.In </span><span class="cov0" title="0">{
                        schema.Enum = append(schema.Enum, &amp;yaml.Node{
                                Kind:  yaml.ScalarNode,
                                Value: fmt.Sprintf("%g", value),
                        })
                }</span>
        }
}

// applyRepeatedConstraints applies repeated field validation constraints to the schema
func applyRepeatedConstraints(constraints *validate.FieldRules, schema *base.Schema) <span class="cov0" title="0">{
        repeatedConstraints := constraints.GetRepeated()
        if repeatedConstraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Min items
        <span class="cov0" title="0">if repeatedConstraints.HasMinItems() </span><span class="cov0" title="0">{
                minItems := int64(repeatedConstraints.GetMinItems())
                schema.MinItems = &amp;minItems
        }</span>

        // Max items
        <span class="cov0" title="0">if repeatedConstraints.HasMaxItems() </span><span class="cov0" title="0">{
                maxItems := int64(repeatedConstraints.GetMaxItems())
                schema.MaxItems = &amp;maxItems
        }</span>

        // Unique items
        <span class="cov0" title="0">if repeatedConstraints.GetUnique() </span><span class="cov0" title="0">{
                uniqueItems := true
                schema.UniqueItems = &amp;uniqueItems
        }</span>
}

// applyMapConstraints applies map field validation constraints to the schema
func applyMapConstraints(constraints *validate.FieldRules, schema *base.Schema) <span class="cov0" title="0">{
        mapConstraints := constraints.GetMap()
        if mapConstraints == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Min pairs (minProperties)
        <span class="cov0" title="0">if mapConstraints.HasMinPairs() </span><span class="cov0" title="0">{
                minProps := int64(mapConstraints.GetMinPairs())
                schema.MinProperties = &amp;minProps
        }</span>

        // Max pairs (maxProperties)
        <span class="cov0" title="0">if mapConstraints.HasMaxPairs() </span><span class="cov0" title="0">{
                maxProps := int64(mapConstraints.GetMaxPairs())
                schema.MaxProperties = &amp;maxProps
        }</span>
}

// checkIfFieldRequired checks if a field has the required constraint
func checkIfFieldRequired(field *protogen.Field) bool <span class="cov0" title="0">{
        // Get the field descriptor options
        fieldOptions := field.Desc.Options()
        if fieldOptions == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Extract the buf.validate field extension
        <span class="cov0" title="0">ext := proto.GetExtension(fieldOptions, validate.E_Field)
        if ext == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Type assert to FieldRules
        <span class="cov0" title="0">fieldConstraints, ok := ext.(*validate.FieldRules)
        if !ok || fieldConstraints == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return fieldConstraints.GetRequired()</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
