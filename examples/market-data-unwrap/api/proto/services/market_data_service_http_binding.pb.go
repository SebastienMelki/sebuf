// Code generated by protoc-gen-go-http. DO NOT EDIT.
// source: proto/services/market_data_service.proto

package services

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"strings"
	"sync"
	"time"
	"unicode/utf8"

	protovalidate "buf.build/go/protovalidate"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"

	sebufhttp "github.com/SebastienMelki/sebuf/http"
)

const (
	// JSONContentType is the content type for JSON
	JSONContentType = "application/json"
	// BinaryContentType is the content type for binary protobuf
	BinaryContentType = "application/octet-stream"
	// ProtoContentType is the content type for protobuf
	ProtoContentType = "application/x-protobuf"
)

type bodyCtxKey struct{}

// PathParamConfig defines configuration for a path parameter.
type PathParamConfig struct {
	URLParam  string // Parameter name in URL path
	FieldName string // Proto field name to bind to
}

// QueryParamConfig defines configuration for a query parameter.
type QueryParamConfig struct {
	QueryName string // Parameter name in query string
	FieldName string // Proto field name to bind to
	Required  bool   // Whether this parameter is required
}

func getRequest[Req any](ctx context.Context) Req {
	val := ctx.Value(bodyCtxKey{})
	request, ok := val.(Req)
	if ok {
		return request
	}
	return *new(Req)
}

// BindingMiddleware creates a middleware that binds HTTP requests to protobuf messages
// and validates them using protovalidate and header validation.
// It supports path parameters, query parameters, and request body binding.
func BindingMiddleware[Req any](next http.Handler, serviceHeaders, methodHeaders []*sebufhttp.Header,
	pathParams []PathParamConfig, queryParams []QueryParamConfig, httpMethod string, errorHandler ErrorHandler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Validate headers first
		if validationErr := validateHeaders(r, serviceHeaders, methodHeaders); validationErr != nil {
			writeErrorWithHandler(w, r, validationErr, errorHandler)
			return
		}

		toBind := new(Req)

		// Bind path parameters
		if msg, ok := any(toBind).(proto.Message); ok {
			if err := bindPathParams(r, msg, pathParams); err != nil {
				writeErrorWithHandler(w, r, err, errorHandler)
				return
			}

			// Bind query parameters
			if err := bindQueryParams(r, msg, queryParams); err != nil {
				writeErrorWithHandler(w, r, err, errorHandler)
				return
			}
		}

		// Bind body only for POST, PUT, PATCH methods
		if httpMethod == "POST" || httpMethod == "PUT" || httpMethod == "PATCH" {
			err := bindDataBasedOnContentType(r, toBind)
			if err != nil {
				// For binding errors, return a simple validation error
				validationErr := &sebufhttp.ValidationError{
					Violations: []*sebufhttp.FieldViolation{
						{
							Field:       "body",
							Description: fmt.Sprintf("failed to parse request body: %v", err),
						},
					},
				}
				writeErrorWithHandler(w, r, validationErr, errorHandler)
				return
			}
		}

		// Validate the complete message
		if msg, ok := any(toBind).(proto.Message); ok {
			if err := ValidateMessage(msg); err != nil {
				writeErrorWithHandler(w, r, convertProtovalidateError(err), errorHandler)
				return
			}
		}

		ctx := context.WithValue(r.Context(), bodyCtxKey{}, toBind)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

func filterFlags(content string) string {
	for i, char := range content {
		if char == ' ' || char == ';' {
			return content[:i]
		}
	}
	return content
}

func bindDataBasedOnContentType[Req any](r *http.Request, toBind *Req) error {
	contentType := filterFlags(r.Header.Get("Content-Type"))
	switch contentType {
	case JSONContentType:
		return bindDataFromJSONRequest(r, toBind)
	case BinaryContentType, ProtoContentType:
		return bindDataFromBinaryRequest(r, toBind)
	default:
		return bindDataFromBinaryRequest(r, toBind)
	}
}

func bindDataFromJSONRequest[Req any](r *http.Request, toBind *Req) error {
	bodyBytes, err := io.ReadAll(r.Body)
	r.Body = io.NopCloser(bytes.NewReader(bodyBytes))
	if err != nil {
		return fmt.Errorf("could not read request body: %w", err)
	}

	if len(bodyBytes) == 0 {
		return nil
	}

	// Check for custom JSON unmarshaler (unwrap support)
	if unmarshaler, ok := any(toBind).(json.Unmarshaler); ok {
		return unmarshaler.UnmarshalJSON(bodyBytes)
	}

	protoRequest, ok := any(toBind).(proto.Message)
	if !ok {
		return errors.New("JSON request is not a protocol buffer message")
	}

	err = protojson.Unmarshal(bodyBytes, protoRequest)
	if err != nil {
		return fmt.Errorf("could not unmarshal request JSON: %w", err)
	}
	return nil
}

func bindDataFromBinaryRequest[Req any](r *http.Request, toBind *Req) error {
	bodyBytes, err := io.ReadAll(r.Body)
	r.Body = io.NopCloser(bytes.NewReader(bodyBytes))

	if len(bodyBytes) == 0 {
		return nil
	}

	if err != nil && !errors.Is(err, io.ErrUnexpectedEOF) {
		return fmt.Errorf("could not read request body: %w", err)
	}

	protoRequest, ok := any(toBind).(proto.Message)
	if !ok {
		return errors.New("binary request is not a protocol buffer message")
	}

	err = proto.Unmarshal(bodyBytes, protoRequest)
	if err != nil {
		return fmt.Errorf("could not unmarshal binary request: %w", err)
	}
	return nil
}

// bindPathParams binds URL path parameters to proto message fields using Go 1.22+ PathValue.
func bindPathParams(r *http.Request, msg proto.Message, params []PathParamConfig) *sebufhttp.ValidationError {
	if len(params) == 0 {
		return nil
	}

	reflectMsg := msg.ProtoReflect()
	fields := reflectMsg.Descriptor().Fields()

	for _, param := range params {
		value := r.PathValue(param.URLParam)
		if value == "" {
			return &sebufhttp.ValidationError{
				Violations: []*sebufhttp.FieldViolation{{
					Field:       param.FieldName,
					Description: fmt.Sprintf("missing required path parameter: %s", param.URLParam),
				}},
			}
		}

		field := fields.ByName(protoreflect.Name(param.FieldName))
		if field == nil {
			continue // Field not found, skip
		}

		convertedValue, err := convertStringToFieldValue(value, field.Kind())
		if err != nil {
			return &sebufhttp.ValidationError{
				Violations: []*sebufhttp.FieldViolation{{
					Field:       param.FieldName,
					Description: fmt.Sprintf("invalid value for path parameter %s: %v", param.URLParam, err),
				}},
			}
		}

		reflectMsg.Set(field, convertedValue)
	}

	return nil
}

// bindQueryParams binds URL query parameters to proto message fields.
func bindQueryParams(r *http.Request, msg proto.Message, params []QueryParamConfig) *sebufhttp.ValidationError {
	if len(params) == 0 {
		return nil
	}

	query := r.URL.Query()
	reflectMsg := msg.ProtoReflect()
	fields := reflectMsg.Descriptor().Fields()

	for _, param := range params {
		values := query[param.QueryName]
		if len(values) == 0 {
			if param.Required {
				return &sebufhttp.ValidationError{
					Violations: []*sebufhttp.FieldViolation{{
						Field:       param.FieldName,
						Description: fmt.Sprintf("missing required query parameter: %s", param.QueryName),
					}},
				}
			}
			continue
		}

		field := fields.ByName(protoreflect.Name(param.FieldName))
		if field == nil {
			continue // Field not found, skip
		}

		// Handle repeated fields (arrays)
		if field.IsList() {
			list := reflectMsg.Mutable(field).List()
			for _, v := range values {
				converted, err := convertStringToFieldValue(v, field.Kind())
				if err != nil {
					return &sebufhttp.ValidationError{
						Violations: []*sebufhttp.FieldViolation{{
							Field:       param.FieldName,
							Description: fmt.Sprintf("invalid value for query parameter %s: %v", param.QueryName, err),
						}},
					}
				}
				list.Append(converted)
			}
		} else {
			converted, err := convertStringToFieldValue(values[0], field.Kind())
			if err != nil {
				return &sebufhttp.ValidationError{
					Violations: []*sebufhttp.FieldViolation{{
						Field:       param.FieldName,
						Description: fmt.Sprintf("invalid value for query parameter %s: %v", param.QueryName, err),
					}},
				}
			}
			reflectMsg.Set(field, converted)
		}
	}

	return nil
}

// convertStringToFieldValue converts a string value to the appropriate protoreflect.Value.
func convertStringToFieldValue(value string, kind protoreflect.Kind) (protoreflect.Value, error) {
	switch kind {
	case protoreflect.StringKind:
		return protoreflect.ValueOfString(value), nil
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		v, err := strconv.ParseInt(value, 10, 32)
		if err != nil {
			return protoreflect.Value{}, err
		}
		return protoreflect.ValueOfInt32(int32(v)), nil
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		v, err := strconv.ParseInt(value, 10, 64)
		if err != nil {
			return protoreflect.Value{}, err
		}
		return protoreflect.ValueOfInt64(v), nil
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		v, err := strconv.ParseUint(value, 10, 32)
		if err != nil {
			return protoreflect.Value{}, err
		}
		return protoreflect.ValueOfUint32(uint32(v)), nil
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		v, err := strconv.ParseUint(value, 10, 64)
		if err != nil {
			return protoreflect.Value{}, err
		}
		return protoreflect.ValueOfUint64(v), nil
	case protoreflect.BoolKind:
		v, err := strconv.ParseBool(value)
		if err != nil {
			return protoreflect.Value{}, err
		}
		return protoreflect.ValueOfBool(v), nil
	case protoreflect.FloatKind:
		v, err := strconv.ParseFloat(value, 32)
		if err != nil {
			return protoreflect.Value{}, err
		}
		return protoreflect.ValueOfFloat32(float32(v)), nil
	case protoreflect.DoubleKind:
		v, err := strconv.ParseFloat(value, 64)
		if err != nil {
			return protoreflect.Value{}, err
		}
		return protoreflect.ValueOfFloat64(v), nil
	default:
		return protoreflect.Value{}, fmt.Errorf("unsupported field type: %v", kind)
	}
}

func genericHandler[Req any, Res any](serve func(context.Context, Req) (Res, error), errorHandler ErrorHandler) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		request := getRequest[Req](r.Context())

		response, err := serve(r.Context(), request)
		if err != nil {
			// Check if error is already a proto.Message (e.g., custom proto error types)
			// If so, pass it directly - defaultErrorResponse will preserve its structure
			if _, ok := err.(proto.Message); ok {
				writeErrorWithHandler(w, r, err, errorHandler)
				return
			}
			errorMsg := &sebufhttp.Error{
				Message: err.Error(),
			}
			writeErrorWithHandler(w, r, errorMsg, errorHandler)
			return
		}

		responseBytes, err := marshalResponse(r, response)
		if err != nil {
			errorMsg := &sebufhttp.Error{
				Message: fmt.Sprintf("failed to marshal response: %v", err),
			}
			writeErrorWithHandler(w, r, errorMsg, errorHandler)
			return
		}

		_, err = w.Write(responseBytes)
		if err != nil {
			errorMsg := &sebufhttp.Error{
				Message: fmt.Sprintf("failed to write response: %v", err),
			}
			writeErrorWithHandler(w, r, errorMsg, errorHandler)
			return
		}
	}
}

func marshalResponse(r *http.Request, response any) ([]byte, error) {
	contentType := r.Header.Get("Content-Type")
	if contentType == "" {
		contentType = JSONContentType
	}

	msg, ok := response.(proto.Message)
	if !ok {
		return nil, fmt.Errorf("response is not a protocol buffer message")
	}

	switch filterFlags(contentType) {
	case JSONContentType:
		// Check for custom JSON marshaler (unwrap support)
		if marshaler, ok := response.(json.Marshaler); ok {
			return marshaler.MarshalJSON()
		}
		return protojson.Marshal(msg)
	case BinaryContentType, ProtoContentType:
		return proto.Marshal(msg)
	default:
		return nil, fmt.Errorf("unsupported content type: %s", contentType)
	}
}

// responseCapture wraps ResponseWriter to track if Write or WriteHeader was called
type responseCapture struct {
	http.ResponseWriter
	wroteHeader bool
	written     bool
}

func (rc *responseCapture) WriteHeader(code int) {
	rc.wroteHeader = true
	rc.ResponseWriter.WriteHeader(code)
}

func (rc *responseCapture) Write(b []byte) (int, error) {
	rc.written = true
	return rc.ResponseWriter.Write(b)
}

// writeProtoMessageResponse writes a protobuf message as an HTTP response
func writeProtoMessageResponse(w http.ResponseWriter, r *http.Request, msg proto.Message, statusCode int, fallbackMsg string) {
	contentType := r.Header.Get("Content-Type")
	if contentType == "" {
		contentType = JSONContentType
	}

	var responseBytes []byte
	var err error

	switch filterFlags(contentType) {
	case JSONContentType:
		responseBytes, err = protojson.Marshal(msg)
	case BinaryContentType, ProtoContentType:
		responseBytes, err = proto.Marshal(msg)
	default:
		// Default to JSON for error responses
		responseBytes, err = protojson.Marshal(msg)
	}

	if err != nil {
		// Fallback to plain text error if marshaling fails
		http.Error(w, fallbackMsg, statusCode)
		return
	}

	w.WriteHeader(statusCode)
	_, _ = w.Write(responseBytes)
}

// writeValidationErrorResponse writes a ValidationError as a response
func writeValidationErrorResponse(w http.ResponseWriter, r *http.Request, validationErr *sebufhttp.ValidationError) {
	writeProtoMessageResponse(w, r, validationErr, http.StatusBadRequest, "validation failed")
}

// writeValidationError converts a protovalidate error to ValidationError and writes it as response
func writeValidationError(w http.ResponseWriter, r *http.Request, err error) {
	validationErr := convertProtovalidateError(err)
	writeValidationErrorResponse(w, r, validationErr)
}

// writeErrorResponse writes an Error as a response
func writeErrorResponse(w http.ResponseWriter, r *http.Request, errorMsg *sebufhttp.Error) {
	writeProtoMessageResponse(w, r, errorMsg, http.StatusInternalServerError, "internal server error")
}

// convertProtovalidateError converts a protovalidate error to ValidationError
func convertProtovalidateError(err error) *sebufhttp.ValidationError {
	validationErr := &sebufhttp.ValidationError{}

	// Handle protovalidate.ValidationError
	var valErr *protovalidate.ValidationError
	if errors.As(err, &valErr) {
		for _, violation := range valErr.Violations {
			// Extract field path from violation
			fieldPath := ""
			if violation.Proto != nil && violation.Proto.GetField() != nil {
				elements := violation.Proto.GetField().GetElements()
				if len(elements) > 0 {
					fieldPath = elements[0].GetFieldName()
					for i := 1; i < len(elements); i++ {
						fieldPath += "." + elements[i].GetFieldName()
					}
				}
			}
			if fieldPath == "" {
				fieldPath = "unknown"
			}

			validationErr.Violations = append(validationErr.Violations, &sebufhttp.FieldViolation{
				Field:       fieldPath,
				Description: violation.Proto.GetMessage(),
			})
		}
	} else {
		// Shouldn't happen, but handle as generic error
		validationErr.Violations = append(validationErr.Violations, &sebufhttp.FieldViolation{
			Field:       "unknown",
			Description: err.Error(),
		})
	}

	return validationErr
}

// defaultErrorResponse returns the appropriate error response message based on error type
func defaultErrorResponse(err error) proto.Message {
	var valErr *sebufhttp.ValidationError
	if errors.As(err, &valErr) {
		return valErr
	}
	var handlerErr *sebufhttp.Error
	if errors.As(err, &handlerErr) {
		return handlerErr
	}
	// Check if error is already a proto.Message (e.g., custom proto error types)
	if protoErr, ok := err.(proto.Message); ok {
		return protoErr
	}
	return &sebufhttp.Error{Message: err.Error()}
}

// defaultErrorStatusCode returns the appropriate HTTP status code based on error type
func defaultErrorStatusCode(err error) int {
	var valErr *sebufhttp.ValidationError
	if errors.As(err, &valErr) {
		return http.StatusBadRequest
	}
	return http.StatusInternalServerError
}

// writeErrorWithHandler calls custom handler if set, then marshals response
func writeErrorWithHandler(w http.ResponseWriter, r *http.Request, err error, handler ErrorHandler) {
	var response proto.Message
	var capture *responseCapture

	if handler != nil {
		capture = &responseCapture{ResponseWriter: w}
		response = handler(capture, r, err)
		if capture.written {
			return // Handler wrote directly, done
		}
	}

	// Determine response if handler didn't provide one
	if response == nil {
		response = defaultErrorResponse(err)
	}

	// Determine status code
	statusCode := defaultErrorStatusCode(err)

	// If handler already set status, don't set it again
	if capture != nil && capture.wroteHeader {
		// Handler set status, just write the body
		writeResponseBody(w, r, response)
		return
	}

	// Write full response with status code
	writeProtoMessageResponse(w, r, response, statusCode, "error processing request")
}

// writeResponseBody writes the response body without setting status code
func writeResponseBody(w http.ResponseWriter, r *http.Request, msg proto.Message) {
	contentType := r.Header.Get("Content-Type")
	if contentType == "" {
		contentType = JSONContentType
	}

	var responseBytes []byte
	var err error

	switch filterFlags(contentType) {
	case JSONContentType:
		responseBytes, err = protojson.Marshal(msg)
	case BinaryContentType, ProtoContentType:
		responseBytes, err = proto.Marshal(msg)
	default:
		responseBytes, err = protojson.Marshal(msg)
	}

	if err != nil {
		return // Can't write anything meaningful
	}

	_, _ = w.Write(responseBytes)
}

var (
	// Global validator instance - created once and reused
	validatorOnce sync.Once
	validator     protovalidate.Validator
	validatorErr  error
)

// getValidator returns a cached validator instance
func getValidator() (protovalidate.Validator, error) {
	validatorOnce.Do(func() {
		validator, validatorErr = protovalidate.New()
	})
	return validator, validatorErr
}

// ValidateMessage validates a protobuf message using protovalidate
func ValidateMessage(msg proto.Message) error {
	// Get cached validator
	v, err := getValidator()
	if err != nil {
		// If we can't create a validator, log and continue
		// This allows the service to run even if validation setup fails
		return nil
	}

	// Validate the message and return any error
	return v.Validate(msg)
}

// validateHeaders validates required headers for a service and method
// Returns a ValidationError if any required headers are missing or invalid
func validateHeaders(r *http.Request, serviceHeaders, methodHeaders []*sebufhttp.Header) *sebufhttp.ValidationError {
	// Merge service and method headers, with method headers taking precedence
	allHeaders := make(map[string]*sebufhttp.Header)

	// Add service headers first
	for _, header := range serviceHeaders {
		if header.GetRequired() {
			allHeaders[strings.ToLower(header.GetName())] = header
		}
	}

	// Add method headers (override service headers if same name)
	for _, header := range methodHeaders {
		if header.GetRequired() {
			allHeaders[strings.ToLower(header.GetName())] = header
		}
	}

	// Collect all validation violations
	var violations []*sebufhttp.FieldViolation

	// Validate each required header
	for _, headerSpec := range allHeaders {
		value := r.Header.Get(headerSpec.GetName())
		if value == "" {
			violations = append(violations, &sebufhttp.FieldViolation{
				Field:       headerSpec.GetName(),
				Description: fmt.Sprintf("required header '%s' is missing", headerSpec.GetName()),
			})
			continue
		}

		if err := validateHeaderValue(headerSpec, value); err != nil {
			violations = append(violations, &sebufhttp.FieldViolation{
				Field:       headerSpec.GetName(),
				Description: fmt.Sprintf("header '%s' validation failed: %v", headerSpec.GetName(), err),
			})
		}
	}

	// Return ValidationError if there are violations
	if len(violations) > 0 {
		return &sebufhttp.ValidationError{
			Violations: violations,
		}
	}

	return nil
}

// validateHeaderValue validates a single header value against its specification
func validateHeaderValue(headerSpec *sebufhttp.Header, value string) error {
	headerType := headerSpec.GetType()
	format := headerSpec.GetFormat()

	// Validate based on type
	switch headerType {
	case "string":
		return validateStringHeader(value, format)
	case "integer":
		return validateIntegerHeader(value)
	case "number":
		return validateNumberHeader(value)
	case "boolean":
		return validateBooleanHeader(value)
	case "array":
		return validateArrayHeader(value)
	default:
		// Default to string validation if type is not specified
		return validateStringHeader(value, format)
	}
}

// validateStringHeader validates string headers with optional format validation
func validateStringHeader(value, format string) error {
	if !utf8.ValidString(value) {
		return fmt.Errorf("value is not valid UTF-8")
	}

	// Apply format-specific validation
	switch format {
	case "uuid":
		return validateUUIDFormat(value)
	case "email":
		return validateEmailFormat(value)
	case "date-time":
		return validateDateTimeFormat(value)
	case "date":
		return validateDateFormat(value)
	case "time":
		return validateTimeFormat(value)
	}

	return nil
}

// validateIntegerHeader validates integer headers
func validateIntegerHeader(value string) error {
	_, err := strconv.ParseInt(value, 10, 64)
	if err != nil {
		return fmt.Errorf("value is not a valid integer: %w", err)
	}
	return nil
}

// validateNumberHeader validates numeric headers (float)
func validateNumberHeader(value string) error {
	_, err := strconv.ParseFloat(value, 64)
	if err != nil {
		return fmt.Errorf("value is not a valid number: %w", err)
	}
	return nil
}

// validateBooleanHeader validates boolean headers
func validateBooleanHeader(value string) error {
	_, err := strconv.ParseBool(value)
	if err != nil {
		return fmt.Errorf("value is not a valid boolean: %w", err)
	}
	return nil
}

// validateArrayHeader validates array headers (comma-separated values)
func validateArrayHeader(value string) error {
	// Arrays are typically comma-separated values
	// Basic validation: ensure it's not empty
	if strings.TrimSpace(value) == "" {
		return fmt.Errorf("array value cannot be empty")
	}
	return nil
}

// validateUUIDFormat validates UUID format (basic check)
func validateUUIDFormat(value string) error {
	// Basic UUID format check: 8-4-4-4-12 hex digits
	if len(value) != 36 {
		return fmt.Errorf("UUID must be 36 characters long")
	}

	// Check for correct dash positions
	if value[8] != '-' || value[13] != '-' || value[18] != '-' || value[23] != '-' {
		return fmt.Errorf("invalid UUID format")
	}

	return nil
}

// validateEmailFormat validates email format (basic check)
func validateEmailFormat(value string) error {
	// Basic email format check
	if !strings.Contains(value, "@") {
		return fmt.Errorf("invalid email format: missing @")
	}

	parts := strings.Split(value, "@")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		return fmt.Errorf("invalid email format")
	}

	return nil
}

// validateDateTimeFormat validates RFC3339 date-time format
func validateDateTimeFormat(value string) error {
	_, err := time.Parse(time.RFC3339, value)
	if err != nil {
		return fmt.Errorf("invalid date-time format, expected RFC3339: %w", err)
	}
	return nil
}

// validateDateFormat validates date format (YYYY-MM-DD)
func validateDateFormat(value string) error {
	_, err := time.Parse("2006-01-02", value)
	if err != nil {
		return fmt.Errorf("invalid date format, expected YYYY-MM-DD: %w", err)
	}
	return nil
}

// validateTimeFormat validates time format (HH:MM:SS)
func validateTimeFormat(value string) error {
	_, err := time.Parse("15:04:05", value)
	if err != nil {
		return fmt.Errorf("invalid time format, expected HH:MM:SS: %w", err)
	}
	return nil
}
