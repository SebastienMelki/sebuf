package main

import (
	"context"
	"fmt"
	"github.com/SebastienMelki/sebuf/examples/simple-api/api/proto/models"
	"github.com/SebastienMelki/sebuf/examples/simple-api/api/proto/services"
	"log"
	"net/http"
	"time"
)

// Note: Uncomment and use after running 'buf generate'

type UserService struct {
	users  map[string]*models.User
	nextID int
}

func NewUserService() *UserService {
	return &UserService{
		users:  make(map[string]*models.User),
		nextID: 1,
	}
}

func (s *UserService) CreateUser(ctx context.Context, req *models.CreateUserRequest) (*models.User, error) {
	user := &models.User{
		Id:        fmt.Sprintf("user-%d", s.nextID),
		Name:      req.Name,
		Email:     req.Email,
		CreatedAt: time.Now().Unix(),
	}
	s.nextID++
	s.users[user.Id] = user
	return user, nil
}

func (s *UserService) GetUser(ctx context.Context, req *models.GetUserRequest) (*models.User, error) {
	user, exists := s.users[req.Id]
	if !exists {
		return nil, fmt.Errorf("user not found: %s", req.Id)
	}
	return user, nil
}

func (s *UserService) Login(ctx context.Context, req *models.LoginRequest) (*models.LoginResponse, error) {
	var userEmail string

	// Handle different authentication methods using the oneof field
	switch auth := req.AuthMethod.(type) {
	case *models.LoginRequest_Email:
		// Email authentication
		userEmail = auth.Email.Email
		// In production, verify password hash
		log.Printf("Email login: %s", auth.Email.Email)

	case *models.LoginRequest_Token:
		// Token authentication
		log.Printf("Token login: %s", auth.Token.Token)
		userEmail = "user@fromtoken.com" // In production, decode token

	case *models.LoginRequest_Social:
		// Social authentication
		log.Printf("Social login via %s", auth.Social.Provider)
		userEmail = "user@social.com" // In production, validate with provider

	default:
		return nil, fmt.Errorf("unknown authentication method")
	}

	// Find or create user
	var user *models.User
	for _, u := range s.users {
		if u.Email == userEmail {
			user = u
			break
		}
	}

	if user == nil {
		// Create new user for demo
		user = &models.User{
			Id:        fmt.Sprintf("user-%d", s.nextID),
			Name:      "Demo User",
			Email:     userEmail,
			CreatedAt: time.Now().Unix(),
		}
		s.nextID++
		s.users[user.Id] = user
	}

	return &models.LoginResponse{
		AccessToken:  fmt.Sprintf("token_%s_%d", user.Id, time.Now().Unix()),
		RefreshToken: fmt.Sprintf("refresh_%s_%d", user.Id, time.Now().Unix()),
		ExpiresIn:    3600,
		User:         user,
	}, nil
}

func main() {
	service := services.NewMockUserServiceServer()
	mux := http.NewServeMux()

	// Register the HTTP handlers (generated by protoc-gen-go-http)
	if err := services.RegisterUserServiceServer(service, services.WithMux(mux)); err != nil {
		log.Fatal(err)
	}

	fmt.Println("Server starting on :8080")
	fmt.Println("Endpoints:")
	fmt.Println("  POST /api/v1/users       - Create user")
	fmt.Println("  POST /api/v1/users/get   - Get user")
	fmt.Println("  POST /api/v1/auth/login  - Login")
	fmt.Println("")
	fmt.Println("Example requests:")
	fmt.Println("")
	fmt.Println("Create user:")
	fmt.Println("  curl -X POST http://localhost:8080/api/v1/users \\")
	fmt.Println("    -H 'Content-Type: application/json' \\")
	fmt.Println("    -d '{\"name\": \"John Doe\", \"email\": \"john@example.com\"}'")
	fmt.Println("")
	fmt.Println("Login with email:")
	fmt.Println("  curl -X POST http://localhost:8080/api/v1/auth/login \\")
	fmt.Println("    -H 'Content-Type: application/json' \\")
	fmt.Println("    -d '{\"email\": {\"email\": \"john@example.com\", \"password\": \"secret\"}}'")
	fmt.Println("")
	fmt.Println("In Go code, you can construct the request manually:")
	fmt.Println("  loginReq := &models.LoginRequest{AuthMethod: &models.LoginRequest_Email{Email: &models.LoginRequest_EmailAuth{Email: \"john@example.com\", Password: \"secret\"}}}")

	log.Fatal(http.ListenAndServe(":8080", mux))
}
