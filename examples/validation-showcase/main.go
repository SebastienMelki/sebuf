package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"strings"
	"time"

	"github.com/SebastienMelki/sebuf/examples/validation-showcase/api/proto/models"
	"github.com/SebastienMelki/sebuf/examples/validation-showcase/api/proto/services"
)

// OrderService implements the OrderServiceServer interface.
type OrderService struct {
	orders   map[string]*models.Order
	orderNum int
}

// NewOrderService creates a new OrderService.
func NewOrderService() *OrderService {
	return &OrderService{
		orders:   make(map[string]*models.Order),
		orderNum: 1,
	}
}

// CreateOrder creates a new order with full validation.
func (s *OrderService) CreateOrder(ctx context.Context, req *models.CreateOrderRequest) (*models.Order, error) {
	// Calculate totals from items
	var subtotal float64
	for _, item := range req.Items {
		itemTotal := float64(item.Quantity) * item.UnitPrice
		discount := itemTotal * float64(item.DiscountPercent) / 100
		subtotal += itemTotal - discount
	}

	// Apply coupons
	discountAmount := 0.0
	for _, code := range req.CouponCodes {
		if strings.HasPrefix(code, "SAVE") {
			// Percentage discount
			discountAmount += subtotal * 0.10 // 10% off
		} else if code == "FREESHIP" {
			// Free shipping handled separately
		}
	}

	// Calculate tax and shipping
	taxAmount := subtotal * 0.0875 // 8.75% tax
	shippingCost := 9.99
	for _, code := range req.CouponCodes {
		if code == "FREESHIP" {
			shippingCost = 0
		}
	}

	total := subtotal - discountAmount + taxAmount + shippingCost

	order := &models.Order{
		Id:                  fmt.Sprintf("550e8400-e29b-41d4-a716-44665544%04d", s.orderNum),
		OrderNumber:         fmt.Sprintf("ORD-2024%08d", s.orderNum),
		Contact:             req.Contact,
		ShippingAddress:     req.ShippingAddress,
		BillingAddress:      req.BillingAddress,
		Items:               req.Items,
		CouponCodes:         req.CouponCodes,
		Metadata:            req.Metadata,
		Subtotal:            subtotal,
		DiscountAmount:      discountAmount,
		TaxAmount:           taxAmount,
		ShippingCost:        shippingCost,
		Total:               total,
		Status:              models.OrderStatus_ORDER_STATUS_PENDING,
		PaymentMethod:       req.PaymentMethod,
		SpecialInstructions: req.SpecialInstructions,
		CreatedAt:           time.Now().Unix(),
		UpdatedAt:           time.Now().Unix(),
	}

	s.orders[order.Id] = order
	s.orderNum++

	log.Printf("Created order: %s (total: $%.2f)", order.OrderNumber, order.Total)
	return order, nil
}

// GetOrder retrieves an order by ID.
func (s *OrderService) GetOrder(ctx context.Context, req *models.GetOrderRequest) (*models.Order, error) {
	order, exists := s.orders[req.OrderId]
	if !exists {
		return nil, fmt.Errorf("order not found: %s", req.OrderId)
	}
	return order, nil
}

// ValidateAddress validates a shipping address.
func (s *OrderService) ValidateAddress(ctx context.Context, req *models.ValidateAddressRequest) (*models.ValidateAddressResponse, error) {
	// If we reach here, the address passed buf.validate rules
	// In production, you would call an address verification service

	// Normalize the address
	normalized := &models.Address{
		Street:     strings.TrimSpace(req.Address.Street),
		City:       strings.TrimSpace(req.Address.City),
		State:      strings.ToUpper(req.Address.State),
		PostalCode: req.Address.PostalCode,
		Country:    strings.ToUpper(req.Address.Country),
	}

	return &models.ValidateAddressResponse{
		Valid:             true,
		NormalizedAddress: normalized,
		Errors:            nil,
		Suggestions:       nil,
	}, nil
}

// ValidateCoupon validates a coupon code.
func (s *OrderService) ValidateCoupon(ctx context.Context, req *models.CouponValidationRequest) (*models.CouponValidationResponse, error) {
	// Sample coupon validation logic
	validCoupons := map[string]struct {
		discountType   string
		discountAmount float64 // percentage or fixed amount
	}{
		"SAVE10":   {"percentage", 10},
		"SAVE20":   {"percentage", 20},
		"SAVE50":   {"fixed_amount", 50},
		"FREESHIP": {"fixed_amount", 9.99},
	}

	coupon, exists := validCoupons[req.Code]
	if !exists {
		return &models.CouponValidationResponse{
			Valid:        false,
			ErrorMessage: fmt.Sprintf("Coupon code '%s' is not valid or has expired", req.Code),
		}, nil
	}

	var discountAmount float64
	if coupon.discountType == "percentage" {
		discountAmount = req.Subtotal * (coupon.discountAmount / 100)
	} else {
		discountAmount = coupon.discountAmount
	}

	return &models.CouponValidationResponse{
		Valid:          true,
		DiscountAmount: discountAmount,
		DiscountType:   coupon.discountType,
	}, nil
}

func main() {
	// Use our custom service implementation
	service := NewOrderService()
	mux := http.NewServeMux()

	// Register the HTTP handlers (generated by protoc-gen-go-http)
	if err := services.RegisterOrderServiceServer(service, services.WithMux(mux)); err != nil {
		log.Fatal(err)
	}

	fmt.Println("Validation Showcase API Server starting on :8080")
	fmt.Println("")
	fmt.Println("This example demonstrates comprehensive buf.validate validation patterns.")
	fmt.Println("")
	fmt.Println("Validation Patterns Demonstrated:")
	fmt.Println("")
	fmt.Println("  String Validation:")
	fmt.Println("    - min_len/max_len    : Name, description lengths")
	fmt.Println("    - email              : Contact email format")
	fmt.Println("    - uuid               : Product IDs, Order IDs")
	fmt.Println("    - pattern (regex)    : Phone numbers, state codes, postal codes, SKUs")
	fmt.Println("    - in (enum)          : Country codes (US, CA, MX, GB, DE, FR)")
	fmt.Println("")
	fmt.Println("  Numeric Validation:")
	fmt.Println("    - gte/lte            : Quantity (1-100), discount percent (0-100)")
	fmt.Println("    - gt/lt              : Price (> 0, <= 10000)")
	fmt.Println("    - timestamp          : Unix epoch validation")
	fmt.Println("")
	fmt.Println("  Array Validation:")
	fmt.Println("    - min_items/max_items: Order items (1-50)")
	fmt.Println("    - unique             : Coupon codes, tags")
	fmt.Println("    - items validation   : Coupon code pattern on each element")
	fmt.Println("")
	fmt.Println("  Map Validation:")
	fmt.Println("    - max_pairs          : Metadata, product options")
	fmt.Println("    - keys validation    : Key pattern constraints")
	fmt.Println("    - values validation  : Value length constraints")
	fmt.Println("")
	fmt.Println("  Nested Validation:")
	fmt.Println("    - required messages  : Contact, shipping address")
	fmt.Println("    - optional messages  : Billing address")
	fmt.Println("    - recursive          : Address validation within order")
	fmt.Println("")
	fmt.Println("Endpoints:")
	fmt.Println("  POST /api/v1/orders           - Create order (full validation)")
	fmt.Println("  GET  /api/v1/orders/{id}      - Get order (UUID validation)")
	fmt.Println("  POST /api/v1/validate/address - Validate address")
	fmt.Println("  POST /api/v1/validate/coupon  - Validate coupon code")
	fmt.Println("")
	fmt.Println("Test valid requests:      make test")
	fmt.Println("Test validation errors:   make test-validation")
	fmt.Println("")

	log.Fatal(http.ListenAndServe(":8080", mux))
}
