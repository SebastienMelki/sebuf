package openapiv3_test

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

func reportGoldenFileMismatch(t *testing.T, testName, goldenFile string, generatedContent, goldenContent []byte) {
	t.Helper()

	generated := string(generatedContent)
	golden := string(goldenContent)

	t.Errorf("Generated output does not match golden file for %s", testName)
	t.Errorf("Generated file size: %d bytes", len(generatedContent))
	t.Errorf("Golden file size: %d bytes", len(goldenContent))

	reportFirstDifference(t, generated, golden)
	reportLineDifferences(t, generated, golden)
	handleGoldenFileUpdate(t, goldenFile, generatedContent)
	writeTemporaryGeneratedFile(t, goldenFile, generatedContent)
}

func reportFirstDifference(t *testing.T, generated, golden string) {
	t.Helper()

	minLen := len(generated)
	if len(golden) < minLen {
		minLen = len(golden)
	}

	for i := range minLen {
		if generated[i] != golden[i] {
			t.Errorf("First difference at byte position %d", i)
			t.Errorf("Generated byte: %d (%c)", generated[i], generated[i])
			t.Errorf("Golden byte: %d (%c)", golden[i], golden[i])
			return
		}
	}
}

func reportLineDifferences(t *testing.T, generated, golden string) {
	t.Helper()

	generatedLines := strings.Split(generated, "\n")
	goldenLines := strings.Split(golden, "\n")

	maxLines := len(generatedLines)
	if len(goldenLines) > maxLines {
		maxLines = len(goldenLines)
	}

	diffCount := 0
	for i := 0; i < maxLines && diffCount < 10; i++ { // Limit to first 10 differences
		var generatedLine, goldenLine string
		if i < len(generatedLines) {
			generatedLine = generatedLines[i]
		}
		if i < len(goldenLines) {
			goldenLine = goldenLines[i]
		}

		if generatedLine != goldenLine {
			t.Errorf("Line %d differs:", i+1)
			t.Errorf("  Generated: %q", generatedLine)
			t.Errorf("  Golden:    %q", goldenLine)
			diffCount++
		}
	}

	if diffCount >= 10 {
		t.Errorf("... (showing first 10 differences only)")
	}
}

func handleGoldenFileUpdate(t *testing.T, goldenFile string, generatedContent []byte) {
	t.Helper()

	if os.Getenv("UPDATE_GOLDEN") == "1" {
		if writeErr := os.WriteFile(goldenFile, generatedContent, 0o644); writeErr != nil {
			t.Logf("Failed to update golden file: %v", writeErr)
		} else {
			t.Logf("Updated golden file: %s", goldenFile)
		}
	} else {
		t.Log("To update golden files, run: UPDATE_GOLDEN=1 go test -run TestExhaustiveGoldenFiles")
	}
}

func writeTemporaryGeneratedFile(t *testing.T, goldenFile string, generatedContent []byte) {
	t.Helper()

	tempGenFile := goldenFile + ".generated"
	if writeErr := os.WriteFile(tempGenFile, generatedContent, 0o644); writeErr == nil {
		t.Logf("Generated content written to: %s", tempGenFile)
		t.Logf("Compare with: diff %s %s", goldenFile, tempGenFile)
	}
}

// tryCreateGoldenFile attempts to create a golden file if it doesn't exist and UPDATE_GOLDEN is set.
// Returns true if the golden file was created, false otherwise.
func tryCreateGoldenFile(t *testing.T, goldenFile string, generatedContent []byte, readErr error) bool {
	t.Helper()

	if !os.IsNotExist(readErr) || os.Getenv("UPDATE_GOLDEN") != "1" {
		return false
	}

	// Ensure directory exists
	goldenDir := filepath.Dir(goldenFile)
	if mkdirErr := os.MkdirAll(goldenDir, 0o755); mkdirErr != nil {
		t.Fatalf("Failed to create golden directory: %v", mkdirErr)
	}

	if writeErr := os.WriteFile(goldenFile, generatedContent, 0o644); writeErr != nil {
		t.Fatalf("Failed to create golden file: %v", writeErr)
	}

	t.Logf("Created golden file: %s (%d bytes)", goldenFile, len(generatedContent))
	return true
}

// TestExhaustiveGoldenFiles performs exhaustive byte-for-byte comparison
// between generated OpenAPI output and golden files.
func TestExhaustiveGoldenFiles(t *testing.T) {
	// Build the plugin binary for testing
	pluginPath := "./protoc-gen-openapiv3-golden-test"
	buildCmd := exec.Command("go", "build", "-o", pluginPath, "../../cmd/protoc-gen-openapiv3")
	if err := buildCmd.Run(); err != nil {
		t.Fatalf("Failed to build plugin: %v", err)
	}
	defer os.Remove(pluginPath)

	// Test cases mapping proto files to their services and expected golden files
	testCases := []struct {
		name        string
		protoFile   string
		serviceName string
		goldenFile  string
		format      string // "yaml" or "json"
	}{
		// simple_service.proto -> SimpleService
		{
			name:        "simple_service_yaml",
			protoFile:   "testdata/proto/simple_service.proto",
			serviceName: "SimpleService",
			goldenFile:  "testdata/golden/yaml/SimpleService.openapi.yaml",
			format:      "yaml",
		},
		{
			name:        "simple_service_json",
			protoFile:   "testdata/proto/simple_service.proto",
			serviceName: "SimpleService",
			goldenFile:  "testdata/golden/json/SimpleService.openapi.json",
			format:      "json",
		},
		// complex_types.proto -> ComplexService
		{
			name:        "complex_types_yaml",
			protoFile:   "testdata/proto/complex_types.proto",
			serviceName: "ComplexService",
			goldenFile:  "testdata/golden/yaml/ComplexService.openapi.yaml",
			format:      "yaml",
		},
		{
			name:        "complex_types_json",
			protoFile:   "testdata/proto/complex_types.proto",
			serviceName: "ComplexService",
			goldenFile:  "testdata/golden/json/ComplexService.openapi.json",
			format:      "json",
		},
		// nested_messages.proto -> NestedService
		{
			name:        "nested_messages_yaml",
			protoFile:   "testdata/proto/nested_messages.proto",
			serviceName: "NestedService",
			goldenFile:  "testdata/golden/yaml/NestedService.openapi.yaml",
			format:      "yaml",
		},
		{
			name:        "nested_messages_json",
			protoFile:   "testdata/proto/nested_messages.proto",
			serviceName: "NestedService",
			goldenFile:  "testdata/golden/json/NestedService.openapi.json",
			format:      "json",
		},
		// headers.proto -> HeaderService
		{
			name:        "header_service_yaml",
			protoFile:   "testdata/proto/headers.proto",
			serviceName: "HeaderService",
			goldenFile:  "testdata/golden/yaml/HeaderService.openapi.yaml",
			format:      "yaml",
		},
		{
			name:        "header_service_json",
			protoFile:   "testdata/proto/headers.proto",
			serviceName: "HeaderService",
			goldenFile:  "testdata/golden/json/HeaderService.openapi.json",
			format:      "json",
		},
		// headers.proto -> HeaderTypesService
		{
			name:        "header_types_service_yaml",
			protoFile:   "testdata/proto/headers.proto",
			serviceName: "HeaderTypesService",
			goldenFile:  "testdata/golden/yaml/HeaderTypesService.openapi.yaml",
			format:      "yaml",
		},
		{
			name:        "header_types_service_json",
			protoFile:   "testdata/proto/headers.proto",
			serviceName: "HeaderTypesService",
			goldenFile:  "testdata/golden/json/HeaderTypesService.openapi.json",
			format:      "json",
		},
		// headers.proto -> NoHeaderService
		{
			name:        "no_header_service_yaml",
			protoFile:   "testdata/proto/headers.proto",
			serviceName: "NoHeaderService",
			goldenFile:  "testdata/golden/yaml/NoHeaderService.openapi.yaml",
			format:      "yaml",
		},
		{
			name:        "no_header_service_json",
			protoFile:   "testdata/proto/headers.proto",
			serviceName: "NoHeaderService",
			goldenFile:  "testdata/golden/json/NoHeaderService.openapi.json",
			format:      "json",
		},
		// headers.proto -> DeprecatedHeaderService
		{
			name:        "deprecated_header_service_yaml",
			protoFile:   "testdata/proto/headers.proto",
			serviceName: "DeprecatedHeaderService",
			goldenFile:  "testdata/golden/yaml/DeprecatedHeaderService.openapi.yaml",
			format:      "yaml",
		},
		{
			name:        "deprecated_header_service_json",
			protoFile:   "testdata/proto/headers.proto",
			serviceName: "DeprecatedHeaderService",
			goldenFile:  "testdata/golden/json/DeprecatedHeaderService.openapi.json",
			format:      "json",
		},
		// headers.proto -> EdgeCaseService
		{
			name:        "edge_case_service_yaml",
			protoFile:   "testdata/proto/headers.proto",
			serviceName: "EdgeCaseService",
			goldenFile:  "testdata/golden/yaml/EdgeCaseService.openapi.yaml",
			format:      "yaml",
		},
		{
			name:        "edge_case_service_json",
			protoFile:   "testdata/proto/headers.proto",
			serviceName: "EdgeCaseService",
			goldenFile:  "testdata/golden/json/EdgeCaseService.openapi.json",
			format:      "json",
		},
		// multiple_services.proto -> UserService
		{
			name:        "multi_user_service_yaml",
			protoFile:   "testdata/proto/multiple_services.proto",
			serviceName: "UserService",
			goldenFile:  "testdata/golden/yaml/UserService.openapi.yaml",
			format:      "yaml",
		},
		{
			name:        "multi_user_service_json",
			protoFile:   "testdata/proto/multiple_services.proto",
			serviceName: "UserService",
			goldenFile:  "testdata/golden/json/UserService.openapi.json",
			format:      "json",
		},
		// multiple_services.proto -> AdminService
		{
			name:        "multi_admin_service_yaml",
			protoFile:   "testdata/proto/multiple_services.proto",
			serviceName: "AdminService",
			goldenFile:  "testdata/golden/yaml/AdminService.openapi.yaml",
			format:      "yaml",
		},
		{
			name:        "multi_admin_service_json",
			protoFile:   "testdata/proto/multiple_services.proto",
			serviceName: "AdminService",
			goldenFile:  "testdata/golden/json/AdminService.openapi.json",
			format:      "json",
		},
		// multiple_services.proto -> NotificationService
		{
			name:        "notification_service_yaml",
			protoFile:   "testdata/proto/multiple_services.proto",
			serviceName: "NotificationService",
			goldenFile:  "testdata/golden/yaml/NotificationService.openapi.yaml",
			format:      "yaml",
		},
		{
			name:        "notification_service_json",
			protoFile:   "testdata/proto/multiple_services.proto",
			serviceName: "NotificationService",
			goldenFile:  "testdata/golden/json/NotificationService.openapi.json",
			format:      "json",
		},
		// http_annotations.proto -> BasicService
		{
			name:        "basic_service_yaml",
			protoFile:   "testdata/proto/http_annotations.proto",
			serviceName: "BasicService",
			goldenFile:  "testdata/golden/yaml/BasicService.openapi.yaml",
			format:      "yaml",
		},
		{
			name:        "basic_service_json",
			protoFile:   "testdata/proto/http_annotations.proto",
			serviceName: "BasicService",
			goldenFile:  "testdata/golden/json/BasicService.openapi.json",
			format:      "json",
		},
		// http_verbs.proto -> RESTfulUserService (HTTP verbs, path params, query params)
		{
			name:        "restful_user_service_yaml",
			protoFile:   "testdata/proto/http_verbs.proto",
			serviceName: "RESTfulUserService",
			goldenFile:  "testdata/golden/yaml/RESTfulUserService.openapi.yaml",
			format:      "yaml",
		},
		{
			name:        "restful_user_service_json",
			protoFile:   "testdata/proto/http_verbs.proto",
			serviceName: "RESTfulUserService",
			goldenFile:  "testdata/golden/json/RESTfulUserService.openapi.json",
			format:      "json",
		},
		// unwrap.proto -> UnwrapService (unwrap field option for map values)
		{
			name:        "unwrap_service_yaml",
			protoFile:   "testdata/proto/unwrap.proto",
			serviceName: "UnwrapService",
			goldenFile:  "testdata/golden/yaml/UnwrapService.openapi.yaml",
			format:      "yaml",
		},
		{
			name:        "unwrap_service_json",
			protoFile:   "testdata/proto/unwrap.proto",
			serviceName: "UnwrapService",
			goldenFile:  "testdata/golden/json/UnwrapService.openapi.json",
			format:      "json",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Generate fresh output using protoc
			tempDir := t.TempDir()

			// Set format parameter
			formatParam := fmt.Sprintf("format=%s", tc.format)

			// Run protoc to generate new output
			cmd := exec.Command("protoc",
				"--plugin=protoc-gen-openapiv3="+pluginPath,
				"--openapiv3_out="+tempDir,
				"--openapiv3_opt="+formatParam,
				"--proto_path=testdata/proto",
				"--proto_path=../../proto",
				tc.protoFile,
			)

			var stdout, stderr bytes.Buffer
			cmd.Stdout = &stdout
			cmd.Stderr = &stderr

			if runErr := cmd.Run(); runErr != nil {
				t.Fatalf("protoc failed for %s: %v\nStdout: %s\nStderr: %s",
					tc.name, runErr, stdout.String(), stderr.String())
			}

			// The generator creates service-specific files, so look for ServiceName.openapi.ext
			var extension string
			if tc.format == "json" {
				extension = ".openapi.json"
			} else {
				extension = ".openapi.yaml"
			}
			generatedFile := filepath.Join(tempDir, tc.serviceName+extension)

			// Read generated content
			generatedContent, err := os.ReadFile(generatedFile)
			if err != nil {
				t.Fatalf("Failed to read generated file %s: %v", generatedFile, err)
			}

			// Read golden file content
			goldenContent, err := os.ReadFile(tc.goldenFile)
			if err != nil {
				if created := tryCreateGoldenFile(t, tc.goldenFile, generatedContent, err); created {
					return
				}
				t.Fatalf("Failed to read golden file %s: %v", tc.goldenFile, err)
			}

			// Perform exhaustive byte-for-byte comparison
			if !bytes.Equal(generatedContent, goldenContent) {
				reportGoldenFileMismatch(t, tc.name, tc.goldenFile, generatedContent, goldenContent)
			} else {
				t.Logf("âœ“ Perfect match for %s (%d bytes)", tc.name, len(generatedContent))
			}
		})
	}
}

// TestExhaustiveRegression tests that any change to the implementation
// is detected by comparing against multiple golden files.
func TestExhaustiveRegression(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping exhaustive regression test in short mode")
	}

	// Build the plugin
	pluginPath := "./protoc-gen-openapiv3-regression-test"
	buildCmd := exec.Command("go", "build", "-o", pluginPath, "../../cmd/protoc-gen-openapiv3")
	if err := buildCmd.Run(); err != nil {
		t.Fatalf("Failed to build plugin: %v", err)
	}
	defer os.Remove(pluginPath)

	// Mapping of proto files to their services for comprehensive regression testing
	protoToServices := map[string][]string{
		"testdata/proto/simple_service.proto":  {"SimpleService"},
		"testdata/proto/complex_types.proto":   {"ComplexService"},
		"testdata/proto/nested_messages.proto": {"NestedService"},
		"testdata/proto/headers.proto": {
			"HeaderService",
			"HeaderTypesService",
			"NoHeaderService",
			"DeprecatedHeaderService",
			"EdgeCaseService",
		},
		"testdata/proto/multiple_services.proto": {"UserService", "AdminService", "NotificationService"},
		"testdata/proto/http_annotations.proto":  {"BasicService"},
	}

	formats := []string{"yaml", "json"}

	for protoFile, services := range protoToServices {
		// Skip proto files that don't exist
		if _, statErr := os.Stat(protoFile); os.IsNotExist(statErr) {
			continue
		}

		for _, service := range services {
			for _, format := range formats {
				var extension string
				if format == "json" {
					extension = ".openapi.json"
				} else {
					extension = ".openapi.yaml"
				}

				goldenFile := fmt.Sprintf("testdata/golden/%s/%s%s", format, service, extension)

				// Check if golden file exists
				if _, statErr := os.Stat(goldenFile); os.IsNotExist(statErr) {
					t.Logf("Skipping missing golden file: %s", goldenFile)
					continue
				}

				testName := fmt.Sprintf("%s_%s_%s", filepath.Base(protoFile), service, format)
				t.Run(testName, func(t *testing.T) {
					// Generate output
					tempDir := t.TempDir()
					formatParam := fmt.Sprintf("format=%s", format)

					cmd := exec.Command("protoc",
						"--plugin=protoc-gen-openapiv3="+pluginPath,
						"--openapiv3_out="+tempDir,
						"--openapiv3_opt="+formatParam,
						"--proto_path=testdata/proto",
						"--proto_path=../../proto",
						protoFile,
					)

					if runErr := cmd.Run(); runErr != nil {
						t.Fatalf("protoc failed for %s: %v", protoFile, runErr)
					}

					// Find generated service-specific file
					generatedFile := filepath.Join(tempDir, service+extension)

					// Compare with golden file
					generatedContent, genErr := os.ReadFile(generatedFile)
					if genErr != nil {
						t.Fatalf("Failed to read generated file %s: %v", generatedFile, genErr)
					}

					goldenContent, goldenErr := os.ReadFile(goldenFile)
					if goldenErr != nil {
						t.Fatalf("Failed to read golden file: %v", goldenErr)
					}

					if !bytes.Equal(generatedContent, goldenContent) {
						t.Errorf("Regression detected in %s service from %s (%s format)", service, protoFile, format)
						t.Errorf("Generated output differs from golden file")

						// Show a summary of the difference
						genLines := strings.Split(string(generatedContent), "\n")
						goldenLines := strings.Split(string(goldenContent), "\n")
						t.Errorf("Generated: %d lines, Golden: %d lines", len(genLines), len(goldenLines))
					}
				})
			}
		}
	}
}

// TestGoldenFileValidity ensures all golden files are valid YAML/JSON.
func TestGoldenFileValidity(t *testing.T) {
	formats := []string{"yaml", "json"}

	for _, format := range formats {
		goldenDir := fmt.Sprintf("testdata/golden/%s", format)
		pattern := fmt.Sprintf("%s/*.openapi.%s", goldenDir, format)
		goldenFiles, err := filepath.Glob(pattern)
		if err != nil {
			t.Fatalf("Failed to find %s golden files: %v", format, err)
		}

		for _, goldenFile := range goldenFiles {
			t.Run(fmt.Sprintf("%s_%s", format, filepath.Base(goldenFile)), func(t *testing.T) {
				// Read content
				content, readErr := os.ReadFile(goldenFile)
				if readErr != nil {
					t.Fatalf("Failed to read golden file: %v", readErr)
				}

				contentStr := string(content)

				switch format {
				case "yaml":
					// Basic YAML validation
					if !strings.HasPrefix(contentStr, "openapi:") {
						t.Error("YAML golden file should start with 'openapi:' declaration")
					}

					// Check for required OpenAPI sections
					requiredSections := []string{"info:", "paths:"}
					for _, section := range requiredSections {
						if !strings.Contains(contentStr, section) {
							t.Errorf("YAML golden file missing required section: %s", section)
						}
					}
				case "json":
					// Basic JSON validation
					if !strings.HasPrefix(strings.TrimSpace(contentStr), "{") {
						t.Error("JSON golden file should start with '{'")
					}

					if !strings.HasSuffix(strings.TrimSpace(contentStr), "}") {
						t.Error("JSON golden file should end with '}'")
					}

					// Check for required OpenAPI fields
					requiredFields := []string{`"openapi"`, `"info"`, `"paths"`}
					for _, field := range requiredFields {
						if !strings.Contains(contentStr, field) {
							t.Errorf("JSON golden file missing required field: %s", field)
						}
					}
				}

				// Check for OpenAPI version
				if !strings.Contains(contentStr, "3.1.0") {
					t.Error("Golden file should specify OpenAPI version 3.1.0")
				}
			})
		}
	}
}

// BenchmarkExhaustiveComparison benchmarks the golden file comparison process.
func BenchmarkExhaustiveComparison(b *testing.B) {
	// Read a sample golden file (YAML format)
	goldenFile := "testdata/golden/yaml/simple_service.openapi.yaml"
	goldenContent, err := os.ReadFile(goldenFile)
	if err != nil {
		// If YAML doesn't exist, try JSON
		goldenFile = "testdata/golden/json/simple_service.openapi.json"
		goldenContent, err = os.ReadFile(goldenFile)
		if err != nil {
			b.Fatalf("Failed to read any golden file: %v", err)
		}
	}

	// Create identical content for comparison
	generatedContent := make([]byte, len(goldenContent))
	copy(generatedContent, goldenContent)

	b.ResetTimer()
	for range b.N {
		_ = bytes.Equal(generatedContent, goldenContent)
	}
}
