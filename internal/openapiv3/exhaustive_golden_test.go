package openapiv3_test

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

func reportGoldenFileMismatch(t *testing.T, testName, goldenFile string, generatedContent, goldenContent []byte) {
	t.Helper()

	generated := string(generatedContent)
	golden := string(goldenContent)

	t.Errorf("Generated output does not match golden file for %s", testName)
	t.Errorf("Generated file size: %d bytes", len(generatedContent))
	t.Errorf("Golden file size: %d bytes", len(goldenContent))

	reportFirstDifference(t, generated, golden)
	reportLineDifferences(t, generated, golden)
	handleGoldenFileUpdate(t, goldenFile, generatedContent)
	writeTemporaryGeneratedFile(t, goldenFile, generatedContent)
}

func reportFirstDifference(t *testing.T, generated, golden string) {
	t.Helper()

	minLen := len(generated)
	if len(golden) < minLen {
		minLen = len(golden)
	}

	for i := range minLen {
		if generated[i] != golden[i] {
			t.Errorf("First difference at byte position %d", i)
			t.Errorf("Generated byte: %d (%c)", generated[i], generated[i])
			t.Errorf("Golden byte: %d (%c)", golden[i], golden[i])
			return
		}
	}
}

func reportLineDifferences(t *testing.T, generated, golden string) {
	t.Helper()

	generatedLines := strings.Split(generated, "\n")
	goldenLines := strings.Split(golden, "\n")

	maxLines := len(generatedLines)
	if len(goldenLines) > maxLines {
		maxLines = len(goldenLines)
	}

	diffCount := 0
	for i := 0; i < maxLines && diffCount < 10; i++ { // Limit to first 10 differences
		var generatedLine, goldenLine string
		if i < len(generatedLines) {
			generatedLine = generatedLines[i]
		}
		if i < len(goldenLines) {
			goldenLine = goldenLines[i]
		}

		if generatedLine != goldenLine {
			t.Errorf("Line %d differs:", i+1)
			t.Errorf("  Generated: %q", generatedLine)
			t.Errorf("  Golden:    %q", goldenLine)
			diffCount++
		}
	}

	if diffCount >= 10 {
		t.Errorf("... (showing first 10 differences only)")
	}
}

func handleGoldenFileUpdate(t *testing.T, goldenFile string, generatedContent []byte) {
	t.Helper()

	if os.Getenv("UPDATE_GOLDEN") == "1" {
		if writeErr := os.WriteFile(goldenFile, generatedContent, 0o644); writeErr != nil {
			t.Logf("Failed to update golden file: %v", writeErr)
		} else {
			t.Logf("Updated golden file: %s", goldenFile)
		}
	} else {
		t.Log("To update golden files, run: UPDATE_GOLDEN=1 go test -run TestExhaustiveGoldenFiles")
	}
}

func writeTemporaryGeneratedFile(t *testing.T, goldenFile string, generatedContent []byte) {
	t.Helper()

	tempGenFile := goldenFile + ".generated"
	if writeErr := os.WriteFile(tempGenFile, generatedContent, 0o644); writeErr == nil {
		t.Logf("Generated content written to: %s", tempGenFile)
		t.Logf("Compare with: diff %s %s", goldenFile, tempGenFile)
	}
}

// TestExhaustiveGoldenFiles performs exhaustive byte-for-byte comparison
// between generated OpenAPI output and golden files.
func TestExhaustiveGoldenFiles(t *testing.T) {
	// Build the plugin binary for testing
	pluginPath := "./protoc-gen-openapiv3-golden-test"
	buildCmd := exec.Command("go", "build", "-o", pluginPath, "../../cmd/protoc-gen-openapiv3")
	if err := buildCmd.Run(); err != nil {
		t.Fatalf("Failed to build plugin: %v", err)
	}
	defer os.Remove(pluginPath)

	testCases := []struct {
		name       string
		protoFile  string
		goldenFile string
		format     string // "yaml" or "json"
	}{
		{
			name:       "simple_service_yaml",
			protoFile:  "testdata/proto/simple_service.proto",
			goldenFile: "testdata/golden/yaml/simple_service.openapi.yaml",
			format:     "yaml",
		},
		{
			name:       "simple_service_json",
			protoFile:  "testdata/proto/simple_service.proto",
			goldenFile: "testdata/golden/json/simple_service.openapi.json",
			format:     "json",
		},
		{
			name:       "multiple_services_yaml",
			protoFile:  "testdata/proto/multiple_services.proto",
			goldenFile: "testdata/golden/yaml/multiple_services.openapi.yaml",
			format:     "yaml",
		},
		{
			name:       "multiple_services_json",
			protoFile:  "testdata/proto/multiple_services.proto",
			goldenFile: "testdata/golden/json/multiple_services.openapi.json",
			format:     "json",
		},
		{
			name:       "complex_types_yaml",
			protoFile:  "testdata/proto/complex_types.proto",
			goldenFile: "testdata/golden/yaml/complex_types.openapi.yaml",
			format:     "yaml",
		},
		{
			name:       "complex_types_json",
			protoFile:  "testdata/proto/complex_types.proto",
			goldenFile: "testdata/golden/json/complex_types.openapi.json",
			format:     "json",
		},
		{
			name:       "nested_messages_yaml",
			protoFile:  "testdata/proto/nested_messages.proto",
			goldenFile: "testdata/golden/yaml/nested_messages.openapi.yaml",
			format:     "yaml",
		},
		{
			name:       "nested_messages_json",
			protoFile:  "testdata/proto/nested_messages.proto",
			goldenFile: "testdata/golden/json/nested_messages.openapi.json",
			format:     "json",
		},
		{
			name:       "headers_yaml",
			protoFile:  "testdata/proto/headers.proto",
			goldenFile: "testdata/golden/yaml/headers.openapi.yaml",
			format:     "yaml",
		},
		{
			name:       "headers_json",
			protoFile:  "testdata/proto/headers.proto",
			goldenFile: "testdata/golden/json/headers.openapi.json",
			format:     "json",
		},
		{
			name:       "validation_constraints_yaml",
			protoFile:  "testdata/proto/validation_constraints.proto",
			goldenFile: "testdata/golden/yaml/validation_constraints.openapi.yaml",
			format:     "yaml",
		},
		{
			name:       "validation_constraints_json",
			protoFile:  "testdata/proto/validation_constraints.proto",
			goldenFile: "testdata/golden/json/validation_constraints.openapi.json",
			format:     "json",
		},
		{
			name:       "http_annotations_yaml",
			protoFile:  "testdata/proto/http_annotations.proto",
			goldenFile: "testdata/golden/yaml/http_annotations.openapi.yaml",
			format:     "yaml",
		},
		{
			name:       "http_annotations_json",
			protoFile:  "testdata/proto/http_annotations.proto",
			goldenFile: "testdata/golden/json/http_annotations.openapi.json",
			format:     "json",
		},
		{
			name:       "no_services_yaml",
			protoFile:  "testdata/proto/no_services.proto",
			goldenFile: "testdata/golden/yaml/no_services.openapi.yaml",
			format:     "yaml",
		},
		{
			name:       "no_services_json",
			protoFile:  "testdata/proto/no_services.proto",
			goldenFile: "testdata/golden/json/no_services.openapi.json",
			format:     "json",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Generate fresh output using protoc
			tempDir := t.TempDir()

			// Set format parameter
			formatParam := fmt.Sprintf("format=%s", tc.format)

			// Run protoc to generate new output
			cmd := exec.Command("protoc",
				"--plugin=protoc-gen-openapiv3="+pluginPath,
				"--openapiv3_out="+tempDir,
				"--openapiv3_opt="+formatParam,
				"--proto_path=testdata/proto",
				tc.protoFile,
			)

			var stdout, stderr bytes.Buffer
			cmd.Stdout = &stdout
			cmd.Stderr = &stderr

			if runErr := cmd.Run(); runErr != nil {
				t.Fatalf("protoc failed for %s: %v\nStdout: %s\nStderr: %s",
					tc.name, runErr, stdout.String(), stderr.String())
			}

			// Find the generated file
			baseName := strings.TrimSuffix(filepath.Base(tc.protoFile), ".proto")
			var extension string
			if tc.format == "json" {
				extension = ".openapi.json"
			} else {
				extension = ".openapi.yaml"
			}
			generatedFile := filepath.Join(tempDir, baseName+extension)

			// Read generated content
			generatedContent, err := os.ReadFile(generatedFile)
			if err != nil {
				t.Fatalf("Failed to read generated file %s: %v", generatedFile, err)
			}

			// Read golden file content
			goldenContent, err := os.ReadFile(tc.goldenFile)
			if err != nil {
				t.Fatalf("Failed to read golden file %s: %v", tc.goldenFile, err)
			}

			// Perform exhaustive byte-for-byte comparison
			if !bytes.Equal(generatedContent, goldenContent) {
				reportGoldenFileMismatch(t, tc.name, tc.goldenFile, generatedContent, goldenContent)
			} else {
				t.Logf("âœ“ Perfect match for %s (%d bytes)", tc.name, len(generatedContent))
			}
		})
	}
}

// TestExhaustiveRegression tests that any change to the implementation
// is detected by comparing against multiple golden files.
func TestExhaustiveRegression(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping exhaustive regression test in short mode")
	}

	// Build the plugin
	pluginPath := "./protoc-gen-openapiv3-regression-test"
	buildCmd := exec.Command("go", "build", "-o", pluginPath, "../../cmd/protoc-gen-openapiv3")
	if err := buildCmd.Run(); err != nil {
		t.Fatalf("Failed to build plugin: %v", err)
	}
	defer os.Remove(pluginPath)

	// Test all proto files in testdata/proto
	protoFiles, err := filepath.Glob("testdata/proto/*.proto")
	if err != nil {
		t.Fatalf("Failed to find proto files: %v", err)
	}

	if len(protoFiles) == 0 {
		t.Fatal("No proto files found in testdata/proto")
	}

	formats := []string{"yaml", "json"}

	for _, protoFile := range protoFiles {
		baseName := strings.TrimSuffix(filepath.Base(protoFile), ".proto")

		for _, format := range formats {
			var extension string
			if format == "json" {
				extension = ".openapi.json"
			} else {
				extension = ".openapi.yaml"
			}

			goldenFile := fmt.Sprintf("testdata/golden/%s/%s%s", format, baseName, extension)

			// Check if golden file exists
			if _, statErr := os.Stat(goldenFile); os.IsNotExist(statErr) {
				t.Errorf("Golden file missing for %s in %s format: %s", protoFile, format, goldenFile)
				continue
			}

			testName := fmt.Sprintf("%s_%s", baseName, format)
			t.Run(testName, func(t *testing.T) {
				// Generate output
				tempDir := t.TempDir()
				formatParam := fmt.Sprintf("format=%s", format)

				cmd := exec.Command("protoc",
					"--plugin=protoc-gen-openapiv3="+pluginPath,
					"--openapiv3_out="+tempDir,
					"--openapiv3_opt="+formatParam,
					"--proto_path=testdata/proto",
					protoFile,
				)

				if runErr := cmd.Run(); runErr != nil {
					t.Fatalf("protoc failed for %s: %v", protoFile, runErr)
				}

				// Find generated file
				generatedFile := filepath.Join(tempDir, baseName+extension)

				// Compare with golden file
				generatedContent, genErr := os.ReadFile(generatedFile)
				if genErr != nil {
					t.Fatalf("Failed to read generated file: %v", genErr)
				}

				goldenContent, goldenErr := os.ReadFile(goldenFile)
				if goldenErr != nil {
					t.Fatalf("Failed to read golden file: %v", goldenErr)
				}

				if !bytes.Equal(generatedContent, goldenContent) {
					t.Errorf("Regression detected in %s (%s format)", protoFile, format)
					t.Errorf("Generated output differs from golden file")

					// Show a summary of the difference
					genLines := strings.Split(string(generatedContent), "\n")
					goldenLines := strings.Split(string(goldenContent), "\n")
					t.Errorf("Generated: %d lines, Golden: %d lines", len(genLines), len(goldenLines))
				}
			})
		}
	}
}

// TestGoldenFileValidity ensures all golden files are valid YAML/JSON.
func TestGoldenFileValidity(t *testing.T) {
	formats := []string{"yaml", "json"}

	for _, format := range formats {
		goldenDir := fmt.Sprintf("testdata/golden/%s", format)
		pattern := fmt.Sprintf("%s/*.openapi.%s", goldenDir, format)
		goldenFiles, err := filepath.Glob(pattern)
		if err != nil {
			t.Fatalf("Failed to find %s golden files: %v", format, err)
		}

		for _, goldenFile := range goldenFiles {
			t.Run(fmt.Sprintf("%s_%s", format, filepath.Base(goldenFile)), func(t *testing.T) {
				// Read content
				content, readErr := os.ReadFile(goldenFile)
				if readErr != nil {
					t.Fatalf("Failed to read golden file: %v", readErr)
				}

				contentStr := string(content)

				if format == "yaml" {
					// Basic YAML validation
					if !strings.HasPrefix(contentStr, "openapi:") {
						t.Error("YAML golden file should start with 'openapi:' declaration")
					}
					
					// Check for required OpenAPI sections
					requiredSections := []string{"info:", "paths:"}
					for _, section := range requiredSections {
						if !strings.Contains(contentStr, section) {
							t.Errorf("YAML golden file missing required section: %s", section)
						}
					}
				} else if format == "json" {
					// Basic JSON validation
					if !strings.HasPrefix(strings.TrimSpace(contentStr), "{") {
						t.Error("JSON golden file should start with '{'")
					}
					
					if !strings.HasSuffix(strings.TrimSpace(contentStr), "}") {
						t.Error("JSON golden file should end with '}'")
					}
					
					// Check for required OpenAPI fields
					requiredFields := []string{`"openapi"`, `"info"`, `"paths"`}
					for _, field := range requiredFields {
						if !strings.Contains(contentStr, field) {
							t.Errorf("JSON golden file missing required field: %s", field)
						}
					}
				}

				// Check for OpenAPI version
				if !strings.Contains(contentStr, "3.1.0") {
					t.Error("Golden file should specify OpenAPI version 3.1.0")
				}
			})
		}
	}
}

// BenchmarkExhaustiveComparison benchmarks the golden file comparison process.
func BenchmarkExhaustiveComparison(b *testing.B) {
	// Read a sample golden file (YAML format)
	goldenFile := "testdata/golden/yaml/simple_service.openapi.yaml"
	goldenContent, err := os.ReadFile(goldenFile)
	if err != nil {
		// If YAML doesn't exist, try JSON
		goldenFile = "testdata/golden/json/simple_service.openapi.json"
		goldenContent, err = os.ReadFile(goldenFile)
		if err != nil {
			b.Fatalf("Failed to read any golden file: %v", err)
		}
	}

	// Create identical content for comparison
	generatedContent := make([]byte, len(goldenContent))
	copy(generatedContent, goldenContent)

	b.ResetTimer()
	for range b.N {
		_ = bytes.Equal(generatedContent, goldenContent)
	}
}