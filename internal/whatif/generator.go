package whatif

import (
	"fmt"
	"os"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

// Generator handles WhatIf scenario generation for protobuf services.
type Generator struct {
	plugin *protogen.Plugin
	opts   Options
	llm    *LLMClient
}

// Options configures the generator.
type Options struct {
	OpenRouterAPIKey string
	Model            string
	Debug            bool
}

// New creates a new WhatIf generator.
func New(plugin *protogen.Plugin, opts Options) *Generator {
	var llm *LLMClient
	if opts.OpenRouterAPIKey != "" {
		llm = NewLLMClient(opts.OpenRouterAPIKey, opts.Model)
		if opts.Debug {
			llm.SetDebug(true)
		}
	}

	return &Generator{
		plugin: plugin,
		opts:   opts,
		llm:    llm,
	}
}

// Generate processes all files and generates WhatIf scenarios.
func (g *Generator) Generate() error {
	for _, file := range g.plugin.Files {
		if !file.Generate {
			continue
		}
		if len(file.Services) == 0 {
			continue
		}

		if err := g.generateFile(file); err != nil {
			return fmt.Errorf("failed to generate file %s: %w", file.Desc.Path(), err)
		}
	}
	return nil
}

func (g *Generator) generateFile(file *protogen.File) error {
	// Generate main WhatIf file
	if err := g.generateWhatIfFile(file); err != nil {
		return err
	}

	// Generate scenarios file
	if err := g.generateScenariosFile(file); err != nil {
		return err
	}

	// Generate mock implementation file
	if err := g.generateMockFile(file); err != nil {
		return err
	}

	return nil
}

func (g *Generator) generateWhatIfFile(file *protogen.File) error {
	filename := file.GeneratedFilenamePrefix + "_whatif.pb.go"
	gf := g.plugin.NewGeneratedFile(filename, file.GoImportPath)

	g.writeHeader(gf, file)

	// Imports
	gf.P("import (")
	gf.P(`"context"`)
	gf.P(`"sync"`)
	gf.P(")")
	gf.P()

	// Generate core types
	g.generateCoreTypes(gf)

	// Generate mock server for each service
	for _, service := range file.Services {
		if err := g.generateMockServer(gf, file, service); err != nil {
			return err
		}
	}

	return nil
}

func (g *Generator) generateScenariosFile(file *protogen.File) error {
	filename := file.GeneratedFilenamePrefix + "_whatif_scenarios.pb.go"
	gf := g.plugin.NewGeneratedFile(filename, file.GoImportPath)

	g.writeHeader(gf, file)
	
	// Imports
	gf.P("import (")
	gf.P(`"context"`)
	gf.P(`"fmt"`)
	gf.P(")")
	gf.P()

	// Collect all scenarios for all services
	allScenarios := make(map[string][]Scenario)

	for _, service := range file.Services {
		// Get LLM-generated scenarios if available
		scenarios, err := g.getScenarios(service)
		if err != nil {
			if g.opts.Debug {
				gf.P("// Warning: Failed to generate LLM scenarios:", err)
			}
			// Fall back to basic scenarios
			scenarios = g.generateBasicScenarios(service)
		}
		allScenarios[service.GoName] = scenarios
	}

	// Generate WhatIf structure
	g.generateWhatIfStructure(gf, file, allScenarios)

	return nil
}

func (g *Generator) generateMockFile(file *protogen.File) error {
	filename := file.GeneratedFilenamePrefix + "_whatif_mock.pb.go"
	gf := g.plugin.NewGeneratedFile(filename, file.GoImportPath)

	g.writeHeader(gf, file)

	gf.P("import (")
	gf.P(`"context"`)
	gf.P(")")
	gf.P()

	// Generate mock method implementations for each service
	for _, service := range file.Services {
		if err := g.generateMockMethods(gf, file, service); err != nil {
			return err
		}
	}

	return nil
}

func (g *Generator) writeHeader(gf *protogen.GeneratedFile, file *protogen.File) {
	gf.P("// Code generated by protoc-gen-go-whatif. DO NOT EDIT.")
	gf.P("// versions:")
	gf.P("// - protoc-gen-go-whatif v0.1.0")
	gf.P("// - protoc             ", protocVersion(g.plugin))
	gf.P("// source: ", file.Desc.Path())
	gf.P()
	gf.P("package ", file.GoPackageName)
	gf.P()
}

func (g *Generator) generateCoreTypes(gf *protogen.GeneratedFile) {
	gf.P("// WhatIfOption configures a whatif server with scenarios.")
	gf.P("type WhatIfOption func(*whatifServerConfig)")
	gf.P()

	gf.P("// ScenarioHandler handles a specific scenario for a method.")
	gf.P("type ScenarioHandler interface {")
	gf.P("Name() string")
	gf.P("Matches(method string, req interface{}) bool")
	gf.P("Handle(ctx context.Context, method string, req interface{}) (interface{}, error)")
	gf.P("}")
	gf.P()

	gf.P("// whatifServerConfig holds scenario configuration for a whatif server.")
	gf.P("type whatifServerConfig struct {")
	gf.P("scenarios map[string][]ScenarioHandler")
	gf.P("serviceScenarios []ScenarioHandler")
	gf.P("mu sync.RWMutex")
	gf.P("}")
	gf.P()

	gf.P("func newWhatIfServerConfig() *whatifServerConfig {")
	gf.P("return &whatifServerConfig{")
	gf.P("scenarios: make(map[string][]ScenarioHandler),")
	gf.P("}")
	gf.P("}")
	gf.P()
}

func (g *Generator) generateMockServer(gf *protogen.GeneratedFile, file *protogen.File, service *protogen.Service) error {
	serverName := "WhatIf" + service.GoName + "Server"

	gf.P("// ", serverName, " is a whatif implementation of ", service.GoName, "Server with scenario support.")
	gf.P("type ", serverName, " struct {")
	gf.P("config *whatifServerConfig")
	gf.P("}")
	gf.P()

	// Constructor
	gf.P("// New", serverName, " creates a new whatif server with optional scenarios.")
	gf.P("func New", serverName, "(opts ...WhatIfOption) *", serverName, " {")
	gf.P("config := newWhatIfServerConfig()")
	gf.P("for _, opt := range opts {")
	gf.P("opt(config)")
	gf.P("}")
	gf.P("return &", serverName, "{config: config}")
	gf.P("}")
	gf.P()

	return nil
}

func (g *Generator) generateMockMethods(gf *protogen.GeneratedFile, file *protogen.File, service *protogen.Service) error {
	serverName := "WhatIf" + service.GoName + "Server"

	for _, method := range service.Methods {
		methodName := method.GoName
		inputType := method.Input.GoIdent
		outputType := method.Output.GoIdent

		gf.P("// ", methodName, " is the mock implementation of ", service.GoName, "Server.", methodName, ".")
		gf.P("func (m *", serverName, ") ", methodName, "(ctx context.Context, req *", inputType, ") (*", outputType, ", error) {")

		// Check for method-specific scenarios
		gf.P("m.config.mu.RLock()")
		gf.P("defer m.config.mu.RUnlock()")
		gf.P()

		gf.P("// Check method-specific scenarios")
		gf.P(`if scenarios, ok := m.config.scenarios["`, methodName, `"]; ok {`)
		gf.P("for _, scenario := range scenarios {")
		gf.P("if scenario.Matches(\"", methodName, "\", req) {")
		gf.P("resp, err := scenario.Handle(ctx, \"", methodName, "\", req)")
		gf.P("if resp != nil {")
		gf.P("return resp.(*", outputType, "), err")
		gf.P("}")
		gf.P("return nil, err")
		gf.P("}")
		gf.P("}")
		gf.P("}")
		gf.P()

		gf.P("// Check service-level scenarios")
		gf.P("for _, scenario := range m.config.serviceScenarios {")
		gf.P("if scenario.Matches(\"", methodName, "\", req) {")
		gf.P("resp, err := scenario.Handle(ctx, \"", methodName, "\", req)")
		gf.P("if err != nil {")
		gf.P("return nil, err")
		gf.P("}")
		gf.P("if resp != nil {")
		gf.P("return resp.(*", outputType, "), err")
		gf.P("}")
		gf.P("// Continue to default if scenario returns nil response")
		gf.P("}")
		gf.P("}")
		gf.P()

		// Default response
		gf.P("// Default successful response")
		gf.P("return ", g.generateDefaultResponse(method), ", nil")
		gf.P("}")
		gf.P()
	}

	return nil
}

func (g *Generator) generateDefaultResponse(method *protogen.Method) string {
	return "&" + method.Output.GoIdent.GoName + "{}"
}

func (g *Generator) getScenarios(service *protogen.Service) ([]Scenario, error) {
	if g.llm == nil {
		if g.opts.Debug {
			fmt.Fprintf(os.Stderr, "Debug: No LLM client available, using basic scenarios\n")
		}
		return g.generateBasicScenarios(service), nil
	}
	
	if g.opts.Debug {
		fmt.Fprintf(os.Stderr, "Debug: Using LLM to generate scenarios for service %s\n", service.GoName)
	}

	var allScenarios []Scenario

	// Get service-level scenarios
	serviceScenarios, err := g.llm.GenerateServiceScenarios(service)
	if err != nil {
		return nil, err
	}
	allScenarios = append(allScenarios, serviceScenarios...)

	// Get method-specific scenarios
	for _, method := range service.Methods {
		methodScenarios, err := g.llm.GenerateMethodScenarios(service, method)
		if err != nil {
			if g.opts.Debug {
				// Log error but continue
				fmt.Fprintf(os.Stderr, "Warning: Failed to generate scenarios for %s.%s: %v\n", service.GoName, method.GoName, err)
			}
			continue
		}
		allScenarios = append(allScenarios, methodScenarios...)
	}

	return allScenarios, nil
}

func (g *Generator) generateBasicScenarios(service *protogen.Service) []Scenario {
	scenarios := []Scenario{
		// Service-level scenarios
		{
			Name:         "database_down",
			Description:  "Database connection failed",
			FunctionName: "DatabaseDown",
			Level:        ServiceLevel,
			Error: &ErrorScenario{
				Code:    503,
				Message: "Service temporarily unavailable",
			},
		},
		{
			Name:         "slow_response",
			Description:  "All responses are slow",
			FunctionName: "SlowResponse",
			Level:        ServiceLevel,
			Latency:      "3s",
		},
	}

	// Add basic method scenarios
	for _, method := range service.Methods {
		scenarios = append(scenarios, Scenario{
			Name:         strings.ToLower(method.GoName) + "_error",
			Description:  fmt.Sprintf("%s returns an error", method.GoName),
			FunctionName: method.GoName + "Error",
			Level:        MethodLevel,
			Method:       method.GoName,
			Error: &ErrorScenario{
				Code:    500,
				Message: "Internal server error",
			},
		})
	}

	return scenarios
}

func (g *Generator) generateWhatIfStructure(gf *protogen.GeneratedFile, file *protogen.File, allScenarios map[string][]Scenario) {
	gf.P("// WhatIf provides all scenario options for this package.")
	gf.P("var WhatIf = whatIfScenarios{}")
	gf.P()

	gf.P("type whatIfScenarios struct{}")
	gf.P()

	// Generate scenario functions for each service
	for _, service := range file.Services {
		scenarios := allScenarios[service.GoName]
		g.generateServiceScenarios(gf, service, scenarios)
	}
}

func (g *Generator) generateServiceScenarios(gf *protogen.GeneratedFile, service *protogen.Service, scenarios []Scenario) {
	// Group scenarios by level
	var serviceScenarios []Scenario
	methodScenarios := make(map[string][]Scenario)

	for _, s := range scenarios {
		if s.Level == ServiceLevel {
			serviceScenarios = append(serviceScenarios, s)
		} else if s.Level == MethodLevel {
			methodScenarios[s.Method] = append(methodScenarios[s.Method], s)
		}
	}

	// Generate service-level scenario functions
	for _, s := range serviceScenarios {
		g.generateScenarioFunction(gf, service, s)
	}

	// Generate method-specific scenario functions
	for method, methodScenarios := range methodScenarios {
		gf.P("// ", method, " scenarios")
		for _, s := range methodScenarios {
			g.generateScenarioFunction(gf, service, s)
		}
	}
}

func (g *Generator) generateScenarioFunction(gf *protogen.GeneratedFile, service *protogen.Service, scenario Scenario) {
	// Create unique function and handler names to avoid conflicts
	// Use the scenario name (which is unique) to generate function names
	var functionName string
	var handlerName string
	
	if scenario.Level == ServiceLevel {
		// Service-level: use FunctionName directly
		functionName = scenario.FunctionName
		handlerName = strings.ToLower(scenario.FunctionName)
	} else {
		// Method-level: create unique name based on method + scenario name
		// Convert snake_case name to PascalCase for function name
		nameParts := strings.Split(scenario.Name, "_")
		var pascalName strings.Builder
		for _, part := range nameParts {
			if len(part) > 0 {
				pascalName.WriteString(strings.ToUpper(part[:1]) + strings.ToLower(part[1:]))
			}
		}
		functionName = scenario.Method + pascalName.String()
		handlerName = strings.ToLower(scenario.Method) + strings.ToLower(pascalName.String())
	}
	handlerName += "Handler"
	
	gf.P("// ", functionName, " - ", scenario.Description)
	gf.P("func (w whatIfScenarios) ", functionName, "() WhatIfOption {")
	gf.P("return func(config *whatifServerConfig) {")
	
	if scenario.Level == ServiceLevel {
		gf.P("config.serviceScenarios = append(config.serviceScenarios, &", handlerName, "{})")
	} else {
		gf.P(`config.scenarios["`, scenario.Method, `"] = append(config.scenarios["`, scenario.Method, `"], &`, handlerName, "{})")
	}
	
	gf.P("}")
	gf.P("}")
	gf.P()

	// Generate the handler type
	gf.P("type ", handlerName, " struct{}")
	gf.P()
	
	gf.P("func (h *", handlerName, ") Name() string { return \"", scenario.Name, "\" }")
	gf.P("func (h *", handlerName, ") Matches(method string, req interface{}) bool { return true }")
	gf.P("func (h *", handlerName, ") Handle(ctx context.Context, method string, req interface{}) (interface{}, error) {")
	
	// Generate intelligent scenario logic based on the scenario description
	g.generateScenarioLogic(gf, scenario)
	
	gf.P("}")
	gf.P()
}

// generateSuccessResponse generates a realistic success response using LLM field values
func (g *Generator) generateSuccessResponse(gf *protogen.GeneratedFile, scenario Scenario) {
	// For now, just return a basic success response with field values as comments
	// This can be enhanced to generate actual proto message construction
	gf.P("// LLM-generated field values: %v", scenario.FieldValues)
	gf.P("// TODO: Generate realistic response using field values")
	gf.P("return nil, fmt.Errorf(\"success scenario not yet implemented\")")
}

func (g *Generator) generateScenarioLogic(gf *protogen.GeneratedFile, scenario Scenario) {
	// First priority: use LLM-generated error information if available
	if scenario.Error != nil {
		gf.P(`return nil, fmt.Errorf("`, scenario.Error.Message, `")`)
		return
	}
	
	// Second priority: use LLM-generated success field values if available
	if len(scenario.FieldValues) > 0 {
		g.generateSuccessResponse(gf, scenario)
		return
	}
	
	// Fallback to pattern-based logic for basic scenarios
	name := strings.ToLower(scenario.Name)
	desc := strings.ToLower(scenario.Description)
	
	switch {
	case strings.Contains(name, "database") && strings.Contains(name, "down"):
		gf.P(`return nil, fmt.Errorf("database connection failed: connection timeout")`)
	case strings.Contains(name, "timeout") || strings.Contains(desc, "timeout"):
		gf.P(`return nil, fmt.Errorf("request timeout: operation took too long")`)
	case strings.Contains(name, "unauthorized") || strings.Contains(desc, "unauthorized"):
		gf.P(`return nil, fmt.Errorf("unauthorized: access denied")`)
	case strings.Contains(name, "not_found") || strings.Contains(desc, "not found"):
		gf.P(`return nil, fmt.Errorf("resource not found")`)
	case strings.Contains(name, "invalid") && strings.Contains(name, "email"):
		gf.P(`return nil, fmt.Errorf("invalid email format provided")`)
	case strings.Contains(name, "missing") && strings.Contains(name, "name"):
		gf.P(`return nil, fmt.Errorf("missing required field: name")`)
	case strings.Contains(name, "empty") && strings.Contains(name, "email"):
		gf.P(`return nil, fmt.Errorf("email field cannot be empty")`)
	case strings.Contains(name, "duplicate") && strings.Contains(name, "email"):
		gf.P(`return nil, fmt.Errorf("email already exists in system")`)
	case strings.Contains(name, "long") && strings.Contains(name, "name"):
		gf.P(`return nil, fmt.Errorf("name exceeds maximum length limit")`)
	case strings.Contains(name, "expired") && strings.Contains(name, "token"):
		gf.P(`return nil, fmt.Errorf("authentication token has expired")`)
	case strings.Contains(name, "missing") && strings.Contains(name, "token"):
		gf.P(`return nil, fmt.Errorf("authentication token is required")`)
	case strings.Contains(name, "locked") && strings.Contains(name, "account"):
		gf.P(`return nil, fmt.Errorf("user account is locked due to multiple failed attempts")`)
	case strings.Contains(name, "invalid") && strings.Contains(name, "format"):
		gf.P(`return nil, fmt.Errorf("invalid format in request data")`)
	case strings.Contains(name, "deleted"):
		gf.P(`return nil, fmt.Errorf("resource has been deleted")`)
	case strings.Contains(name, "maintenance"):
		gf.P(`return nil, fmt.Errorf("service temporarily unavailable due to maintenance")`)
	case strings.Contains(name, "authentication") && strings.Contains(name, "unavailable"):
		gf.P(`return nil, fmt.Errorf("authentication service is currently unavailable")`)
	default:
		// Default error for unknown scenarios
		gf.P(`return nil, fmt.Errorf("scenario triggered: ` + scenario.Description + `")`)
	}
}

func protocVersion(plugin *protogen.Plugin) string {
	if v := plugin.Request.GetCompilerVersion(); v != nil {
		return fmt.Sprintf("v%d.%d.%d", v.GetMajor(), v.GetMinor(), v.GetPatch())
	}
	return "(unknown)"
}