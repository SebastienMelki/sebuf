// Package oneofhelper provides helper functions for protobuf messages with oneof fields.
package oneofhelper

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

const (
	goString            = "string"
	goInt32             = "int32"
	goInt64             = "int64"
	goUint32            = "uint32"
	goUint64            = "uint64"
	goBool              = "bool"
	goFloat32           = "float32"
	goFloat64           = "float64"
	goBytes             = "[]byte"
	goInterface         = "interface{}"
	mapValueFieldNumber = 2
)

// GenerateHelpers generates helper functions for all messages with oneofs in the given file.
func GenerateHelpers(plugin *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + "_helpers.pb.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	// Write package header
	g.P("// Code generated by protoc-gen-go-oneof-helper. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// Generate helpers for each message with oneofs
	// The GeneratedFile will automatically handle imports for us
	for _, message := range file.Messages {
		GenerateMessageHelpers(g, message)
	}
}

// GenerateMessageHelpers generates helper functions for a single message and its nested messages.
func GenerateMessageHelpers(g *protogen.GeneratedFile, message *protogen.Message) {
	// Look for oneofs
	for _, oneof := range message.Oneofs {
		// Generate a helper for each field in the oneof
		for _, field := range oneof.Fields {
			GenerateOneofHelper(g, message, oneof, field)
		}
	}

	// Recurse into nested messages
	for _, nested := range message.Messages {
		GenerateMessageHelpers(g, nested)
	}
}

// GenerateOneofHelper generates a helper function for a specific oneof field.
func GenerateOneofHelper(g *protogen.GeneratedFile, message *protogen.Message,
	oneof *protogen.Oneof, field *protogen.Field,
) {
	// Generate helper function name
	helperName := fmt.Sprintf("New%s%s", message.GoIdent.GoName, field.GoName)

	// Get the wrapper type name (e.g., LoginMethod_Email)
	wrapperType := fmt.Sprintf("%s_%s", message.GoIdent.GoName, field.GoName)

	// Check if this field is a message type that might have fields
	if field.Message != nil {
		// Build parameter list from both normal fields and nested message fields
		var params []string
		var normalFieldAssignments []string
		var paramAssignments []string

		// First, collect all normal (non-oneof) fields from the parent message
		for _, parentField := range message.Fields {
			// Skip if this field is part of a oneof
			if parentField.Oneof != nil {
				continue
			}

			paramName := lowerFirst(parentField.GoName)
			paramType := GetFieldType(g, parentField)
			params = append(params, fmt.Sprintf("%s %s", paramName, paramType))
			normalFieldAssignments = append(normalFieldAssignments,
				fmt.Sprintf("\t\t%s: %s,", parentField.GoName, paramName))
		}

		// Then collect fields from the nested message within the oneof
		for _, nestedField := range field.Message.Fields {
			paramName := lowerFirst(nestedField.GoName)
			paramType := GetFieldType(g, nestedField)
			params = append(params, fmt.Sprintf("%s %s", paramName, paramType))
			paramAssignments = append(paramAssignments,
				fmt.Sprintf("\t\t\t%s: %s,", nestedField.GoName, paramName))
		}

		// Generate the helper function
		g.P("// ", helperName, " creates a new ", message.GoIdent.GoName,
			" with ", field.GoName, " set")
		g.P("func ", helperName, "(", strings.Join(params, ", "), ") *",
			message.GoIdent.GoName, " {")
		g.P("\treturn &", message.GoIdent.GoName, "{")

		// Add normal field assignments
		for _, assignment := range normalFieldAssignments {
			g.P(assignment)
		}

		// Add oneof field assignment
		g.P("\t\t", oneof.GoName, ": &", wrapperType, "{")
		g.P("\t\t\t", field.GoName, ": &", g.QualifiedGoIdent(field.Message.GoIdent), "{")

		for _, assignment := range paramAssignments {
			g.P(assignment)
		}

		g.P("\t\t\t},")
		g.P("\t\t},")
		g.P("\t}")
		g.P("}")
		g.P()
	}
}

// LowerFirst converts the first character of a string to lowercase
// This function is exported for testing purposes.
func LowerFirst(s string) string {
	return lowerFirst(s)
}

// lowerFirst is the internal implementation.
func lowerFirst(s string) string {
	if s == "" {
		return ""
	}

	return strings.ToLower(s[:1]) + s[1:]
}

// GetFieldType determines the Go type for a protobuf field.
func GetFieldType(g *protogen.GeneratedFile, field *protogen.Field) string {
	// Handle repeated fields
	if field.Desc.IsList() {
		return "[]" + getSingleFieldType(g, field)
	}

	// Handle map fields
	if field.Desc.IsMap() {
		return getMapType(g, field)
	}

	// Handle optional fields (proto3 optional)
	if field.Desc.HasOptionalKeyword() {
		return "*" + getSingleFieldType(g, field)
	}

	return getSingleFieldType(g, field)
}

func getMapType(g *protogen.GeneratedFile, field *protogen.Field) string {
	// For map keys, we need to handle the key type specially
	keyType := getMapKeyType(field.Desc.MapKey())
	valueType := getMapValueType(g, field)

	return "map[" + keyType + "]" + valueType
}

func getMapValueType(g *protogen.GeneratedFile, field *protogen.Field) string {
	switch field.Desc.MapValue().Kind() {
	case protoreflect.BoolKind:
		return goBool
	case protoreflect.EnumKind:
		return goInt32
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return goInt32
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return goUint32
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return goInt64
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return goUint64
	case protoreflect.FloatKind:
		return goFloat32
	case protoreflect.DoubleKind:
		return goFloat64
	case protoreflect.StringKind:
		return goString
	case protoreflect.BytesKind:
		return goBytes
	case protoreflect.GroupKind, protoreflect.MessageKind:
		return getMapMessageValueType(g, field)
	default:
		// For non-message types, use a temporary field
		tempField := &protogen.Field{
			Desc: field.Desc.MapValue(),
		}
		return getSingleFieldType(g, tempField)
	}
}

func getMapMessageValueType(g *protogen.GeneratedFile, field *protogen.Field) string {
	// Find the actual message type for the map value
	if field.Message != nil && field.Message.Fields != nil && len(field.Message.Fields) > 1 {
		// Map entry messages have exactly 2 fields: key and value
		for _, f := range field.Message.Fields {
			if f.Desc.Number() == mapValueFieldNumber { // value field is always number 2
				return getSingleFieldType(g, f)
			}
		}
	}

	return goInterface
}

func getMapKeyType(desc protoreflect.FieldDescriptor) string {
	switch desc.Kind() {
	case protoreflect.StringKind:
		return goString
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return goInt32
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return goInt64
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return goUint32
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return goUint64
	case protoreflect.BoolKind:
		return goBool
	case protoreflect.EnumKind:
		return goInt32
	case protoreflect.FloatKind:
		return goFloat32
	case protoreflect.DoubleKind:
		return goFloat64
	case protoreflect.BytesKind:
		return goBytes
	case protoreflect.MessageKind:
		return goInterface
	case protoreflect.GroupKind:
		return goInterface
	default:
		return goString
	}
}

func getSingleFieldType(g *protogen.GeneratedFile, field *protogen.Field) string {
	switch field.Desc.Kind() {
	// String types
	case protoreflect.StringKind:
		return goString

	// Boolean type
	case protoreflect.BoolKind:
		return goBool

	// Integer types
	case protoreflect.Int32Kind:
		return goInt32
	case protoreflect.Int64Kind:
		return goInt64
	case protoreflect.Sint32Kind:
		return goInt32
	case protoreflect.Sint64Kind:
		return goInt64
	case protoreflect.Sfixed32Kind:
		return goInt32
	case protoreflect.Sfixed64Kind:
		return goInt64

	// Unsigned integer types
	case protoreflect.Uint32Kind:
		return goUint32
	case protoreflect.Uint64Kind:
		return goUint64
	case protoreflect.Fixed32Kind:
		return goUint32
	case protoreflect.Fixed64Kind:
		return goUint64

	// Floating point types
	case protoreflect.FloatKind:
		return goFloat32
	case protoreflect.DoubleKind:
		return goFloat64

	// Bytes type
	case protoreflect.BytesKind:
		return goBytes

	// Enum type
	case protoreflect.EnumKind:
		if field.Enum != nil {
			return g.QualifiedGoIdent(field.Enum.GoIdent)
		}

		return goInt32 // fallback for enums

	// Message type
	case protoreflect.MessageKind:
		if field.Message != nil {
			return "*" + g.QualifiedGoIdent(field.Message.GoIdent)
		}

		return "*interface{}" // fallback

	// Group type (deprecated but still supported)
	case protoreflect.GroupKind:
		if field.Message != nil {
			return "*" + g.QualifiedGoIdent(field.Message.GoIdent)
		}

		return "*interface{}"

	default:
		return goInterface
	}
}
