package oneofhelper_test

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

func reportGoldenFileMismatch(t *testing.T, testName, goldenFile string, generatedContent, goldenContent []byte) {
	t.Helper()

	generated := string(generatedContent)
	golden := string(goldenContent)

	t.Errorf("Generated output does not match golden file for %s", testName)
	t.Errorf("Generated file size: %d bytes", len(generatedContent))
	t.Errorf("Golden file size: %d bytes", len(goldenContent))

	reportFirstDifference(t, generated, golden)
	reportLineDifferences(t, generated, golden)
	handleGoldenFileUpdate(t, goldenFile, generatedContent)
	writeTemporaryGeneratedFile(t, goldenFile, generatedContent)
}

func reportFirstDifference(t *testing.T, generated, golden string) {
	t.Helper()

	minLen := len(generated)
	if len(golden) < minLen {
		minLen = len(golden)
	}

	for i := range minLen {
		if generated[i] != golden[i] {
			t.Errorf("First difference at byte position %d", i)
			t.Errorf("Generated byte: %d (%c)", generated[i], generated[i])
			t.Errorf("Golden byte: %d (%c)", golden[i], golden[i])
			return
		}
	}
}

func reportLineDifferences(t *testing.T, generated, golden string) {
	t.Helper()

	generatedLines := strings.Split(generated, "\n")
	goldenLines := strings.Split(golden, "\n")

	maxLines := len(generatedLines)
	if len(goldenLines) > maxLines {
		maxLines = len(goldenLines)
	}

	diffCount := 0
	for i := 0; i < maxLines && diffCount < 10; i++ { // Limit to first 10 differences
		var generatedLine, goldenLine string
		if i < len(generatedLines) {
			generatedLine = generatedLines[i]
		}
		if i < len(goldenLines) {
			goldenLine = goldenLines[i]
		}

		if generatedLine != goldenLine {
			t.Errorf("Line %d differs:", i+1)
			t.Errorf("  Generated: %q", generatedLine)
			t.Errorf("  Golden:    %q", goldenLine)
			diffCount++
		}
	}

	if diffCount >= 10 {
		t.Errorf("... (showing first 10 differences only)")
	}
}

func handleGoldenFileUpdate(t *testing.T, goldenFile string, generatedContent []byte) {
	t.Helper()

	if os.Getenv("UPDATE_GOLDEN") == "1" {
		if writeErr := os.WriteFile(goldenFile, generatedContent, 0o644); writeErr != nil {
			t.Logf("Failed to update golden file: %v", writeErr)
		} else {
			t.Logf("Updated golden file: %s", goldenFile)
		}
	} else {
		t.Log("To update golden files, run: UPDATE_GOLDEN=1 go test -run TestExhaustiveGoldenFiles")
	}
}

func writeTemporaryGeneratedFile(t *testing.T, goldenFile string, generatedContent []byte) {
	t.Helper()

	tempGenFile := goldenFile + ".generated"
	if writeErr := os.WriteFile(tempGenFile, generatedContent, 0o644); writeErr == nil {
		t.Logf("Generated content written to: %s", tempGenFile)
		t.Logf("Compare with: diff %s %s", goldenFile, tempGenFile)
	}
}

// TestExhaustiveGoldenFiles performs exhaustive byte-for-byte comparison
// between generated output and golden files.
func TestExhaustiveGoldenFiles(t *testing.T) {
	// Build the plugin binary for testing
	pluginPath := "./protoc-gen-go-oneof-helper-golden-test"
	buildCmd := exec.Command("go", "build", "-o", pluginPath, "../../cmd/protoc-gen-go-oneof-helper")
	if err := buildCmd.Run(); err != nil {
		t.Fatalf("Failed to build plugin: %v", err)
	}
	// defer os.Remove(pluginPath)

	testCases := []struct {
		name       string
		protoFile  string
		goldenFile string
	}{
		{
			name:       "simple_oneof",
			protoFile:  "testdata/proto/simple_oneof.proto",
			goldenFile: "testdata/golden/simple_oneof_helpers.pb.go",
		},
		{
			name:       "complex_types",
			protoFile:  "testdata/proto/complex_types.proto",
			goldenFile: "testdata/golden/complex_types_helpers.pb.go",
		},
		{
			name:       "nested_messages",
			protoFile:  "testdata/proto/nested_messages.proto",
			goldenFile: "testdata/golden/nested_messages_helpers.pb.go",
		},
		{
			name:       "no_oneof",
			protoFile:  "testdata/proto/no_oneof.proto",
			goldenFile: "testdata/golden/no_oneof_helpers.pb.go",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Generate fresh output using protoc
			tempDir := t.TempDir()

			// Run protoc to generate new output
			cmd := exec.Command("protoc",
				"--plugin=protoc-gen-go-oneof-helper="+pluginPath,
				"--go-helpers_out="+tempDir,
				"--proto_path=testdata/proto",
				tc.protoFile,
			)

			var stdout, stderr bytes.Buffer
			cmd.Stdout = &stdout
			cmd.Stderr = &stderr

			if runErr := cmd.Run(); runErr != nil {
				t.Fatalf("protoc failed for %s: %v\nStdout: %s\nStderr: %s",
					tc.name, runErr, stdout.String(), stderr.String())
			}

			// Find the generated file
			baseName := strings.TrimSuffix(filepath.Base(tc.protoFile), ".proto")
			generatedFile := filepath.Join(tempDir, "github.com", "anghami", "anghamak-go",
				"cmd", "protoc-gen-go-oneof-helper", "testdata", baseName+"_helpers.pb.go")

			// Read generated content
			generatedContent, err := os.ReadFile(generatedFile)
			if err != nil {
				t.Fatalf("Failed to read generated file: %v", err)
			}

			// Read golden file content
			goldenContent, err := os.ReadFile(tc.goldenFile)
			if err != nil {
				t.Fatalf("Failed to read golden file %s: %v", tc.goldenFile, err)
			}

			// Perform exhaustive byte-for-byte comparison
			if !bytes.Equal(generatedContent, goldenContent) {
				reportGoldenFileMismatch(t, tc.name, tc.goldenFile, generatedContent, goldenContent)
			} else {
				t.Logf("âœ“ Perfect match for %s (%d bytes)", tc.name, len(generatedContent))
			}
		})
	}
}

// TestExhaustiveRegression tests that any change to the implementation
// is detected by comparing against multiple golden files.
func TestExhaustiveRegression(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping exhaustive regression test in short mode")
	}

	// Build the plugin
	pluginPath := "./protoc-gen-go-oneof-helper-regression-test"
	buildCmd := exec.Command("go", "build", "-o", pluginPath, "../../cmd/protoc-gen-go-oneof-helper")
	if err := buildCmd.Run(); err != nil {
		t.Fatalf("Failed to build plugin: %v", err)
	}
	defer os.Remove(pluginPath)

	// Test all proto files in testdata/proto
	protoFiles, err := filepath.Glob("testdata/proto/*.proto")
	if err != nil {
		t.Fatalf("Failed to find proto files: %v", err)
	}

	if len(protoFiles) == 0 {
		t.Fatal("No proto files found in testdata/proto")
	}

	for _, protoFile := range protoFiles {
		baseName := strings.TrimSuffix(filepath.Base(protoFile), ".proto")
		goldenFile := fmt.Sprintf("testdata/golden/%s_helpers.pb.go", baseName)

		// Check if golden file exists
		if _, statErr := os.Stat(goldenFile); os.IsNotExist(statErr) {
			t.Errorf("Golden file missing for %s: %s", protoFile, goldenFile)
			continue
		}

		t.Run(baseName, func(t *testing.T) {
			// Generate output
			tempDir := t.TempDir()

			cmd := exec.Command("protoc",
				"--plugin=protoc-gen-go-oneof-helper="+pluginPath,
				"--go-helpers_out="+tempDir,
				"--proto_path=testdata/proto",
				protoFile,
			)

			if runErr := cmd.Run(); runErr != nil {
				t.Fatalf("protoc failed for %s: %v", protoFile, runErr)
			}

			// Find generated file
			generatedFile := filepath.Join(tempDir, "github.com", "anghami", "anghamak-go",
				"cmd", "protoc-gen-go-oneof-helper", "testdata", baseName+"_helpers.pb.go")

			// Compare with golden file
			generatedContent, genErr := os.ReadFile(generatedFile)
			if genErr != nil {
				t.Fatalf("Failed to read generated file: %v", genErr)
			}

			goldenContent, goldenErr := os.ReadFile(goldenFile)
			if goldenErr != nil {
				t.Fatalf("Failed to read golden file: %v", goldenErr)
			}

			if !bytes.Equal(generatedContent, goldenContent) {
				t.Errorf("Regression detected in %s", protoFile)
				t.Errorf("Generated output differs from golden file")

				// Show a summary of the difference
				genLines := strings.Split(string(generatedContent), "\n")
				goldenLines := strings.Split(string(goldenContent), "\n")
				t.Errorf("Generated: %d lines, Golden: %d lines", len(genLines), len(goldenLines))
			}
		})
	}
}

// TestGoldenFileValidity ensures all golden files are valid Go code.
func TestGoldenFileValidity(t *testing.T) {
	goldenFiles, err := filepath.Glob("testdata/golden/*.go")
	if err != nil {
		t.Fatalf("Failed to find golden files: %v", err)
	}

	for _, goldenFile := range goldenFiles {
		t.Run(filepath.Base(goldenFile), func(t *testing.T) {
			// Check if file is syntactically valid Go
			cmd := exec.Command("go", "fmt", goldenFile)
			if runErr := cmd.Run(); runErr != nil {
				t.Errorf("Golden file %s is not valid Go code: %v", goldenFile, runErr)
			}

			// Read content and perform basic validation
			content, readErr := os.ReadFile(goldenFile)
			if readErr != nil {
				t.Fatalf("Failed to read golden file: %v", readErr)
			}

			contentStr := string(content)

			// Must have generation comment
			if !strings.Contains(contentStr, "Code generated by protoc-gen-go-helpers. DO NOT EDIT.") {
				t.Error("Golden file missing generation comment")
			}

			// Must have package declaration
			if !strings.Contains(contentStr, "package testdata") {
				t.Error("Golden file missing or incorrect package declaration")
			}

			// Should not have syntax errors (basic check)
			if strings.Contains(contentStr, "func New") {
				// Files with functions should have proper Go syntax
				lines := strings.Split(contentStr, "\n")
				braceCount := 0
				for i, line := range lines {
					braceCount += strings.Count(line, "{")
					braceCount -= strings.Count(line, "}")
					if braceCount < 0 {
						t.Errorf("Unmatched closing brace at line %d: %s", i+1, line)
						break
					}
				}
				if braceCount != 0 {
					t.Errorf("Unmatched braces in file (count: %d)", braceCount)
				}
			}
		})
	}
}

// BenchmarkExhaustiveComparison benchmarks the golden file comparison process.
func BenchmarkExhaustiveComparison(b *testing.B) {
	// Read a sample golden file
	goldenFile := "testdata/golden/simple_oneof_helpers.pb.go"
	goldenContent, err := os.ReadFile(goldenFile)
	if err != nil {
		b.Fatalf("Failed to read golden file: %v", err)
	}

	// Create identical content for comparison
	generatedContent := make([]byte, len(goldenContent))
	copy(generatedContent, goldenContent)

	b.ResetTimer()
	for range b.N {
		_ = bytes.Equal(generatedContent, goldenContent)
	}
}
