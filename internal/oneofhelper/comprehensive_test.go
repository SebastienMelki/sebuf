package oneofhelper_test

import (
	"strings"
	"testing"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"

	"github.com/SebastienMelki/sebuf/internal/oneofhelper"
)

func TestMainFunctionalities(t *testing.T) {
	t.Run("lowerFirst", func(t *testing.T) {
		tests := []struct {
			input    string
			expected string
		}{
			{"", ""},
			{"A", "a"},
			{"UserName", "userName"},
			{"API", "aPI"},
			{"userName", "userName"},
		}

		for _, tt := range tests {
			result := oneofhelper.LowerFirst(tt.input)
			if result != tt.expected {
				t.Errorf("lowerFirst(%q) = %q, want %q", tt.input, result, tt.expected)
			}
		}
	})

	t.Run("integration with real proto generation", func(t *testing.T) {
		// Test the actual main workflow with a simple proto definition
		req := &pluginpb.CodeGeneratorRequest{
			FileToGenerate: []string{"test.proto"},
			ProtoFile: []*descriptorpb.FileDescriptorProto{
				{
					Name:    proto.String("test.proto"),
					Package: proto.String("test"),
					Syntax:  proto.String("proto3"),
					MessageType: []*descriptorpb.DescriptorProto{
						{
							Name: proto.String("LoginMethod"),
							NestedType: []*descriptorpb.DescriptorProto{
								{
									Name: proto.String("WithEmail"),
									Field: []*descriptorpb.FieldDescriptorProto{
										{
											Name:   proto.String("email"),
											Number: proto.Int32(1),
											Type:   descriptorpb.FieldDescriptorProto_TYPE_STRING.Enum(),
										},
										{
											Name:   proto.String("otp"),
											Number: proto.Int32(2),
											Type:   descriptorpb.FieldDescriptorProto_TYPE_STRING.Enum(),
										},
									},
								},
							},
							OneofDecl: []*descriptorpb.OneofDescriptorProto{
								{
									Name: proto.String("method"),
								},
							},
							Field: []*descriptorpb.FieldDescriptorProto{
								{
									Name:       proto.String("email"),
									Number:     proto.Int32(1),
									Type:       descriptorpb.FieldDescriptorProto_TYPE_MESSAGE.Enum(),
									TypeName:   proto.String(".test.LoginMethod.WithEmail"),
									OneofIndex: proto.Int32(0),
									JsonName:   proto.String("email"),
								},
							},
						},
					},
					Options: &descriptorpb.FileOptions{
						GoPackage: proto.String("example.com/test"),
					},
				},
			},
		}

		// Process with protogen
		opts := protogen.Options{}
		plugin, err := opts.New(req)
		if err != nil {
			t.Fatalf("Failed to create protogen plugin: %v", err)
		}

		if len(plugin.Files) == 0 {
			t.Fatal("No files found in plugin")
		}

		file := plugin.Files[0]
		if !file.Generate {
			file.Generate = true
		}

		// Generate helpers
		oneofhelper.GenerateHelpers(plugin, file)

		// Get the response
		resp := plugin.Response()
		if len(resp.GetFile()) == 0 {
			t.Fatal("No files generated")
		}

		generatedFile := resp.GetFile()[0]
		content := generatedFile.GetContent()

		// Verify basic structure
		if !strings.Contains(content, "package test") {
			t.Error("Generated content should contain package declaration")
		}

		if !strings.Contains(content, "Code generated by protoc-gen-go-oneof-helper") {
			t.Error("Generated content should contain generation notice")
		}

		// Check that a helper function was generated
		if !strings.Contains(content, "func NewLoginMethodEmail") {
			t.Error("Generated content should contain NewLoginMethodEmail function")
		}

		// Verify the function has the expected parameters
		if !strings.Contains(content, "email string, otp string") {
			t.Error("NewLoginMethodEmail should have expected parameters")
		}
	})

	t.Run("generateHelpers creates file with correct name", func(t *testing.T) {
		req := &pluginpb.CodeGeneratorRequest{
			FileToGenerate: []string{"example.proto"},
			ProtoFile: []*descriptorpb.FileDescriptorProto{
				{
					Name:        proto.String("example.proto"),
					Package:     proto.String("example"),
					Syntax:      proto.String("proto3"),
					MessageType: []*descriptorpb.DescriptorProto{},
					Options: &descriptorpb.FileOptions{
						GoPackage: proto.String("example.com/example"),
					},
				},
			},
		}

		opts := protogen.Options{}
		plugin, err := opts.New(req)
		if err != nil {
			t.Fatalf("Failed to create protogen plugin: %v", err)
		}

		file := plugin.Files[0]
		file.Generate = true

		oneofhelper.GenerateHelpers(plugin, file)

		resp := plugin.Response()
		if len(resp.GetFile()) == 0 {
			t.Fatal("No files generated")
		}

		generatedFile := resp.GetFile()[0]
		fileName := generatedFile.GetName()

		// Should generate a file with _helpers.pb.go suffix
		if !strings.HasSuffix(fileName, "_helpers.pb.go") {
			t.Errorf("Generated file name %q should end with '_helpers.pb.go'", fileName)
		}
	})
}

func TestEndToEndWorkflow(t *testing.T) {
	// This test verifies that the complete workflow works as expected
	// with a more complex proto structure
	req := &pluginpb.CodeGeneratorRequest{
		FileToGenerate: []string{"complex.proto"},
		ProtoFile: []*descriptorpb.FileDescriptorProto{
			{
				Name:    proto.String("complex.proto"),
				Package: proto.String("complex"),
				Syntax:  proto.String("proto3"),
				MessageType: []*descriptorpb.DescriptorProto{
					{
						Name: proto.String("Authentication"),
						NestedType: []*descriptorpb.DescriptorProto{
							{
								Name: proto.String("OAuth"),
								Field: []*descriptorpb.FieldDescriptorProto{
									{
										Name:   proto.String("token"),
										Number: proto.Int32(1),
										Type:   descriptorpb.FieldDescriptorProto_TYPE_STRING.Enum(),
									},
									{
										Name:   proto.String("refresh_token"),
										Number: proto.Int32(2),
										Type:   descriptorpb.FieldDescriptorProto_TYPE_STRING.Enum(),
									},
								},
							},
							{
								Name: proto.String("ApiKey"),
								Field: []*descriptorpb.FieldDescriptorProto{
									{
										Name:   proto.String("key"),
										Number: proto.Int32(1),
										Type:   descriptorpb.FieldDescriptorProto_TYPE_STRING.Enum(),
									},
								},
							},
						},
						OneofDecl: []*descriptorpb.OneofDescriptorProto{
							{
								Name: proto.String("auth_method"),
							},
						},
						Field: []*descriptorpb.FieldDescriptorProto{
							{
								Name:       proto.String("oauth"),
								Number:     proto.Int32(1),
								Type:       descriptorpb.FieldDescriptorProto_TYPE_MESSAGE.Enum(),
								TypeName:   proto.String(".complex.Authentication.OAuth"),
								OneofIndex: proto.Int32(0),
								JsonName:   proto.String("oauth"),
							},
							{
								Name:       proto.String("api_key"),
								Number:     proto.Int32(2),
								Type:       descriptorpb.FieldDescriptorProto_TYPE_MESSAGE.Enum(),
								TypeName:   proto.String(".complex.Authentication.ApiKey"),
								OneofIndex: proto.Int32(0),
								JsonName:   proto.String("apiKey"),
							},
						},
					},
				},
				Options: &descriptorpb.FileOptions{
					GoPackage: proto.String("example.com/complex"),
				},
			},
		},
	}

	opts := protogen.Options{}
	plugin, err := opts.New(req)
	if err != nil {
		t.Fatalf("Failed to create protogen plugin: %v", err)
	}

	file := plugin.Files[0]
	file.Generate = true

	oneofhelper.GenerateHelpers(plugin, file)

	resp := plugin.Response()
	if len(resp.GetFile()) == 0 {
		t.Fatal("No files generated")
	}

	generatedFile := resp.GetFile()[0]
	content := generatedFile.GetContent()

	// Verify multiple helper functions are generated
	expectedFunctions := []string{
		"func NewAuthenticationOauth(",
		"func NewAuthenticationApiKey(",
	}

	for _, expectedFunc := range expectedFunctions {
		if !strings.Contains(content, expectedFunc) {
			t.Errorf("Generated content should contain %s", expectedFunc)
		}
	}

	// Verify parameters are correctly converted to camelCase
	if !strings.Contains(content, "token string, refreshToken string") {
		t.Error("OAuth function should have camelCase parameters")
	}

	if !strings.Contains(content, "key string") {
		t.Error("ApiKey function should have key parameter")
	}
}
