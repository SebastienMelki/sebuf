package tsservergen

import (
	"bytes"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

// TestCrossGeneratorTypeConsistency verifies that message interfaces and enum types
// generated by protoc-gen-ts-server match those generated by protoc-gen-ts-client.
// This ensures the shared tscommon package produces identical types in both generators.
func TestCrossGeneratorTypeConsistency(t *testing.T) {
	if _, err := exec.LookPath("protoc"); err != nil {
		t.Skip("protoc not found, skipping cross-generator tests")
	}

	testProtos := []string{
		"http_verbs_comprehensive.proto",
		"query_params.proto",
		"complex_features.proto",
		"unwrap.proto",
		"int64_encoding.proto",
		"enum_encoding.proto",
		"nullable.proto",
		"empty_behavior.proto",
		"timestamp_format.proto",
		"bytes_encoding.proto",
		"flatten.proto",
		"oneof_discriminator.proto",
	}

	baseDir, err := os.Getwd()
	if err != nil {
		t.Fatalf("Failed to get working directory: %v", err)
	}

	projectRoot := filepath.Join(baseDir, "..", "..")
	protoDir := filepath.Join(baseDir, "testdata", "proto")

	serverPluginPath := filepath.Join(projectRoot, "bin", "protoc-gen-ts-server")
	clientPluginPath := filepath.Join(projectRoot, "bin", "protoc-gen-ts-client")

	// Build plugins if they don't exist
	for _, pluginPath := range []string{serverPluginPath, clientPluginPath} {
		if _, statErr := os.Stat(pluginPath); os.IsNotExist(statErr) {
			buildCmd := exec.Command("make", "build")
			buildCmd.Dir = projectRoot
			if buildErr := buildCmd.Run(); buildErr != nil {
				t.Fatalf("Failed to build plugins: %v", buildErr)
			}
			break
		}
	}

	serverDir := t.TempDir()
	clientDir := t.TempDir()

	for _, proto := range testProtos {
		t.Run(proto, func(t *testing.T) {
			// Generate server
			serverCmd := exec.Command("protoc",
				"--plugin=protoc-gen-ts-server="+serverPluginPath,
				"--ts-server_out="+serverDir,
				"--ts-server_opt=paths=source_relative",
				"--proto_path="+protoDir,
				"--proto_path="+filepath.Join(projectRoot, "proto"),
				proto,
			)
			serverCmd.Dir = protoDir
			var serverStderr bytes.Buffer
			serverCmd.Stderr = &serverStderr
			if runErr := serverCmd.Run(); runErr != nil {
				t.Fatalf("protoc ts-server failed: %v\nstderr: %s", runErr, serverStderr.String())
			}

			// Generate client
			clientCmd := exec.Command("protoc",
				"--plugin=protoc-gen-ts-client="+clientPluginPath,
				"--ts-client_out="+clientDir,
				"--ts-client_opt=paths=source_relative",
				"--proto_path="+protoDir,
				"--proto_path="+filepath.Join(projectRoot, "proto"),
				proto,
			)
			clientCmd.Dir = protoDir
			var clientStderr bytes.Buffer
			clientCmd.Stderr = &clientStderr
			if runErr := clientCmd.Run(); runErr != nil {
				t.Fatalf("protoc ts-client failed: %v\nstderr: %s", runErr, clientStderr.String())
			}

			// Read generated files
			baseName := strings.TrimSuffix(proto, ".proto")
			serverContent, readErr := os.ReadFile(filepath.Join(serverDir, baseName+"_server.ts"))
			if readErr != nil {
				t.Fatalf("Failed to read server file: %v", readErr)
			}
			clientContent, readErr := os.ReadFile(filepath.Join(clientDir, baseName+"_client.ts"))
			if readErr != nil {
				t.Fatalf("Failed to read client file: %v", readErr)
			}

			// Extract type sections (interfaces, enums, error types) from both
			serverTypes := extractTypeSection(string(serverContent))
			clientTypes := extractTypeSection(string(clientContent))

			if serverTypes != clientTypes {
				t.Errorf("Type sections differ between server and client for %s.\n"+
					"Server types:\n%s\n\nClient types:\n%s",
					proto, serverTypes, clientTypes)
			}
		})
	}
}

// extractTypeSection extracts the message interfaces, enum types, and error types
// from generated TypeScript code (everything before the service-specific code).
func extractTypeSection(content string) string {
	lines := strings.Split(content, "\n")
	var result []string
	inTypes := false

	for _, line := range lines {
		// Skip header comment
		if strings.HasPrefix(line, "// Code generated") || strings.HasPrefix(line, "// source:") {
			continue
		}
		// Skip empty lines at the start
		if !inTypes && strings.TrimSpace(line) == "" {
			continue
		}

		// Start of type definitions
		if strings.HasPrefix(line, "export interface ") ||
			strings.HasPrefix(line, "export type ") ||
			strings.HasPrefix(line, "export class ") {
			inTypes = true
		}

		// End of shared types: server-specific or client-specific code starts
		if strings.HasPrefix(line, "export interface ServerContext") ||
			strings.HasPrefix(line, "export interface ServerOptions") ||
			strings.HasPrefix(line, "export interface RouteDescriptor") ||
			strings.Contains(line, "ClientOptions") ||
			strings.Contains(line, "CallOptions") ||
			strings.Contains(line, "Client {") ||
			strings.Contains(line, "Handler {") {
			break
		}

		if inTypes {
			result = append(result, line)
		}
	}

	return strings.Join(result, "\n")
}
