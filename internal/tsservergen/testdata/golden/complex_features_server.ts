// Code generated by protoc-gen-ts-server. DO NOT EDIT.
// source: complex_features.proto

export interface ListNotesRequest {
  page: number;
  pageSize: number;
  filter: string;
}

export interface ListNotesResponse {
  notes: Note[];
  totalCount: number;
}

export interface Note {
  id: string;
  title: string;
  content: string;
  priority: Priority;
  status: Status;
  tags: Tag[];
  metadata: Record<string, string>;
  dueDate?: string;
  address?: Address;
}

export interface Tag {
  name: string;
  color: string;
}

export interface Address {
  street: string;
  city: string;
  zipCode: string;
}

export interface GetNoteRequest {
  noteId: string;
}

export interface CreateNoteRequest {
  title: string;
  content: string;
  priority: Priority;
  status: Status;
  tags: Tag[];
  metadata: Record<string, string>;
  dueDate?: string;
  address?: Address;
}

export interface UpdateNoteRequest {
  noteId: string;
  title: string;
  content: string;
  priority: Priority;
}

export interface GetNoteListRequest {
  category: string;
}

export interface NoteList {
  notes: Note[];
}

export interface GetNoteMapRequest {
  ownerId: string;
}

export interface NoteMap {
  notes: Record<string, Note>;
}

export interface GetBarsBySymbolRequest {
  symbols: string[];
}

export interface BarsBySymbol {
  data: Record<string, Bar[]>;
}

export interface BarWrapper {
  bars: Bar[];
}

export interface Bar {
  symbol: string;
  price: number;
  volume: string;
}

export interface GetCombinedUnwrapRequest {
  market: string;
}

export interface CombinedUnwrap {
  data: Record<string, Bar[]>;
}

export type Priority = "PRIORITY_UNSPECIFIED" | "PRIORITY_LOW" | "PRIORITY_MEDIUM" | "PRIORITY_HIGH" | "PRIORITY_URGENT";

export type Status = "STATUS_UNSPECIFIED" | "STATUS_PENDING" | "STATUS_IN_PROGRESS" | "STATUS_DONE" | "STATUS_ARCHIVED";

export interface FieldViolation {
  field: string;
  description: string;
}

export class ValidationError extends Error {
  violations: FieldViolation[];

  constructor(violations: FieldViolation[]) {
    super("Validation failed");
    this.name = "ValidationError";
    this.violations = violations;
  }
}

export class ApiError extends Error {
  statusCode: number;
  body: string;

  constructor(statusCode: number, message: string, body: string) {
    super(message);
    this.name = "ApiError";
    this.statusCode = statusCode;
    this.body = body;
  }
}

export interface ServerContext {
  request: Request;
  pathParams: Record<string, string>;
  headers: Record<string, string>;
}

export interface ServerOptions {
  onError?: (error: unknown, req: Request) => Response | Promise<Response>;
  validateRequest?: (methodName: string, body: unknown) => FieldViolation[] | undefined;
}

export interface RouteDescriptor {
  method: string;
  path: string;
  handler: (req: Request) => Promise<Response>;
}

const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

const DATETIME_REGEX = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.[\d]+)?(Z|[+-]\d{2}:\d{2})$/;

const DATE_REGEX = /^\d{4}-\d{2}-\d{2}$/;

const TIME_REGEX = /^\d{2}:\d{2}:\d{2}(\.[\d]+)?$/;

interface HeaderConfig {
  name: string;
  type: string;
  required: boolean;
  format?: string;
}

function validateHeaderValue(value: string, config: HeaderConfig): string | undefined {
  switch (config.type) {
    case "integer":
      if (!/^-?\d+$/.test(value)) return "must be an integer";
      break;
    case "number":
      if (isNaN(Number(value))) return "must be a number";
      break;
    case "boolean":
      if (value !== "true" && value !== "false" && value !== "1" && value !== "0")
        return "must be a boolean";
      break;
  }
  if (config.format) {
    switch (config.format) {
      case "uuid":
        if (!UUID_REGEX.test(value)) return "must be a valid UUID";
        break;
      case "email":
        if (!EMAIL_REGEX.test(value)) return "must be a valid email";
        break;
      case "date-time":
        if (!DATETIME_REGEX.test(value)) return "must be a valid date-time";
        break;
      case "date":
        if (!DATE_REGEX.test(value)) return "must be a valid date";
        break;
      case "time":
        if (!TIME_REGEX.test(value)) return "must be a valid time";
        break;
    }
  }
  return undefined;
}

function validateHeaders(
  req: Request,
  configs: HeaderConfig[],
): FieldViolation[] | undefined {
  const violations: FieldViolation[] = [];
  for (const config of configs) {
    const value = req.headers.get(config.name);
    if (value == null) {
      if (config.required) {
        violations.push({
          field: config.name,
          description: "required header is missing",
        });
      }
      continue;
    }
    const err = validateHeaderValue(value, config);
    if (err) {
      violations.push({
        field: config.name,
        description: `header ${config.name}: ${err}`,
      });
    }
  }
  return violations.length > 0 ? violations : undefined;
}

export interface FeatureServiceHandler {
  listNotes(ctx: ServerContext, req: ListNotesRequest): Promise<ListNotesResponse>;
  getNote(ctx: ServerContext, req: GetNoteRequest): Promise<Note>;
  createNote(ctx: ServerContext, req: CreateNoteRequest): Promise<Note>;
  updateNote(ctx: ServerContext, req: UpdateNoteRequest): Promise<Note>;
  getNoteList(ctx: ServerContext, req: GetNoteListRequest): Promise<Note[]>;
  getNoteMap(ctx: ServerContext, req: GetNoteMapRequest): Promise<Record<string, Note>>;
  getBarsBySymbol(ctx: ServerContext, req: GetBarsBySymbolRequest): Promise<BarsBySymbol>;
  getCombinedUnwrap(ctx: ServerContext, req: GetCombinedUnwrapRequest): Promise<Record<string, Bar[]>>;
}

export function createFeatureServiceRoutes(
  handler: FeatureServiceHandler,
  options?: ServerOptions,
): RouteDescriptor[] {
  return [
    {
      method: "GET",
      path: "/api/v1/notes",
      handler: async (req: Request): Promise<Response> => {
        try {
          const headerConfigs: HeaderConfig[] = [
            { name: "X-API-Key", type: "string", required: true, format: "uuid" },
            { name: "X-Tenant-ID", type: "integer", required: true },
          ];
          const headerViolations = validateHeaders(req, headerConfigs);
          if (headerViolations) {
            throw new ValidationError(headerViolations);
          }

          const pathParams: Record<string, string> = {};
          const url = new URL(req.url, "http://localhost");
          const params = url.searchParams;
          const body: ListNotesRequest = {
            page: Number(params.get("page") ?? "0"),
            pageSize: Number(params.get("page_size") ?? "0"),
            filter: params.get("filter") ?? "",
          };
          if (options?.validateRequest) {
            const bodyViolations = options.validateRequest("listNotes", body);
            if (bodyViolations) {
              throw new ValidationError(bodyViolations);
            }
          }

          const ctx: ServerContext = {
            request: req,
            pathParams,
            headers: Object.fromEntries(req.headers.entries()),
          };

          const result = await handler.listNotes(ctx, body);
          return new Response(JSON.stringify(result as ListNotesResponse), {
            status: 200,
            headers: { "Content-Type": "application/json" },
          });
        } catch (err: unknown) {
          if (err instanceof ValidationError) {
            return new Response(JSON.stringify({ violations: err.violations }), {
              status: 400,
              headers: { "Content-Type": "application/json" },
            });
          }
          if (options?.onError) {
            return options.onError(err, req);
          }
          const message = err instanceof Error ? err.message : String(err);
          return new Response(JSON.stringify({ message }), {
            status: 500,
            headers: { "Content-Type": "application/json" },
          });
        }
      },
    },
    {
      method: "GET",
      path: "/api/v1/notes/{note_id}",
      handler: async (req: Request): Promise<Response> => {
        try {
          const headerConfigs: HeaderConfig[] = [
            { name: "X-API-Key", type: "string", required: true, format: "uuid" },
            { name: "X-Tenant-ID", type: "integer", required: true },
          ];
          const headerViolations = validateHeaders(req, headerConfigs);
          if (headerViolations) {
            throw new ValidationError(headerViolations);
          }

          const pathParams: Record<string, string> = {};
          const url = new URL(req.url, "http://localhost");
          const pathSegments = url.pathname.split("/");
          pathParams["note_id"] = decodeURIComponent(pathSegments[4] ?? "");

          const body = {} as GetNoteRequest;

          body.noteId = pathParams["note_id"];

          const ctx: ServerContext = {
            request: req,
            pathParams,
            headers: Object.fromEntries(req.headers.entries()),
          };

          const result = await handler.getNote(ctx, body);
          return new Response(JSON.stringify(result as Note), {
            status: 200,
            headers: { "Content-Type": "application/json" },
          });
        } catch (err: unknown) {
          if (err instanceof ValidationError) {
            return new Response(JSON.stringify({ violations: err.violations }), {
              status: 400,
              headers: { "Content-Type": "application/json" },
            });
          }
          if (options?.onError) {
            return options.onError(err, req);
          }
          const message = err instanceof Error ? err.message : String(err);
          return new Response(JSON.stringify({ message }), {
            status: 500,
            headers: { "Content-Type": "application/json" },
          });
        }
      },
    },
    {
      method: "POST",
      path: "/api/v1/notes",
      handler: async (req: Request): Promise<Response> => {
        try {
          const headerConfigs: HeaderConfig[] = [
            { name: "X-API-Key", type: "string", required: true, format: "uuid" },
            { name: "X-Tenant-ID", type: "integer", required: true },
            { name: "X-Request-ID", type: "string", required: true, format: "uuid" },
          ];
          const headerViolations = validateHeaders(req, headerConfigs);
          if (headerViolations) {
            throw new ValidationError(headerViolations);
          }

          const pathParams: Record<string, string> = {};
          const body = await req.json() as CreateNoteRequest;
          if (options?.validateRequest) {
            const bodyViolations = options.validateRequest("createNote", body);
            if (bodyViolations) {
              throw new ValidationError(bodyViolations);
            }
          }

          const ctx: ServerContext = {
            request: req,
            pathParams,
            headers: Object.fromEntries(req.headers.entries()),
          };

          const result = await handler.createNote(ctx, body);
          return new Response(JSON.stringify(result as Note), {
            status: 200,
            headers: { "Content-Type": "application/json" },
          });
        } catch (err: unknown) {
          if (err instanceof ValidationError) {
            return new Response(JSON.stringify({ violations: err.violations }), {
              status: 400,
              headers: { "Content-Type": "application/json" },
            });
          }
          if (options?.onError) {
            return options.onError(err, req);
          }
          const message = err instanceof Error ? err.message : String(err);
          return new Response(JSON.stringify({ message }), {
            status: 500,
            headers: { "Content-Type": "application/json" },
          });
        }
      },
    },
    {
      method: "PUT",
      path: "/api/v1/notes/{note_id}",
      handler: async (req: Request): Promise<Response> => {
        try {
          const headerConfigs: HeaderConfig[] = [
            { name: "X-API-Key", type: "string", required: true, format: "uuid" },
            { name: "X-Tenant-ID", type: "integer", required: true },
            { name: "X-Idempotency-Key", type: "string", required: true, format: "uuid" },
          ];
          const headerViolations = validateHeaders(req, headerConfigs);
          if (headerViolations) {
            throw new ValidationError(headerViolations);
          }

          const pathParams: Record<string, string> = {};
          const url = new URL(req.url, "http://localhost");
          const pathSegments = url.pathname.split("/");
          pathParams["note_id"] = decodeURIComponent(pathSegments[4] ?? "");

          const body = await req.json() as UpdateNoteRequest;
          if (options?.validateRequest) {
            const bodyViolations = options.validateRequest("updateNote", body);
            if (bodyViolations) {
              throw new ValidationError(bodyViolations);
            }
          }

          body.noteId = pathParams["note_id"];

          const ctx: ServerContext = {
            request: req,
            pathParams,
            headers: Object.fromEntries(req.headers.entries()),
          };

          const result = await handler.updateNote(ctx, body);
          return new Response(JSON.stringify(result as Note), {
            status: 200,
            headers: { "Content-Type": "application/json" },
          });
        } catch (err: unknown) {
          if (err instanceof ValidationError) {
            return new Response(JSON.stringify({ violations: err.violations }), {
              status: 400,
              headers: { "Content-Type": "application/json" },
            });
          }
          if (options?.onError) {
            return options.onError(err, req);
          }
          const message = err instanceof Error ? err.message : String(err);
          return new Response(JSON.stringify({ message }), {
            status: 500,
            headers: { "Content-Type": "application/json" },
          });
        }
      },
    },
    {
      method: "POST",
      path: "/api/v1/notes/list",
      handler: async (req: Request): Promise<Response> => {
        try {
          const headerConfigs: HeaderConfig[] = [
            { name: "X-API-Key", type: "string", required: true, format: "uuid" },
            { name: "X-Tenant-ID", type: "integer", required: true },
          ];
          const headerViolations = validateHeaders(req, headerConfigs);
          if (headerViolations) {
            throw new ValidationError(headerViolations);
          }

          const pathParams: Record<string, string> = {};
          const body = await req.json() as GetNoteListRequest;
          if (options?.validateRequest) {
            const bodyViolations = options.validateRequest("getNoteList", body);
            if (bodyViolations) {
              throw new ValidationError(bodyViolations);
            }
          }

          const ctx: ServerContext = {
            request: req,
            pathParams,
            headers: Object.fromEntries(req.headers.entries()),
          };

          const result = await handler.getNoteList(ctx, body);
          return new Response(JSON.stringify(result as Note[]), {
            status: 200,
            headers: { "Content-Type": "application/json" },
          });
        } catch (err: unknown) {
          if (err instanceof ValidationError) {
            return new Response(JSON.stringify({ violations: err.violations }), {
              status: 400,
              headers: { "Content-Type": "application/json" },
            });
          }
          if (options?.onError) {
            return options.onError(err, req);
          }
          const message = err instanceof Error ? err.message : String(err);
          return new Response(JSON.stringify({ message }), {
            status: 500,
            headers: { "Content-Type": "application/json" },
          });
        }
      },
    },
    {
      method: "POST",
      path: "/api/v1/notes/map",
      handler: async (req: Request): Promise<Response> => {
        try {
          const headerConfigs: HeaderConfig[] = [
            { name: "X-API-Key", type: "string", required: true, format: "uuid" },
            { name: "X-Tenant-ID", type: "integer", required: true },
          ];
          const headerViolations = validateHeaders(req, headerConfigs);
          if (headerViolations) {
            throw new ValidationError(headerViolations);
          }

          const pathParams: Record<string, string> = {};
          const body = await req.json() as GetNoteMapRequest;
          if (options?.validateRequest) {
            const bodyViolations = options.validateRequest("getNoteMap", body);
            if (bodyViolations) {
              throw new ValidationError(bodyViolations);
            }
          }

          const ctx: ServerContext = {
            request: req,
            pathParams,
            headers: Object.fromEntries(req.headers.entries()),
          };

          const result = await handler.getNoteMap(ctx, body);
          return new Response(JSON.stringify(result as Record<string, Note>), {
            status: 200,
            headers: { "Content-Type": "application/json" },
          });
        } catch (err: unknown) {
          if (err instanceof ValidationError) {
            return new Response(JSON.stringify({ violations: err.violations }), {
              status: 400,
              headers: { "Content-Type": "application/json" },
            });
          }
          if (options?.onError) {
            return options.onError(err, req);
          }
          const message = err instanceof Error ? err.message : String(err);
          return new Response(JSON.stringify({ message }), {
            status: 500,
            headers: { "Content-Type": "application/json" },
          });
        }
      },
    },
    {
      method: "POST",
      path: "/api/v1/bars",
      handler: async (req: Request): Promise<Response> => {
        try {
          const headerConfigs: HeaderConfig[] = [
            { name: "X-API-Key", type: "string", required: true, format: "uuid" },
            { name: "X-Tenant-ID", type: "integer", required: true },
          ];
          const headerViolations = validateHeaders(req, headerConfigs);
          if (headerViolations) {
            throw new ValidationError(headerViolations);
          }

          const pathParams: Record<string, string> = {};
          const body = await req.json() as GetBarsBySymbolRequest;
          if (options?.validateRequest) {
            const bodyViolations = options.validateRequest("getBarsBySymbol", body);
            if (bodyViolations) {
              throw new ValidationError(bodyViolations);
            }
          }

          const ctx: ServerContext = {
            request: req,
            pathParams,
            headers: Object.fromEntries(req.headers.entries()),
          };

          const result = await handler.getBarsBySymbol(ctx, body);
          return new Response(JSON.stringify(result as BarsBySymbol), {
            status: 200,
            headers: { "Content-Type": "application/json" },
          });
        } catch (err: unknown) {
          if (err instanceof ValidationError) {
            return new Response(JSON.stringify({ violations: err.violations }), {
              status: 400,
              headers: { "Content-Type": "application/json" },
            });
          }
          if (options?.onError) {
            return options.onError(err, req);
          }
          const message = err instanceof Error ? err.message : String(err);
          return new Response(JSON.stringify({ message }), {
            status: 500,
            headers: { "Content-Type": "application/json" },
          });
        }
      },
    },
    {
      method: "POST",
      path: "/api/v1/bars/combined",
      handler: async (req: Request): Promise<Response> => {
        try {
          const headerConfigs: HeaderConfig[] = [
            { name: "X-API-Key", type: "string", required: true, format: "uuid" },
            { name: "X-Tenant-ID", type: "integer", required: true },
          ];
          const headerViolations = validateHeaders(req, headerConfigs);
          if (headerViolations) {
            throw new ValidationError(headerViolations);
          }

          const pathParams: Record<string, string> = {};
          const body = await req.json() as GetCombinedUnwrapRequest;
          if (options?.validateRequest) {
            const bodyViolations = options.validateRequest("getCombinedUnwrap", body);
            if (bodyViolations) {
              throw new ValidationError(bodyViolations);
            }
          }

          const ctx: ServerContext = {
            request: req,
            pathParams,
            headers: Object.fromEntries(req.headers.entries()),
          };

          const result = await handler.getCombinedUnwrap(ctx, body);
          return new Response(JSON.stringify(result as Record<string, Bar[]>), {
            status: 200,
            headers: { "Content-Type": "application/json" },
          });
        } catch (err: unknown) {
          if (err instanceof ValidationError) {
            return new Response(JSON.stringify({ violations: err.violations }), {
              status: 400,
              headers: { "Content-Type": "application/json" },
            });
          }
          if (options?.onError) {
            return options.onError(err, req);
          }
          const message = err instanceof Error ? err.message : String(err);
          return new Response(JSON.stringify({ message }), {
            status: 500,
            headers: { "Content-Type": "application/json" },
          });
        }
      },
    },
  ];
}

