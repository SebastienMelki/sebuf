// Code generated by protoc-gen-ts-server. DO NOT EDIT.
// source: http_verbs_comprehensive.proto

export interface ListResourcesRequest {
  page: number;
  pageSize: number;
  filter: string;
  includeDeleted: boolean;
  sinceTimestamp: string;
  maxId: string;
  minScore: number;
  maxScore: number;
}

export interface ListResourcesResponse {
  resources: Resource[];
  totalCount: number;
  page: number;
}

export interface Resource {
  id: string;
  name: string;
  description: string;
  metadata: Record<string, string>;
  createdAt: string;
  updatedAt: string;
  status: ResourceStatus;
  metadataDetail?: ResourceMetadata;
  tag?: string;
}

export interface ResourceMetadata {
  createdBy: string;
  createdAtUnix: string;
  version: number;
}

export interface GetResourceRequest {
  resourceId: string;
}

export interface GetNestedResourceRequest {
  orgId: string;
  teamId: string;
  resourceId: string;
}

export interface CreateResourceRequest {
  name: string;
  description: string;
  metadata: Record<string, string>;
}

export interface UpdateResourceRequest {
  resourceId: string;
  name: string;
  description: string;
  metadata: Record<string, string>;
}

export interface PatchResourceRequest {
  resourceId: string;
  name: string;
  description: string;
}

export interface DeleteResourceRequest {
  resourceId: string;
}

export interface DeleteResourceResponse {
  success: boolean;
}

export interface DefaultPostRequest {
  action: string;
}

export interface DefaultPostResponse {
  result: string;
}

export interface SearchResourcesRequest {
  statusFilter: ResourceStatus;
  query: string;
}

export interface LegacyRequest {
  data: string;
}

export interface LegacyResponse {
  result: string;
}

export type ResourceStatus = "RESOURCE_STATUS_UNSPECIFIED" | "RESOURCE_STATUS_ACTIVE" | "RESOURCE_STATUS_INACTIVE" | "RESOURCE_STATUS_ARCHIVED";

export interface FieldViolation {
  field: string;
  description: string;
}

export class ValidationError extends Error {
  violations: FieldViolation[];

  constructor(violations: FieldViolation[]) {
    super("Validation failed");
    this.name = "ValidationError";
    this.violations = violations;
  }
}

export class ApiError extends Error {
  statusCode: number;
  body: string;

  constructor(statusCode: number, message: string, body: string) {
    super(message);
    this.name = "ApiError";
    this.statusCode = statusCode;
    this.body = body;
  }
}

export interface ServerContext {
  request: Request;
  pathParams: Record<string, string>;
  headers: Record<string, string>;
}

export interface ServerOptions {
  onError?: (error: unknown, req: Request) => Response | Promise<Response>;
  validateRequest?: (methodName: string, body: unknown) => FieldViolation[] | undefined;
}

export interface RouteDescriptor {
  method: string;
  path: string;
  handler: (req: Request) => Promise<Response>;
}

const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

const DATETIME_REGEX = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.[\d]+)?(Z|[+-]\d{2}:\d{2})$/;

const DATE_REGEX = /^\d{4}-\d{2}-\d{2}$/;

const TIME_REGEX = /^\d{2}:\d{2}:\d{2}(\.[\d]+)?$/;

interface HeaderConfig {
  name: string;
  type: string;
  required: boolean;
  format?: string;
}

function validateHeaderValue(value: string, config: HeaderConfig): string | undefined {
  switch (config.type) {
    case "integer":
      if (!/^-?\d+$/.test(value)) return "must be an integer";
      break;
    case "number":
      if (isNaN(Number(value))) return "must be a number";
      break;
    case "boolean":
      if (value !== "true" && value !== "false" && value !== "1" && value !== "0")
        return "must be a boolean";
      break;
  }
  if (config.format) {
    switch (config.format) {
      case "uuid":
        if (!UUID_REGEX.test(value)) return "must be a valid UUID";
        break;
      case "email":
        if (!EMAIL_REGEX.test(value)) return "must be a valid email";
        break;
      case "date-time":
        if (!DATETIME_REGEX.test(value)) return "must be a valid date-time";
        break;
      case "date":
        if (!DATE_REGEX.test(value)) return "must be a valid date";
        break;
      case "time":
        if (!TIME_REGEX.test(value)) return "must be a valid time";
        break;
    }
  }
  return undefined;
}

function validateHeaders(
  req: Request,
  configs: HeaderConfig[],
): FieldViolation[] | undefined {
  const violations: FieldViolation[] = [];
  for (const config of configs) {
    const value = req.headers.get(config.name);
    if (value == null) {
      if (config.required) {
        violations.push({
          field: config.name,
          description: "required header is missing",
        });
      }
      continue;
    }
    const err = validateHeaderValue(value, config);
    if (err) {
      violations.push({
        field: config.name,
        description: `header ${config.name}: ${err}`,
      });
    }
  }
  return violations.length > 0 ? violations : undefined;
}

export interface RESTfulAPIServiceHandler {
  listResources(ctx: ServerContext, req: ListResourcesRequest): Promise<ListResourcesResponse>;
  getResource(ctx: ServerContext, req: GetResourceRequest): Promise<Resource>;
  getNestedResource(ctx: ServerContext, req: GetNestedResourceRequest): Promise<Resource>;
  createResource(ctx: ServerContext, req: CreateResourceRequest): Promise<Resource>;
  updateResource(ctx: ServerContext, req: UpdateResourceRequest): Promise<Resource>;
  patchResource(ctx: ServerContext, req: PatchResourceRequest): Promise<Resource>;
  deleteResource(ctx: ServerContext, req: DeleteResourceRequest): Promise<DeleteResourceResponse>;
  defaultPostMethod(ctx: ServerContext, req: DefaultPostRequest): Promise<DefaultPostResponse>;
  searchResources(ctx: ServerContext, req: SearchResourcesRequest): Promise<ListResourcesResponse>;
}

export function createRESTfulAPIServiceRoutes(
  handler: RESTfulAPIServiceHandler,
  options?: ServerOptions,
): RouteDescriptor[] {
  return [
    {
      method: "GET",
      path: "/api/v1/resources",
      handler: async (req: Request): Promise<Response> => {
        try {
          const headerConfigs: HeaderConfig[] = [
            { name: "X-API-Key", type: "string", required: true, format: "uuid" },
          ];
          const headerViolations = validateHeaders(req, headerConfigs);
          if (headerViolations) {
            throw new ValidationError(headerViolations);
          }

          const pathParams: Record<string, string> = {};
          const url = new URL(req.url, "http://localhost");
          const params = url.searchParams;
          const body: ListResourcesRequest = {
            page: Number(params.get("page") ?? "0"),
            pageSize: Number(params.get("page_size") ?? "0"),
            filter: params.get("filter") ?? "",
            includeDeleted: params.get("include_deleted") === "true",
            sinceTimestamp: params.get("since_timestamp") ?? "",
            maxId: params.get("max_id") ?? "",
            minScore: Number(params.get("min_score") ?? "0"),
            maxScore: Number(params.get("max_score") ?? "0"),
          };
          if (options?.validateRequest) {
            const bodyViolations = options.validateRequest("listResources", body);
            if (bodyViolations) {
              throw new ValidationError(bodyViolations);
            }
          }

          const ctx: ServerContext = {
            request: req,
            pathParams,
            headers: Object.fromEntries(req.headers.entries()),
          };

          const result = await handler.listResources(ctx, body);
          return new Response(JSON.stringify(result as ListResourcesResponse), {
            status: 200,
            headers: { "Content-Type": "application/json" },
          });
        } catch (err: unknown) {
          if (err instanceof ValidationError) {
            return new Response(JSON.stringify({ violations: err.violations }), {
              status: 400,
              headers: { "Content-Type": "application/json" },
            });
          }
          if (options?.onError) {
            return options.onError(err, req);
          }
          const message = err instanceof Error ? err.message : String(err);
          return new Response(JSON.stringify({ message }), {
            status: 500,
            headers: { "Content-Type": "application/json" },
          });
        }
      },
    },
    {
      method: "GET",
      path: "/api/v1/resources/{resource_id}",
      handler: async (req: Request): Promise<Response> => {
        try {
          const headerConfigs: HeaderConfig[] = [
            { name: "X-API-Key", type: "string", required: true, format: "uuid" },
          ];
          const headerViolations = validateHeaders(req, headerConfigs);
          if (headerViolations) {
            throw new ValidationError(headerViolations);
          }

          const pathParams: Record<string, string> = {};
          const url = new URL(req.url, "http://localhost");
          const pathSegments = url.pathname.split("/");
          pathParams["resource_id"] = decodeURIComponent(pathSegments[4] ?? "");

          const body = {} as GetResourceRequest;

          body.resourceId = pathParams["resource_id"];

          const ctx: ServerContext = {
            request: req,
            pathParams,
            headers: Object.fromEntries(req.headers.entries()),
          };

          const result = await handler.getResource(ctx, body);
          return new Response(JSON.stringify(result as Resource), {
            status: 200,
            headers: { "Content-Type": "application/json" },
          });
        } catch (err: unknown) {
          if (err instanceof ValidationError) {
            return new Response(JSON.stringify({ violations: err.violations }), {
              status: 400,
              headers: { "Content-Type": "application/json" },
            });
          }
          if (options?.onError) {
            return options.onError(err, req);
          }
          const message = err instanceof Error ? err.message : String(err);
          return new Response(JSON.stringify({ message }), {
            status: 500,
            headers: { "Content-Type": "application/json" },
          });
        }
      },
    },
    {
      method: "GET",
      path: "/api/v1/orgs/{org_id}/teams/{team_id}/resources/{resource_id}",
      handler: async (req: Request): Promise<Response> => {
        try {
          const headerConfigs: HeaderConfig[] = [
            { name: "X-API-Key", type: "string", required: true, format: "uuid" },
          ];
          const headerViolations = validateHeaders(req, headerConfigs);
          if (headerViolations) {
            throw new ValidationError(headerViolations);
          }

          const pathParams: Record<string, string> = {};
          const url = new URL(req.url, "http://localhost");
          const pathSegments = url.pathname.split("/");
          pathParams["org_id"] = decodeURIComponent(pathSegments[4] ?? "");
          pathParams["team_id"] = decodeURIComponent(pathSegments[6] ?? "");
          pathParams["resource_id"] = decodeURIComponent(pathSegments[8] ?? "");

          const body = {} as GetNestedResourceRequest;

          body.orgId = pathParams["org_id"];
          body.teamId = pathParams["team_id"];
          body.resourceId = pathParams["resource_id"];

          const ctx: ServerContext = {
            request: req,
            pathParams,
            headers: Object.fromEntries(req.headers.entries()),
          };

          const result = await handler.getNestedResource(ctx, body);
          return new Response(JSON.stringify(result as Resource), {
            status: 200,
            headers: { "Content-Type": "application/json" },
          });
        } catch (err: unknown) {
          if (err instanceof ValidationError) {
            return new Response(JSON.stringify({ violations: err.violations }), {
              status: 400,
              headers: { "Content-Type": "application/json" },
            });
          }
          if (options?.onError) {
            return options.onError(err, req);
          }
          const message = err instanceof Error ? err.message : String(err);
          return new Response(JSON.stringify({ message }), {
            status: 500,
            headers: { "Content-Type": "application/json" },
          });
        }
      },
    },
    {
      method: "POST",
      path: "/api/v1/resources",
      handler: async (req: Request): Promise<Response> => {
        try {
          const headerConfigs: HeaderConfig[] = [
            { name: "X-API-Key", type: "string", required: true, format: "uuid" },
            { name: "X-Request-ID", type: "string", required: true, format: "uuid" },
          ];
          const headerViolations = validateHeaders(req, headerConfigs);
          if (headerViolations) {
            throw new ValidationError(headerViolations);
          }

          const pathParams: Record<string, string> = {};
          const body = await req.json() as CreateResourceRequest;
          if (options?.validateRequest) {
            const bodyViolations = options.validateRequest("createResource", body);
            if (bodyViolations) {
              throw new ValidationError(bodyViolations);
            }
          }

          const ctx: ServerContext = {
            request: req,
            pathParams,
            headers: Object.fromEntries(req.headers.entries()),
          };

          const result = await handler.createResource(ctx, body);
          return new Response(JSON.stringify(result as Resource), {
            status: 200,
            headers: { "Content-Type": "application/json" },
          });
        } catch (err: unknown) {
          if (err instanceof ValidationError) {
            return new Response(JSON.stringify({ violations: err.violations }), {
              status: 400,
              headers: { "Content-Type": "application/json" },
            });
          }
          if (options?.onError) {
            return options.onError(err, req);
          }
          const message = err instanceof Error ? err.message : String(err);
          return new Response(JSON.stringify({ message }), {
            status: 500,
            headers: { "Content-Type": "application/json" },
          });
        }
      },
    },
    {
      method: "PUT",
      path: "/api/v1/resources/{resource_id}",
      handler: async (req: Request): Promise<Response> => {
        try {
          const headerConfigs: HeaderConfig[] = [
            { name: "X-API-Key", type: "string", required: true, format: "uuid" },
          ];
          const headerViolations = validateHeaders(req, headerConfigs);
          if (headerViolations) {
            throw new ValidationError(headerViolations);
          }

          const pathParams: Record<string, string> = {};
          const url = new URL(req.url, "http://localhost");
          const pathSegments = url.pathname.split("/");
          pathParams["resource_id"] = decodeURIComponent(pathSegments[4] ?? "");

          const body = await req.json() as UpdateResourceRequest;
          if (options?.validateRequest) {
            const bodyViolations = options.validateRequest("updateResource", body);
            if (bodyViolations) {
              throw new ValidationError(bodyViolations);
            }
          }

          body.resourceId = pathParams["resource_id"];

          const ctx: ServerContext = {
            request: req,
            pathParams,
            headers: Object.fromEntries(req.headers.entries()),
          };

          const result = await handler.updateResource(ctx, body);
          return new Response(JSON.stringify(result as Resource), {
            status: 200,
            headers: { "Content-Type": "application/json" },
          });
        } catch (err: unknown) {
          if (err instanceof ValidationError) {
            return new Response(JSON.stringify({ violations: err.violations }), {
              status: 400,
              headers: { "Content-Type": "application/json" },
            });
          }
          if (options?.onError) {
            return options.onError(err, req);
          }
          const message = err instanceof Error ? err.message : String(err);
          return new Response(JSON.stringify({ message }), {
            status: 500,
            headers: { "Content-Type": "application/json" },
          });
        }
      },
    },
    {
      method: "PATCH",
      path: "/api/v1/resources/{resource_id}",
      handler: async (req: Request): Promise<Response> => {
        try {
          const headerConfigs: HeaderConfig[] = [
            { name: "X-API-Key", type: "string", required: true, format: "uuid" },
          ];
          const headerViolations = validateHeaders(req, headerConfigs);
          if (headerViolations) {
            throw new ValidationError(headerViolations);
          }

          const pathParams: Record<string, string> = {};
          const url = new URL(req.url, "http://localhost");
          const pathSegments = url.pathname.split("/");
          pathParams["resource_id"] = decodeURIComponent(pathSegments[4] ?? "");

          const body = await req.json() as PatchResourceRequest;
          if (options?.validateRequest) {
            const bodyViolations = options.validateRequest("patchResource", body);
            if (bodyViolations) {
              throw new ValidationError(bodyViolations);
            }
          }

          body.resourceId = pathParams["resource_id"];

          const ctx: ServerContext = {
            request: req,
            pathParams,
            headers: Object.fromEntries(req.headers.entries()),
          };

          const result = await handler.patchResource(ctx, body);
          return new Response(JSON.stringify(result as Resource), {
            status: 200,
            headers: { "Content-Type": "application/json" },
          });
        } catch (err: unknown) {
          if (err instanceof ValidationError) {
            return new Response(JSON.stringify({ violations: err.violations }), {
              status: 400,
              headers: { "Content-Type": "application/json" },
            });
          }
          if (options?.onError) {
            return options.onError(err, req);
          }
          const message = err instanceof Error ? err.message : String(err);
          return new Response(JSON.stringify({ message }), {
            status: 500,
            headers: { "Content-Type": "application/json" },
          });
        }
      },
    },
    {
      method: "DELETE",
      path: "/api/v1/resources/{resource_id}",
      handler: async (req: Request): Promise<Response> => {
        try {
          const headerConfigs: HeaderConfig[] = [
            { name: "X-API-Key", type: "string", required: true, format: "uuid" },
          ];
          const headerViolations = validateHeaders(req, headerConfigs);
          if (headerViolations) {
            throw new ValidationError(headerViolations);
          }

          const pathParams: Record<string, string> = {};
          const url = new URL(req.url, "http://localhost");
          const pathSegments = url.pathname.split("/");
          pathParams["resource_id"] = decodeURIComponent(pathSegments[4] ?? "");

          const body = {} as DeleteResourceRequest;

          body.resourceId = pathParams["resource_id"];

          const ctx: ServerContext = {
            request: req,
            pathParams,
            headers: Object.fromEntries(req.headers.entries()),
          };

          const result = await handler.deleteResource(ctx, body);
          return new Response(JSON.stringify(result as DeleteResourceResponse), {
            status: 200,
            headers: { "Content-Type": "application/json" },
          });
        } catch (err: unknown) {
          if (err instanceof ValidationError) {
            return new Response(JSON.stringify({ violations: err.violations }), {
              status: 400,
              headers: { "Content-Type": "application/json" },
            });
          }
          if (options?.onError) {
            return options.onError(err, req);
          }
          const message = err instanceof Error ? err.message : String(err);
          return new Response(JSON.stringify({ message }), {
            status: 500,
            headers: { "Content-Type": "application/json" },
          });
        }
      },
    },
    {
      method: "POST",
      path: "/api/v1/legacy/action",
      handler: async (req: Request): Promise<Response> => {
        try {
          const headerConfigs: HeaderConfig[] = [
            { name: "X-API-Key", type: "string", required: true, format: "uuid" },
          ];
          const headerViolations = validateHeaders(req, headerConfigs);
          if (headerViolations) {
            throw new ValidationError(headerViolations);
          }

          const pathParams: Record<string, string> = {};
          const body = await req.json() as DefaultPostRequest;
          if (options?.validateRequest) {
            const bodyViolations = options.validateRequest("defaultPostMethod", body);
            if (bodyViolations) {
              throw new ValidationError(bodyViolations);
            }
          }

          const ctx: ServerContext = {
            request: req,
            pathParams,
            headers: Object.fromEntries(req.headers.entries()),
          };

          const result = await handler.defaultPostMethod(ctx, body);
          return new Response(JSON.stringify(result as DefaultPostResponse), {
            status: 200,
            headers: { "Content-Type": "application/json" },
          });
        } catch (err: unknown) {
          if (err instanceof ValidationError) {
            return new Response(JSON.stringify({ violations: err.violations }), {
              status: 400,
              headers: { "Content-Type": "application/json" },
            });
          }
          if (options?.onError) {
            return options.onError(err, req);
          }
          const message = err instanceof Error ? err.message : String(err);
          return new Response(JSON.stringify({ message }), {
            status: 500,
            headers: { "Content-Type": "application/json" },
          });
        }
      },
    },
    {
      method: "GET",
      path: "/api/v1/resources/search",
      handler: async (req: Request): Promise<Response> => {
        try {
          const headerConfigs: HeaderConfig[] = [
            { name: "X-API-Key", type: "string", required: true, format: "uuid" },
          ];
          const headerViolations = validateHeaders(req, headerConfigs);
          if (headerViolations) {
            throw new ValidationError(headerViolations);
          }

          const pathParams: Record<string, string> = {};
          const url = new URL(req.url, "http://localhost");
          const params = url.searchParams;
          const body: SearchResourcesRequest = {
            statusFilter: params.get("status") ?? "",
            query: params.get("q") ?? "",
          };
          if (options?.validateRequest) {
            const bodyViolations = options.validateRequest("searchResources", body);
            if (bodyViolations) {
              throw new ValidationError(bodyViolations);
            }
          }

          const ctx: ServerContext = {
            request: req,
            pathParams,
            headers: Object.fromEntries(req.headers.entries()),
          };

          const result = await handler.searchResources(ctx, body);
          return new Response(JSON.stringify(result as ListResourcesResponse), {
            status: 200,
            headers: { "Content-Type": "application/json" },
          });
        } catch (err: unknown) {
          if (err instanceof ValidationError) {
            return new Response(JSON.stringify({ violations: err.violations }), {
              status: 400,
              headers: { "Content-Type": "application/json" },
            });
          }
          if (options?.onError) {
            return options.onError(err, req);
          }
          const message = err instanceof Error ? err.message : String(err);
          return new Response(JSON.stringify({ message }), {
            status: 500,
            headers: { "Content-Type": "application/json" },
          });
        }
      },
    },
  ];
}

export interface BackwardCompatServiceHandler {
  legacyAction(ctx: ServerContext, req: LegacyRequest): Promise<LegacyResponse>;
}

export function createBackwardCompatServiceRoutes(
  handler: BackwardCompatServiceHandler,
  options?: ServerOptions,
): RouteDescriptor[] {
  return [
    {
      method: "POST",
      path: "/legacyAction",
      handler: async (req: Request): Promise<Response> => {
        try {
          const pathParams: Record<string, string> = {};
          const body = await req.json() as LegacyRequest;
          if (options?.validateRequest) {
            const bodyViolations = options.validateRequest("legacyAction", body);
            if (bodyViolations) {
              throw new ValidationError(bodyViolations);
            }
          }

          const ctx: ServerContext = {
            request: req,
            pathParams,
            headers: Object.fromEntries(req.headers.entries()),
          };

          const result = await handler.legacyAction(ctx, body);
          return new Response(JSON.stringify(result as LegacyResponse), {
            status: 200,
            headers: { "Content-Type": "application/json" },
          });
        } catch (err: unknown) {
          if (err instanceof ValidationError) {
            return new Response(JSON.stringify({ violations: err.violations }), {
              status: 400,
              headers: { "Content-Type": "application/json" },
            });
          }
          if (options?.onError) {
            return options.onError(err, req);
          }
          const message = err instanceof Error ? err.message : String(err);
          return new Response(JSON.stringify({ message }), {
            status: 500,
            headers: { "Content-Type": "application/json" },
          });
        }
      },
    },
  ];
}

