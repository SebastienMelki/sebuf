package tsservergen

import (
	"fmt"
	"net/http"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"

	sebufhttp "github.com/SebastienMelki/sebuf/http"
	"github.com/SebastienMelki/sebuf/internal/annotations"
	"github.com/SebastienMelki/sebuf/internal/tscommon"
)

// Generator handles TypeScript server code generation for protobuf services.
type Generator struct {
	plugin *protogen.Plugin
}

// New creates a new TypeScript server generator.
func New(plugin *protogen.Plugin) *Generator {
	return &Generator{
		plugin: plugin,
	}
}

// Generate processes all files and generates TypeScript server files.
func (g *Generator) Generate() error {
	for _, file := range g.plugin.Files {
		if !file.Generate {
			continue
		}
		if err := g.generateFile(file); err != nil {
			return err
		}
	}
	return nil
}

func (g *Generator) generateFile(file *protogen.File) error {
	if len(file.Services) == 0 {
		return nil
	}
	return g.generateServerFile(file)
}

func (g *Generator) generateServerFile(file *protogen.File) error {
	filename := file.GeneratedFilenamePrefix + "_server.ts"
	gf := g.plugin.NewGeneratedFile(filename, "")

	// Collect all referenced messages and enums
	ms := tscommon.CollectServiceMessages(file)

	p := func(format string, args ...interface{}) {
		if len(args) == 0 {
			gf.P(format)
		} else {
			gf.P(fmt.Sprintf(format, args...))
		}
	}

	// 1. Header
	g.writeHeader(p, file)

	// 2. Message interfaces (shared types via tscommon)
	for _, msg := range ms.OrderedMessages() {
		tscommon.GenerateInterface(tscommon.Printer(p), msg)
	}

	// 3. Enum types (shared via tscommon)
	for _, enum := range ms.OrderedEnums() {
		tscommon.GenerateEnumType(tscommon.Printer(p), enum)
	}

	// 4. Error types (shared with client)
	tscommon.WriteErrorTypes(tscommon.Printer(p))

	// 5. Server-specific framework types
	g.writeServerTypes(p)

	// 6. Header validation helpers (if any service uses headers)
	if g.fileUsesHeaders(file) {
		g.writeHeaderValidationHelpers(p)
	}

	// 7. Per service: handler interface + route creation
	for _, service := range file.Services {
		if err := g.generateService(p, service); err != nil {
			return err
		}
	}

	return nil
}

func (g *Generator) writeHeader(p tscommon.Printer, file *protogen.File) {
	p("// Code generated by protoc-gen-ts-server. DO NOT EDIT.")
	p("// source: %s", file.Desc.Path())
	p("")
}

func (g *Generator) writeServerTypes(p tscommon.Printer) {
	// ServerContext
	p("export interface ServerContext {")
	p("  request: Request;")
	p("  pathParams: Record<string, string>;")
	p("  headers: Record<string, string>;")
	p("}")
	p("")

	// ServerOptions
	p("export interface ServerOptions {")
	p("  onError?: (error: unknown, req: Request) => Response | Promise<Response>;")
	p("  validateRequest?: (methodName: string, body: unknown) => FieldViolation[] | undefined;")
	p("}")
	p("")

	// RouteDescriptor
	p("export interface RouteDescriptor {")
	p("  method: string;")
	p("  path: string;")
	p("  handler: (req: Request) => Promise<Response>;")
	p("}")
	p("")
}

// fileUsesHeaders returns true if any service in the file uses header annotations.
func (g *Generator) fileUsesHeaders(file *protogen.File) bool {
	for _, service := range file.Services {
		if len(annotations.GetServiceHeaders(service)) > 0 {
			return true
		}
		for _, method := range service.Methods {
			if len(annotations.GetMethodHeaders(method)) > 0 {
				return true
			}
		}
	}
	return false
}

// writeHeaderValidationHelpers writes format/type validation helper functions.
func (g *Generator) writeHeaderValidationHelpers(p tscommon.Printer) {
	g.writeHeaderRegexConstants(p)
	g.writeHeaderConfigType(p)
	g.writeValidateHeaderValueFn(p)
	g.writeValidateHeadersFn(p)
}

func (g *Generator) writeHeaderRegexConstants(p tscommon.Printer) {
	p("const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;")
	p("")
	p("const EMAIL_REGEX = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;")
	p("")
	p("const DATETIME_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.[\\d]+)?(Z|[+-]\\d{2}:\\d{2})$/;")
	p("")
	p("const DATE_REGEX = /^\\d{4}-\\d{2}-\\d{2}$/;")
	p("")
	p("const TIME_REGEX = /^\\d{2}:\\d{2}:\\d{2}(\\.[\\d]+)?$/;")
	p("")
}

func (g *Generator) writeHeaderConfigType(p tscommon.Printer) {
	p("interface HeaderConfig {")
	p("  name: string;")
	p("  type: string;")
	p("  required: boolean;")
	p("  format?: string;")
	p("}")
	p("")
}

func (g *Generator) writeValidateHeaderValueFn(p tscommon.Printer) {
	p("function validateHeaderValue(value: string, config: HeaderConfig): string | undefined {")
	p("  switch (config.type) {")
	p(`    case "integer":`)
	p(`      if (!/^-?\d+$/.test(value)) return "must be an integer";`)
	p("      break;")
	p(`    case "number":`)
	p(`      if (isNaN(Number(value))) return "must be a number";`)
	p("      break;")
	p(`    case "boolean":`)
	p(`      if (value !== "true" && value !== "false" && value !== "1" && value !== "0")`)
	p(`        return "must be a boolean";`)
	p("      break;")
	p("  }")
	p("  if (config.format) {")
	p("    switch (config.format) {")
	p(`      case "uuid":`)
	p(`        if (!UUID_REGEX.test(value)) return "must be a valid UUID";`)
	p("        break;")
	p(`      case "email":`)
	p(`        if (!EMAIL_REGEX.test(value)) return "must be a valid email";`)
	p("        break;")
	p(`      case "date-time":`)
	p(`        if (!DATETIME_REGEX.test(value)) return "must be a valid date-time";`)
	p("        break;")
	p(`      case "date":`)
	p(`        if (!DATE_REGEX.test(value)) return "must be a valid date";`)
	p("        break;")
	p(`      case "time":`)
	p(`        if (!TIME_REGEX.test(value)) return "must be a valid time";`)
	p("        break;")
	p("    }")
	p("  }")
	p("  return undefined;")
	p("}")
	p("")
}

func (g *Generator) writeValidateHeadersFn(p tscommon.Printer) {
	p("function validateHeaders(")
	p("  req: Request,")
	p("  configs: HeaderConfig[],")
	p("): FieldViolation[] | undefined {")
	p("  const violations: FieldViolation[] = [];")
	p("  for (const config of configs) {")
	p("    const value = req.headers.get(config.name);")
	p("    if (value == null) {")
	p("      if (config.required) {")
	p("        violations.push({")
	p("          field: config.name,")
	p(`          description: "required header is missing",`)
	p("        });")
	p("      }")
	p("      continue;")
	p("    }")
	p("    const err = validateHeaderValue(value, config);")
	p("    if (err) {")
	p("      violations.push({")
	p("        field: config.name,")
	p("        description: `header ${config.name}: ${err}`,")
	p("      });")
	p("    }")
	p("  }")
	p("  return violations.length > 0 ? violations : undefined;")
	p("}")
	p("")
}

func (g *Generator) generateService(p tscommon.Printer, service *protogen.Service) error {
	serviceName := service.GoName

	// Handler interface
	g.generateHandlerInterface(p, service)

	// Route creation function
	g.generateCreateRoutes(p, service)

	_ = serviceName
	return nil
}

// generateHandlerInterface generates the XxxServiceHandler interface.
func (g *Generator) generateHandlerInterface(p tscommon.Printer, service *protogen.Service) {
	serviceName := service.GoName

	p("export interface %sHandler {", serviceName)
	for _, method := range service.Methods {
		methodName := annotations.LowerFirst(method.GoName)
		inputType := string(method.Input.Desc.Name())
		outputType := g.resolveOutputType(method)
		p("  %s(ctx: ServerContext, req: %s): Promise<%s>;", methodName, inputType, outputType)
	}
	p("}")
	p("")
}

// resolveOutputType returns the TypeScript return type, handling root unwrap.
func (g *Generator) resolveOutputType(method *protogen.Method) string {
	msg := method.Output
	if annotations.IsRootUnwrap(msg) {
		return tscommon.RootUnwrapTSType(msg)
	}
	return string(msg.Desc.Name())
}

// rpcRouteConfig holds config for generating a route handler.
type rpcRouteConfig struct {
	serviceName string
	methodName  string
	httpMethod  string
	fullPath    string
	pathParams  []string
	queryParams []annotations.QueryParam
	hasBody     bool
}

func (g *Generator) buildRPCRouteConfig(service *protogen.Service, method *protogen.Method) *rpcRouteConfig {
	serviceName := service.GoName
	methodName := method.GoName

	httpConfig := annotations.GetMethodHTTPConfig(method)
	httpMethod := http.MethodPost
	httpPath := "/" + annotations.LowerFirst(methodName)
	var pathParams []string

	if httpConfig != nil {
		if httpConfig.Method != "" {
			httpMethod = httpConfig.Method
		}
		if httpConfig.Path != "" {
			httpPath = httpConfig.Path
		}
		pathParams = httpConfig.PathParams
	}

	basePath := annotations.GetServiceBasePath(service)
	fullPath := annotations.BuildHTTPPath(basePath, httpPath)

	return &rpcRouteConfig{
		serviceName: serviceName,
		methodName:  methodName,
		httpMethod:  httpMethod,
		fullPath:    fullPath,
		pathParams:  pathParams,
		queryParams: annotations.GetQueryParams(method.Input),
		hasBody:     httpMethod == "POST" || httpMethod == "PUT" || httpMethod == "PATCH",
	}
}

// generateCreateRoutes generates the createXxxRoutes function.
func (g *Generator) generateCreateRoutes(p tscommon.Printer, service *protogen.Service) {
	serviceName := service.GoName

	p("export function create%sRoutes(", serviceName)
	p("  handler: %sHandler,", serviceName)
	p("  options?: ServerOptions,")
	p("): RouteDescriptor[] {")
	p("  return [")
	for _, method := range service.Methods {
		g.generateRouteEntry(p, service, method)
	}
	p("  ];")
	p("}")
	p("")
}

// generateRouteEntry generates a single route descriptor entry.
func (g *Generator) generateRouteEntry(p tscommon.Printer, service *protogen.Service, method *protogen.Method) {
	cfg := g.buildRPCRouteConfig(service, method)
	tsMethodName := annotations.LowerFirst(cfg.methodName)
	outputType := g.resolveOutputType(method)

	p("    {")
	p(`      method: "%s",`, cfg.httpMethod)
	p(`      path: "%s",`, cfg.fullPath)
	p("      handler: async (req: Request): Promise<Response> => {")

	// Try-catch wraps the handler body
	p("        try {")

	// Header validation (before body parsing)
	serviceHeaders := annotations.GetServiceHeaders(service)
	methodHeaders := annotations.GetMethodHeaders(method)
	g.generateHeaderValidation(p, serviceHeaders, methodHeaders)

	// Extract path params
	g.generatePathParamExtraction(p, cfg)

	// Parse request body or query params
	if cfg.hasBody {
		g.generateBodyParsing(p, method, tsMethodName)
	} else {
		g.generateQueryParamParsing(p, cfg, method, tsMethodName)
	}

	// Build ServerContext
	p("          const ctx: ServerContext = {")
	p("            request: req,")
	p("            pathParams,")
	p("            headers: Object.fromEntries(req.headers.entries()),")
	p("          };")
	p("")

	// Call handler
	p("          const result = await handler.%s(ctx, body);", tsMethodName)

	// Return JSON response
	p("          return new Response(JSON.stringify(result as %s), {", outputType)
	p("            status: 200,")
	p(`            headers: { "Content-Type": "application/json" },`)
	p("          });")

	// Catch block
	p("        } catch (err: unknown) {")
	p("          if (err instanceof ValidationError) {")
	p("            return new Response(JSON.stringify({ violations: err.violations }), {")
	p("              status: 400,")
	p(`              headers: { "Content-Type": "application/json" },`)
	p("            });")
	p("          }")
	p("          if (options?.onError) {")
	p("            return options.onError(err, req);")
	p("          }")
	p("          const message = err instanceof Error ? err.message : String(err);")
	p("          return new Response(JSON.stringify({ message }), {")
	p("            status: 500,")
	p(`            headers: { "Content-Type": "application/json" },`)
	p("          });")
	p("        }")

	p("      },")
	p("    },")
}

// generateHeaderValidation generates header validation code.
func (g *Generator) generateHeaderValidation(
	p tscommon.Printer,
	serviceHeaders []*sebufhttp.Header,
	methodHeaders []*sebufhttp.Header,
) {
	// Combine all headers that need validation
	allHeaders := make([]*sebufhttp.Header, 0, len(serviceHeaders)+len(methodHeaders))
	allHeaders = append(allHeaders, serviceHeaders...)
	allHeaders = append(allHeaders, methodHeaders...)
	if len(allHeaders) == 0 {
		return
	}

	// Build inline header config for method-specific combination
	p("          const headerConfigs: HeaderConfig[] = [")
	for _, h := range allHeaders {
		formatStr := ""
		if h.GetFormat() != "" {
			formatStr = fmt.Sprintf(`, format: "%s"`, h.GetFormat())
		}
		p(`            { name: "%s", type: "%s", required: %t%s },`,
			h.GetName(), h.GetType(), h.GetRequired(), formatStr)
	}
	p("          ];")
	p("          const headerViolations = validateHeaders(req, headerConfigs);")
	p("          if (headerViolations) {")
	p("            throw new ValidationError(headerViolations);")
	p("          }")
	p("")
}

// generatePathParamExtraction generates code to extract path params from the URL.
func (g *Generator) generatePathParamExtraction(p tscommon.Printer, cfg *rpcRouteConfig) {
	if len(cfg.pathParams) == 0 {
		p("          const pathParams: Record<string, string> = {};")
		return
	}

	// Generate path matching to extract params
	// Build a regex from the path pattern
	p("          const pathParams: Record<string, string> = {};")
	p("          const url = new URL(req.url, \"http://localhost\");")
	p("          const pathSegments = url.pathname.split(\"/\");")

	// Calculate segment indices for each path param
	segments := strings.Split(cfg.fullPath, "/")
	for _, param := range cfg.pathParams {
		paramPlaceholder := "{" + param + "}"
		for i, seg := range segments {
			if seg == paramPlaceholder {
				p("          pathParams[\"%s\"] = decodeURIComponent(pathSegments[%d] ?? \"\");", param, i)
				break
			}
		}
	}
	p("")
}

// generateBodyParsing generates code to parse JSON request body.
func (g *Generator) generateBodyParsing(p tscommon.Printer, method *protogen.Method, tsMethodName string) {
	inputType := string(method.Input.Desc.Name())
	p("          const body = await req.json() as %s;", inputType)

	// Optional validation hook
	p("          if (options?.validateRequest) {")
	p("            const bodyViolations = options.validateRequest(\"%s\", body);", tsMethodName)
	p("            if (bodyViolations) {")
	p("              throw new ValidationError(bodyViolations);")
	p("            }")
	p("          }")
	p("")
}

// generateQueryParamParsing generates code to parse query parameters.
func (g *Generator) generateQueryParamParsing(
	p tscommon.Printer,
	cfg *rpcRouteConfig,
	method *protogen.Method,
	tsMethodName string,
) {
	inputType := string(method.Input.Desc.Name())

	if len(cfg.queryParams) == 0 {
		p("          const body = {} as %s;", inputType)
		p("")
		return
	}

	p("          const url = new URL(req.url, \"http://localhost\");")
	p("          const params = url.searchParams;")
	p("          const body: %s = {", inputType)
	for _, qp := range cfg.queryParams {
		g.generateQueryParamField(p, qp)
	}
	p("          };")

	// Optional validation hook
	p("          if (options?.validateRequest) {")
	p("            const bodyViolations = options.validateRequest(\"%s\", body);", tsMethodName)
	p("            if (bodyViolations) {")
	p("              throw new ValidationError(bodyViolations);")
	p("            }")
	p("          }")
	p("")
}

// generateQueryParamField generates a single query parameter field extraction.
func (g *Generator) generateQueryParamField(p tscommon.Printer, qp annotations.QueryParam) {
	jsonName := qp.FieldJSONName
	paramName := qp.ParamName

	if qp.Field != nil {
		tsType := tscommon.TSScalarTypeForField(qp.Field)
		switch tsType {
		case tscommon.TSNumber:
			p(`            %s: Number(params.get("%s") ?? "0"),`, jsonName, paramName)
		case tscommon.TSBoolean:
			p(`            %s: params.get("%s") === "true",`, jsonName, paramName)
		default:
			p(`            %s: params.get("%s") ?? "",`, jsonName, paramName)
		}
	} else {
		// Fallback based on field kind string
		switch qp.FieldKind {
		case "int32", "sint32", "sfixed32", "uint32", "fixed32", "float", "double":
			p(`            %s: Number(params.get("%s") ?? "0"),`, jsonName, paramName)
		case "int64", "sint64", "sfixed64", "uint64", "fixed64":
			p(`            %s: params.get("%s") ?? "0",`, jsonName, paramName)
		case "bool":
			p(`            %s: params.get("%s") === "true",`, jsonName, paramName)
		default:
			p(`            %s: params.get("%s") ?? "",`, jsonName, paramName)
		}
	}
}
