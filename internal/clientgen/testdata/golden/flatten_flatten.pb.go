// Code generated by protoc-gen-go-client. DO NOT EDIT.
// source: flatten.proto

package flatten

import (
	"encoding/json"

	"google.golang.org/protobuf/encoding/protojson"
)

// MarshalJSON implements json.Marshaler for SimpleFlatten.
// This method handles flatten fields: address
func (x *SimpleFlatten) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}

	// Use protojson for base serialization (handles all other fields correctly)
	data, err := protojson.Marshal(x)
	if err != nil {
		return nil, err
	}

	// Parse into a map to promote flattened child fields
	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return nil, err
	}

	// Flatten field: address
	if x.Address != nil {
		delete(raw, "address")
		// Use json.Marshal to invoke child's MarshalJSON (annotation composability)
		childData, childErr := json.Marshal(x.Address)
		if childErr != nil {
			return nil, childErr
		}
		var childRaw map[string]json.RawMessage
		if childErr = json.Unmarshal(childData, &childRaw); childErr != nil {
			return nil, childErr
		}
		for k, v := range childRaw {
			raw[k] = v
		}
	}

	return json.Marshal(raw)
}

// UnmarshalJSON implements json.Unmarshaler for SimpleFlatten.
// This method handles flatten fields: address
func (x *SimpleFlatten) UnmarshalJSON(data []byte) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}

	// Extract flattened child fields for: address
	{
		childRaw := make(map[string]json.RawMessage)
		if v, ok := raw["street"]; ok {
			childRaw["street"] = v
			delete(raw, "street")
		}
		if v, ok := raw["city"]; ok {
			childRaw["city"] = v
			delete(raw, "city")
		}
		if v, ok := raw["zip"]; ok {
			childRaw["zip"] = v
			delete(raw, "zip")
		}
		if len(childRaw) > 0 {
			childData, childErr := json.Marshal(childRaw)
			if childErr != nil {
				return childErr
			}
			x.Address = &Address{}
			// Use json.Unmarshal to invoke child's UnmarshalJSON (annotation composability)
			if childErr = json.Unmarshal(childData, x.Address); childErr != nil {
				return childErr
			}
		}
	}

	// Re-marshal remaining fields for protojson
	remaining, err := json.Marshal(raw)
	if err != nil {
		return err
	}

	return protojson.Unmarshal(remaining, x)
}

// MarshalJSON implements json.Marshaler for DualFlatten.
// This method handles flatten fields: billing, shipping
func (x *DualFlatten) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}

	// Use protojson for base serialization (handles all other fields correctly)
	data, err := protojson.Marshal(x)
	if err != nil {
		return nil, err
	}

	// Parse into a map to promote flattened child fields
	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return nil, err
	}

	// Flatten field: billing
	if x.Billing != nil {
		delete(raw, "billing")
		// Use json.Marshal to invoke child's MarshalJSON (annotation composability)
		childData, childErr := json.Marshal(x.Billing)
		if childErr != nil {
			return nil, childErr
		}
		var childRaw map[string]json.RawMessage
		if childErr = json.Unmarshal(childData, &childRaw); childErr != nil {
			return nil, childErr
		}
		for k, v := range childRaw {
			raw["billing_"+k] = v
		}
	}

	// Flatten field: shipping
	if x.Shipping != nil {
		delete(raw, "shipping")
		// Use json.Marshal to invoke child's MarshalJSON (annotation composability)
		childData, childErr := json.Marshal(x.Shipping)
		if childErr != nil {
			return nil, childErr
		}
		var childRaw map[string]json.RawMessage
		if childErr = json.Unmarshal(childData, &childRaw); childErr != nil {
			return nil, childErr
		}
		for k, v := range childRaw {
			raw["shipping_"+k] = v
		}
	}

	return json.Marshal(raw)
}

// UnmarshalJSON implements json.Unmarshaler for DualFlatten.
// This method handles flatten fields: billing, shipping
func (x *DualFlatten) UnmarshalJSON(data []byte) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}

	// Extract flattened child fields for: billing
	{
		childRaw := make(map[string]json.RawMessage)
		if v, ok := raw["billing_street"]; ok {
			childRaw["street"] = v
			delete(raw, "billing_street")
		}
		if v, ok := raw["billing_city"]; ok {
			childRaw["city"] = v
			delete(raw, "billing_city")
		}
		if v, ok := raw["billing_zip"]; ok {
			childRaw["zip"] = v
			delete(raw, "billing_zip")
		}
		if len(childRaw) > 0 {
			childData, childErr := json.Marshal(childRaw)
			if childErr != nil {
				return childErr
			}
			x.Billing = &Address{}
			// Use json.Unmarshal to invoke child's UnmarshalJSON (annotation composability)
			if childErr = json.Unmarshal(childData, x.Billing); childErr != nil {
				return childErr
			}
		}
	}

	// Extract flattened child fields for: shipping
	{
		childRaw := make(map[string]json.RawMessage)
		if v, ok := raw["shipping_street"]; ok {
			childRaw["street"] = v
			delete(raw, "shipping_street")
		}
		if v, ok := raw["shipping_city"]; ok {
			childRaw["city"] = v
			delete(raw, "shipping_city")
		}
		if v, ok := raw["shipping_zip"]; ok {
			childRaw["zip"] = v
			delete(raw, "shipping_zip")
		}
		if len(childRaw) > 0 {
			childData, childErr := json.Marshal(childRaw)
			if childErr != nil {
				return childErr
			}
			x.Shipping = &Address{}
			// Use json.Unmarshal to invoke child's UnmarshalJSON (annotation composability)
			if childErr = json.Unmarshal(childData, x.Shipping); childErr != nil {
				return childErr
			}
		}
	}

	// Re-marshal remaining fields for protojson
	remaining, err := json.Marshal(raw)
	if err != nil {
		return err
	}

	return protojson.Unmarshal(remaining, x)
}

// MarshalJSON implements json.Marshaler for MixedFlatten.
// This method handles flatten fields: address
func (x *MixedFlatten) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}

	// Use protojson for base serialization (handles all other fields correctly)
	data, err := protojson.Marshal(x)
	if err != nil {
		return nil, err
	}

	// Parse into a map to promote flattened child fields
	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return nil, err
	}

	// Flatten field: address
	if x.Address != nil {
		delete(raw, "address")
		// Use json.Marshal to invoke child's MarshalJSON (annotation composability)
		childData, childErr := json.Marshal(x.Address)
		if childErr != nil {
			return nil, childErr
		}
		var childRaw map[string]json.RawMessage
		if childErr = json.Unmarshal(childData, &childRaw); childErr != nil {
			return nil, childErr
		}
		for k, v := range childRaw {
			raw[k] = v
		}
	}

	return json.Marshal(raw)
}

// UnmarshalJSON implements json.Unmarshaler for MixedFlatten.
// This method handles flatten fields: address
func (x *MixedFlatten) UnmarshalJSON(data []byte) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}

	// Extract flattened child fields for: address
	{
		childRaw := make(map[string]json.RawMessage)
		if v, ok := raw["street"]; ok {
			childRaw["street"] = v
			delete(raw, "street")
		}
		if v, ok := raw["city"]; ok {
			childRaw["city"] = v
			delete(raw, "city")
		}
		if v, ok := raw["zip"]; ok {
			childRaw["zip"] = v
			delete(raw, "zip")
		}
		if len(childRaw) > 0 {
			childData, childErr := json.Marshal(childRaw)
			if childErr != nil {
				return childErr
			}
			x.Address = &Address{}
			// Use json.Unmarshal to invoke child's UnmarshalJSON (annotation composability)
			if childErr = json.Unmarshal(childData, x.Address); childErr != nil {
				return childErr
			}
		}
	}

	// Re-marshal remaining fields for protojson
	remaining, err := json.Marshal(raw)
	if err != nil {
		return err
	}

	return protojson.Unmarshal(remaining, x)
}
