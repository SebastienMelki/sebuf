// Code generated by protoc-gen-go-client. DO NOT EDIT.
// source: unwrap.proto

package generated

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"

	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"

	sebufhttp "github.com/SebastienMelki/sebuf/http"
)

const (
	// ContentTypeJSON is the content type for JSON requests/responses.
	ContentTypeJSON = "application/json"
	// ContentTypeProto is the content type for binary protobuf requests/responses.
	ContentTypeProto = "application/x-protobuf"
)

// OptionDataServiceClient is the client API for OptionDataService service.
type OptionDataServiceClient interface {
	GetOptionBars(ctx context.Context, req *GetOptionBarsRequest, opts ...OptionDataServiceCallOption) (*GetOptionBarsResponse, error)
}

// optionDataServiceClient is the implementation of OptionDataServiceClient.
type optionDataServiceClient struct {
	baseURL        string
	httpClient     *http.Client
	contentType    string
	defaultHeaders map[string]string
}

var _ OptionDataServiceClient = (*optionDataServiceClient)(nil)

// OptionDataServiceClientOption configures a OptionDataService client.
type OptionDataServiceClientOption func(*optionDataServiceClient)

// WithOptionDataServiceHTTPClient sets the HTTP client to use for requests.
func WithOptionDataServiceHTTPClient(client *http.Client) OptionDataServiceClientOption {
	return func(c *optionDataServiceClient) {
		c.httpClient = client
	}
}

// WithOptionDataServiceContentType sets the default content type for requests.
// Use ContentTypeJSON or ContentTypeProto.
func WithOptionDataServiceContentType(contentType string) OptionDataServiceClientOption {
	return func(c *optionDataServiceClient) {
		c.contentType = contentType
	}
}

// WithOptionDataServiceDefaultHeader sets a default header to include in all requests.
func WithOptionDataServiceDefaultHeader(key, value string) OptionDataServiceClientOption {
	return func(c *optionDataServiceClient) {
		if c.defaultHeaders == nil {
			c.defaultHeaders = make(map[string]string)
		}
		c.defaultHeaders[key] = value
	}
}

// OptionDataServiceCallOption configures a single RPC call.
type OptionDataServiceCallOption func(*optionDataServiceCallOptions)

// optionDataServiceCallOptions holds options for a single RPC call.
type optionDataServiceCallOptions struct {
	headers     map[string]string
	contentType string
}

// WithOptionDataServiceHeader adds a header to a single request.
func WithOptionDataServiceHeader(key, value string) OptionDataServiceCallOption {
	return func(o *optionDataServiceCallOptions) {
		if o.headers == nil {
			o.headers = make(map[string]string)
		}
		o.headers[key] = value
	}
}

// WithOptionDataServiceCallContentType sets the content type for a single request.
func WithOptionDataServiceCallContentType(contentType string) OptionDataServiceCallOption {
	return func(o *optionDataServiceCallOptions) {
		o.contentType = contentType
	}
}

// NewOptionDataServiceClient creates a new OptionDataService client.
func NewOptionDataServiceClient(baseURL string, opts ...OptionDataServiceClientOption) OptionDataServiceClient {
	c := &optionDataServiceClient{
		baseURL:        strings.TrimSuffix(baseURL, "/"),
		httpClient:     http.DefaultClient,
		contentType:    ContentTypeJSON,
		defaultHeaders: make(map[string]string),
	}

	for _, opt := range opts {
		opt(c)
	}

	return c
}

// GetOptionBars calls the GetOptionBars RPC.
func (c *optionDataServiceClient) GetOptionBars(ctx context.Context, req *GetOptionBarsRequest, opts ...OptionDataServiceCallOption) (*GetOptionBarsResponse, error) {
	callOpts := &optionDataServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/api/v1/options/bars"
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "POST", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetOptionBarsResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

func (c *optionDataServiceClient) marshalRequest(req proto.Message, contentType string) ([]byte, error) {
	switch contentType {
	case ContentTypeJSON:
		// Check for custom JSON marshaler (unwrap support)
		if marshaler, ok := req.(json.Marshaler); ok {
			return marshaler.MarshalJSON()
		}
		return protojson.Marshal(req)
	case ContentTypeProto:
		return proto.Marshal(req)
	default:
		return protojson.Marshal(req)
	}
}

func (c *optionDataServiceClient) handleErrorResponse(statusCode int, body []byte, contentType string) error {
	// Try to parse as ValidationError first (for 400 errors)
	if statusCode == http.StatusBadRequest {
		validationErr := &sebufhttp.ValidationError{}
		if unmarshalErr := c.unmarshalResponse(body, validationErr, contentType); unmarshalErr == nil {
			return validationErr
		}
	}

	// Try to parse as generic Error
	genericErr := &sebufhttp.Error{}
	if unmarshalErr := c.unmarshalResponse(body, genericErr, contentType); unmarshalErr == nil {
		return genericErr
	}

	// Fallback to raw error message
	return fmt.Errorf("request failed with status %d: %s", statusCode, string(body))
}

func (c *optionDataServiceClient) unmarshalResponse(body []byte, msg proto.Message, contentType string) error {
	if len(body) == 0 {
		return nil
	}

	switch contentType {
	case ContentTypeJSON:
		// Check for custom JSON unmarshaler (unwrap support)
		if unmarshaler, ok := msg.(json.Unmarshaler); ok {
			return unmarshaler.UnmarshalJSON(body)
		}
		return protojson.Unmarshal(body, msg)
	case ContentTypeProto:
		return proto.Unmarshal(body, msg)
	default:
		return protojson.Unmarshal(body, msg)
	}
}

// UnwrapServiceClient is the client API for UnwrapService service.
type UnwrapServiceClient interface {
	GetOptionBars(ctx context.Context, req *GetOptionBarsRequest, opts ...UnwrapServiceCallOption) (*GetOptionBarsResponse, error)
	GetRootMap(ctx context.Context, req *GetOptionBarsRequest, opts ...UnwrapServiceCallOption) (*RootMapResponse, error)
	GetRootRepeated(ctx context.Context, req *GetOptionBarsRequest, opts ...UnwrapServiceCallOption) (*RootRepeatedResponse, error)
	GetRootMapWithValueUnwrap(ctx context.Context, req *GetOptionBarsRequest, opts ...UnwrapServiceCallOption) (*RootMapWithValueUnwrapResponse, error)
}

// unwrapServiceClient is the implementation of UnwrapServiceClient.
type unwrapServiceClient struct {
	baseURL        string
	httpClient     *http.Client
	contentType    string
	defaultHeaders map[string]string
}

var _ UnwrapServiceClient = (*unwrapServiceClient)(nil)

// UnwrapServiceClientOption configures a UnwrapService client.
type UnwrapServiceClientOption func(*unwrapServiceClient)

// WithUnwrapServiceHTTPClient sets the HTTP client to use for requests.
func WithUnwrapServiceHTTPClient(client *http.Client) UnwrapServiceClientOption {
	return func(c *unwrapServiceClient) {
		c.httpClient = client
	}
}

// WithUnwrapServiceContentType sets the default content type for requests.
// Use ContentTypeJSON or ContentTypeProto.
func WithUnwrapServiceContentType(contentType string) UnwrapServiceClientOption {
	return func(c *unwrapServiceClient) {
		c.contentType = contentType
	}
}

// WithUnwrapServiceDefaultHeader sets a default header to include in all requests.
func WithUnwrapServiceDefaultHeader(key, value string) UnwrapServiceClientOption {
	return func(c *unwrapServiceClient) {
		if c.defaultHeaders == nil {
			c.defaultHeaders = make(map[string]string)
		}
		c.defaultHeaders[key] = value
	}
}

// UnwrapServiceCallOption configures a single RPC call.
type UnwrapServiceCallOption func(*unwrapServiceCallOptions)

// unwrapServiceCallOptions holds options for a single RPC call.
type unwrapServiceCallOptions struct {
	headers     map[string]string
	contentType string
}

// WithUnwrapServiceHeader adds a header to a single request.
func WithUnwrapServiceHeader(key, value string) UnwrapServiceCallOption {
	return func(o *unwrapServiceCallOptions) {
		if o.headers == nil {
			o.headers = make(map[string]string)
		}
		o.headers[key] = value
	}
}

// WithUnwrapServiceCallContentType sets the content type for a single request.
func WithUnwrapServiceCallContentType(contentType string) UnwrapServiceCallOption {
	return func(o *unwrapServiceCallOptions) {
		o.contentType = contentType
	}
}

// NewUnwrapServiceClient creates a new UnwrapService client.
func NewUnwrapServiceClient(baseURL string, opts ...UnwrapServiceClientOption) UnwrapServiceClient {
	c := &unwrapServiceClient{
		baseURL:        strings.TrimSuffix(baseURL, "/"),
		httpClient:     http.DefaultClient,
		contentType:    ContentTypeJSON,
		defaultHeaders: make(map[string]string),
	}

	for _, opt := range opts {
		opt(c)
	}

	return c
}

// GetOptionBars calls the GetOptionBars RPC.
func (c *unwrapServiceClient) GetOptionBars(ctx context.Context, req *GetOptionBarsRequest, opts ...UnwrapServiceCallOption) (*GetOptionBarsResponse, error) {
	callOpts := &unwrapServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/api/v1/options/bars"
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "POST", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &GetOptionBarsResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetRootMap calls the GetRootMap RPC.
func (c *unwrapServiceClient) GetRootMap(ctx context.Context, req *GetOptionBarsRequest, opts ...UnwrapServiceCallOption) (*RootMapResponse, error) {
	callOpts := &unwrapServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/api/v1/root/map"
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "POST", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &RootMapResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetRootRepeated calls the GetRootRepeated RPC.
func (c *unwrapServiceClient) GetRootRepeated(ctx context.Context, req *GetOptionBarsRequest, opts ...UnwrapServiceCallOption) (*RootRepeatedResponse, error) {
	callOpts := &unwrapServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/api/v1/root/repeated"
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "POST", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &RootRepeatedResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetRootMapWithValueUnwrap calls the GetRootMapWithValueUnwrap RPC.
func (c *unwrapServiceClient) GetRootMapWithValueUnwrap(ctx context.Context, req *GetOptionBarsRequest, opts ...UnwrapServiceCallOption) (*RootMapWithValueUnwrapResponse, error) {
	callOpts := &unwrapServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/api/v1/root/map-value-unwrap"
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "POST", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &RootMapWithValueUnwrapResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

func (c *unwrapServiceClient) marshalRequest(req proto.Message, contentType string) ([]byte, error) {
	switch contentType {
	case ContentTypeJSON:
		// Check for custom JSON marshaler (unwrap support)
		if marshaler, ok := req.(json.Marshaler); ok {
			return marshaler.MarshalJSON()
		}
		return protojson.Marshal(req)
	case ContentTypeProto:
		return proto.Marshal(req)
	default:
		return protojson.Marshal(req)
	}
}

func (c *unwrapServiceClient) handleErrorResponse(statusCode int, body []byte, contentType string) error {
	// Try to parse as ValidationError first (for 400 errors)
	if statusCode == http.StatusBadRequest {
		validationErr := &sebufhttp.ValidationError{}
		if unmarshalErr := c.unmarshalResponse(body, validationErr, contentType); unmarshalErr == nil {
			return validationErr
		}
	}

	// Try to parse as generic Error
	genericErr := &sebufhttp.Error{}
	if unmarshalErr := c.unmarshalResponse(body, genericErr, contentType); unmarshalErr == nil {
		return genericErr
	}

	// Fallback to raw error message
	return fmt.Errorf("request failed with status %d: %s", statusCode, string(body))
}

func (c *unwrapServiceClient) unmarshalResponse(body []byte, msg proto.Message, contentType string) error {
	if len(body) == 0 {
		return nil
	}

	switch contentType {
	case ContentTypeJSON:
		// Check for custom JSON unmarshaler (unwrap support)
		if unmarshaler, ok := msg.(json.Unmarshaler); ok {
			return unmarshaler.UnmarshalJSON(body)
		}
		return protojson.Unmarshal(body, msg)
	case ContentTypeProto:
		return proto.Unmarshal(body, msg)
	default:
		return protojson.Unmarshal(body, msg)
	}
}
