// Code generated by protoc-gen-go-client. DO NOT EDIT.
// source: int64_encoding.proto

package int64encoding

import (
	"encoding/json"
	"strconv"

	"google.golang.org/protobuf/encoding/protojson"
)

// MarshalJSON implements json.Marshaler for Int64EncodingTest.
// This method handles int64_encoding=NUMBER fields: number_int64, number_uint64, number_sint64, number_sfixed64, number_fixed64, repeated_number_int64, optional_number_int64, commented_number_int64
// Warning: int64 fields with NUMBER encoding may lose precision for values > 2^53 in JavaScript.
func (x *Int64EncodingTest) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}

	// Use protojson for base serialization (handles all other fields correctly)
	data, err := protojson.Marshal(x)
	if err != nil {
		return nil, err
	}

	// Parse into a map to modify NUMBER-encoded int64 fields
	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return nil, err
	}

	// Convert NumberInt64 from string to number
	if x.NumberInt64 != 0 {
		raw["numberInt64"], _ = json.Marshal(x.NumberInt64)
	} else {
		// Remove the field if zero (proto3 default behavior)
		delete(raw, "numberInt64")
	}

	// Convert NumberUint64 from string to number
	if x.NumberUint64 != 0 {
		raw["numberUint64"], _ = json.Marshal(x.NumberUint64)
	} else {
		// Remove the field if zero (proto3 default behavior)
		delete(raw, "numberUint64")
	}

	// Convert NumberSint64 from string to number
	if x.NumberSint64 != 0 {
		raw["numberSint64"], _ = json.Marshal(x.NumberSint64)
	} else {
		// Remove the field if zero (proto3 default behavior)
		delete(raw, "numberSint64")
	}

	// Convert NumberSfixed64 from string to number
	if x.NumberSfixed64 != 0 {
		raw["numberSfixed64"], _ = json.Marshal(x.NumberSfixed64)
	} else {
		// Remove the field if zero (proto3 default behavior)
		delete(raw, "numberSfixed64")
	}

	// Convert NumberFixed64 from string to number
	if x.NumberFixed64 != 0 {
		raw["numberFixed64"], _ = json.Marshal(x.NumberFixed64)
	} else {
		// Remove the field if zero (proto3 default behavior)
		delete(raw, "numberFixed64")
	}

	// Convert repeated RepeatedNumberInt64 from strings to numbers
	if len(x.RepeatedNumberInt64) > 0 {
		raw["repeatedNumberInt64"], _ = json.Marshal(x.RepeatedNumberInt64)
	}

	// Convert OptionalNumberInt64 from string to number
	if x.OptionalNumberInt64 != 0 {
		raw["optionalNumberInt64"], _ = json.Marshal(x.OptionalNumberInt64)
	} else {
		// Remove the field if zero (proto3 default behavior)
		delete(raw, "optionalNumberInt64")
	}

	// Convert CommentedNumberInt64 from string to number
	if x.CommentedNumberInt64 != 0 {
		raw["commentedNumberInt64"], _ = json.Marshal(x.CommentedNumberInt64)
	} else {
		// Remove the field if zero (proto3 default behavior)
		delete(raw, "commentedNumberInt64")
	}

	return json.Marshal(raw)
}

// UnmarshalJSON implements json.Unmarshaler for Int64EncodingTest.
// This method handles int64_encoding=NUMBER fields: number_int64, number_uint64, number_sint64, number_sfixed64, number_fixed64, repeated_number_int64, optional_number_int64, commented_number_int64
func (x *Int64EncodingTest) UnmarshalJSON(data []byte) error {
	// First, parse the raw JSON to extract NUMBER-encoded fields
	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}

	// Convert numberInt64 from number to string for protojson
	if rawVal, ok := raw["numberInt64"]; ok {
		var num int64
		if err := json.Unmarshal(rawVal, &num); err == nil {
			raw["numberInt64"], _ = json.Marshal(strconv.FormatInt(num, 10))
		}
	}

	// Convert numberUint64 from number to string for protojson
	if rawVal, ok := raw["numberUint64"]; ok {
		var num uint64
		if err := json.Unmarshal(rawVal, &num); err == nil {
			raw["numberUint64"], _ = json.Marshal(strconv.FormatUint(num, 10))
		}
	}

	// Convert numberSint64 from number to string for protojson
	if rawVal, ok := raw["numberSint64"]; ok {
		var num int64
		if err := json.Unmarshal(rawVal, &num); err == nil {
			raw["numberSint64"], _ = json.Marshal(strconv.FormatInt(num, 10))
		}
	}

	// Convert numberSfixed64 from number to string for protojson
	if rawVal, ok := raw["numberSfixed64"]; ok {
		var num int64
		if err := json.Unmarshal(rawVal, &num); err == nil {
			raw["numberSfixed64"], _ = json.Marshal(strconv.FormatInt(num, 10))
		}
	}

	// Convert numberFixed64 from number to string for protojson
	if rawVal, ok := raw["numberFixed64"]; ok {
		var num uint64
		if err := json.Unmarshal(rawVal, &num); err == nil {
			raw["numberFixed64"], _ = json.Marshal(strconv.FormatUint(num, 10))
		}
	}

	// Convert repeated repeatedNumberInt64 from numbers to strings for protojson
	if rawVal, ok := raw["repeatedNumberInt64"]; ok {
		var nums []int64
		if err := json.Unmarshal(rawVal, &nums); err == nil {
			strs := make([]string, len(nums))
			for i, n := range nums {
				strs[i] = strconv.FormatInt(n, 10)
			}
			raw["repeatedNumberInt64"], _ = json.Marshal(strs)
		}
	}

	// Convert optionalNumberInt64 from number to string for protojson
	if rawVal, ok := raw["optionalNumberInt64"]; ok {
		var num int64
		if err := json.Unmarshal(rawVal, &num); err == nil {
			raw["optionalNumberInt64"], _ = json.Marshal(strconv.FormatInt(num, 10))
		}
	}

	// Convert commentedNumberInt64 from number to string for protojson
	if rawVal, ok := raw["commentedNumberInt64"]; ok {
		var num int64
		if err := json.Unmarshal(rawVal, &num); err == nil {
			raw["commentedNumberInt64"], _ = json.Marshal(strconv.FormatInt(num, 10))
		}
	}

	// Re-marshal to JSON with string values for protojson
	modified, err := json.Marshal(raw)
	if err != nil {
		return err
	}

	// Use protojson to unmarshal the rest
	return protojson.Unmarshal(modified, x)
}
