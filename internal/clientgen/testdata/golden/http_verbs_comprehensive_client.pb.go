// Code generated by protoc-gen-go-client. DO NOT EDIT.
// source: http_verbs_comprehensive.proto

package generated

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"

	sebufhttp "github.com/SebastienMelki/sebuf/http"
)

const (
	// ContentTypeJSON is the content type for JSON requests/responses.
	ContentTypeJSON = "application/json"
	// ContentTypeProto is the content type for binary protobuf requests/responses.
	ContentTypeProto = "application/x-protobuf"
)

// RESTfulAPIServiceClient is the client API for RESTfulAPIService service.
type RESTfulAPIServiceClient interface {
	ListResources(ctx context.Context, req *ListResourcesRequest, opts ...RESTfulAPIServiceCallOption) (*ListResourcesResponse, error)
	GetResource(ctx context.Context, req *GetResourceRequest, opts ...RESTfulAPIServiceCallOption) (*Resource, error)
	GetNestedResource(ctx context.Context, req *GetNestedResourceRequest, opts ...RESTfulAPIServiceCallOption) (*Resource, error)
	CreateResource(ctx context.Context, req *CreateResourceRequest, opts ...RESTfulAPIServiceCallOption) (*Resource, error)
	UpdateResource(ctx context.Context, req *UpdateResourceRequest, opts ...RESTfulAPIServiceCallOption) (*Resource, error)
	PatchResource(ctx context.Context, req *PatchResourceRequest, opts ...RESTfulAPIServiceCallOption) (*Resource, error)
	DeleteResource(ctx context.Context, req *DeleteResourceRequest, opts ...RESTfulAPIServiceCallOption) (*DeleteResourceResponse, error)
	DefaultPostMethod(ctx context.Context, req *DefaultPostRequest, opts ...RESTfulAPIServiceCallOption) (*DefaultPostResponse, error)
	SearchResources(ctx context.Context, req *SearchResourcesRequest, opts ...RESTfulAPIServiceCallOption) (*ListResourcesResponse, error)
}

// rESTfulAPIServiceClient is the implementation of RESTfulAPIServiceClient.
type rESTfulAPIServiceClient struct {
	baseURL        string
	httpClient     *http.Client
	contentType    string
	defaultHeaders map[string]string
}

var _ RESTfulAPIServiceClient = (*rESTfulAPIServiceClient)(nil)

// RESTfulAPIServiceClientOption configures a RESTfulAPIService client.
type RESTfulAPIServiceClientOption func(*rESTfulAPIServiceClient)

// WithRESTfulAPIServiceHTTPClient sets the HTTP client to use for requests.
func WithRESTfulAPIServiceHTTPClient(client *http.Client) RESTfulAPIServiceClientOption {
	return func(c *rESTfulAPIServiceClient) {
		c.httpClient = client
	}
}

// WithRESTfulAPIServiceContentType sets the default content type for requests.
// Use ContentTypeJSON or ContentTypeProto.
func WithRESTfulAPIServiceContentType(contentType string) RESTfulAPIServiceClientOption {
	return func(c *rESTfulAPIServiceClient) {
		c.contentType = contentType
	}
}

// WithRESTfulAPIServiceDefaultHeader sets a default header to include in all requests.
func WithRESTfulAPIServiceDefaultHeader(key, value string) RESTfulAPIServiceClientOption {
	return func(c *rESTfulAPIServiceClient) {
		if c.defaultHeaders == nil {
			c.defaultHeaders = make(map[string]string)
		}
		c.defaultHeaders[key] = value
	}
}

// RESTfulAPIServiceCallOption configures a single RPC call.
type RESTfulAPIServiceCallOption func(*rESTfulAPIServiceCallOptions)

// rESTfulAPIServiceCallOptions holds options for a single RPC call.
type rESTfulAPIServiceCallOptions struct {
	headers     map[string]string
	contentType string
}

// WithRESTfulAPIServiceHeader adds a header to a single request.
func WithRESTfulAPIServiceHeader(key, value string) RESTfulAPIServiceCallOption {
	return func(o *rESTfulAPIServiceCallOptions) {
		if o.headers == nil {
			o.headers = make(map[string]string)
		}
		o.headers[key] = value
	}
}

// WithRESTfulAPIServiceCallContentType sets the content type for a single request.
func WithRESTfulAPIServiceCallContentType(contentType string) RESTfulAPIServiceCallOption {
	return func(o *rESTfulAPIServiceCallOptions) {
		o.contentType = contentType
	}
}

// WithRESTfulAPIServiceAPIKey API key for authentication
func WithRESTfulAPIServiceAPIKey(value string) RESTfulAPIServiceClientOption {
	return WithRESTfulAPIServiceDefaultHeader("X-API-Key", value)
}

// WithRESTfulAPIServiceCallAPIKey API key for authentication for a single request.
func WithRESTfulAPIServiceCallAPIKey(value string) RESTfulAPIServiceCallOption {
	return WithRESTfulAPIServiceHeader("X-API-Key", value)
}

// WithRESTfulAPIServiceCallRequestID sets the X-Request-ID header for a single request.
func WithRESTfulAPIServiceCallRequestID(value string) RESTfulAPIServiceCallOption {
	return WithRESTfulAPIServiceHeader("X-Request-ID", value)
}

// NewRESTfulAPIServiceClient creates a new RESTfulAPIService client.
func NewRESTfulAPIServiceClient(baseURL string, opts ...RESTfulAPIServiceClientOption) RESTfulAPIServiceClient {
	c := &rESTfulAPIServiceClient{
		baseURL:        strings.TrimSuffix(baseURL, "/"),
		httpClient:     http.DefaultClient,
		contentType:    ContentTypeJSON,
		defaultHeaders: make(map[string]string),
	}

	for _, opt := range opts {
		opt(c)
	}

	return c
}

// ListResources calls the ListResources RPC.
func (c *rESTfulAPIServiceClient) ListResources(ctx context.Context, req *ListResourcesRequest, opts ...RESTfulAPIServiceCallOption) (*ListResourcesResponse, error) {
	callOpts := &rESTfulAPIServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/api/v1/resources"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.Page != 0 {
		queryParams.Set("page", fmt.Sprint(req.Page))
	}
	if req.PageSize != 0 {
		queryParams.Set("page_size", fmt.Sprint(req.PageSize))
	}
	if req.Filter != "" {
		queryParams.Set("filter", fmt.Sprint(req.Filter))
	}
	if req.IncludeDeleted != false {
		queryParams.Set("include_deleted", fmt.Sprint(req.IncludeDeleted))
	}
	if req.SinceTimestamp != 0 {
		queryParams.Set("since_timestamp", fmt.Sprint(req.SinceTimestamp))
	}
	if req.MaxId != 0 {
		queryParams.Set("max_id", fmt.Sprint(req.MaxId))
	}
	if req.MinScore != 0 {
		queryParams.Set("min_score", fmt.Sprint(req.MinScore))
	}
	if req.MaxScore != 0 {
		queryParams.Set("max_score", fmt.Sprint(req.MaxScore))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &ListResourcesResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetResource calls the GetResource RPC.
func (c *rESTfulAPIServiceClient) GetResource(ctx context.Context, req *GetResourceRequest, opts ...RESTfulAPIServiceCallOption) (*Resource, error) {
	callOpts := &rESTfulAPIServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/api/v1/resources/{resource_id}"
	path = strings.Replace(path, "{resource_id}", url.PathEscape(fmt.Sprint(req.ResourceId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &Resource{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// GetNestedResource calls the GetNestedResource RPC.
func (c *rESTfulAPIServiceClient) GetNestedResource(ctx context.Context, req *GetNestedResourceRequest, opts ...RESTfulAPIServiceCallOption) (*Resource, error) {
	callOpts := &rESTfulAPIServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/api/v1/orgs/{org_id}/teams/{team_id}/resources/{resource_id}"
	path = strings.Replace(path, "{org_id}", url.PathEscape(fmt.Sprint(req.OrgId)), 1)
	path = strings.Replace(path, "{team_id}", url.PathEscape(fmt.Sprint(req.TeamId)), 1)
	path = strings.Replace(path, "{resource_id}", url.PathEscape(fmt.Sprint(req.ResourceId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &Resource{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// CreateResource calls the CreateResource RPC.
func (c *rESTfulAPIServiceClient) CreateResource(ctx context.Context, req *CreateResourceRequest, opts ...RESTfulAPIServiceCallOption) (*Resource, error) {
	callOpts := &rESTfulAPIServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/api/v1/resources"
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "POST", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &Resource{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// UpdateResource calls the UpdateResource RPC.
func (c *rESTfulAPIServiceClient) UpdateResource(ctx context.Context, req *UpdateResourceRequest, opts ...RESTfulAPIServiceCallOption) (*Resource, error) {
	callOpts := &rESTfulAPIServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/api/v1/resources/{resource_id}"
	path = strings.Replace(path, "{resource_id}", url.PathEscape(fmt.Sprint(req.ResourceId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "PUT", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &Resource{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// PatchResource calls the PatchResource RPC.
func (c *rESTfulAPIServiceClient) PatchResource(ctx context.Context, req *PatchResourceRequest, opts ...RESTfulAPIServiceCallOption) (*Resource, error) {
	callOpts := &rESTfulAPIServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/api/v1/resources/{resource_id}"
	path = strings.Replace(path, "{resource_id}", url.PathEscape(fmt.Sprint(req.ResourceId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "PATCH", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &Resource{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// DeleteResource calls the DeleteResource RPC.
func (c *rESTfulAPIServiceClient) DeleteResource(ctx context.Context, req *DeleteResourceRequest, opts ...RESTfulAPIServiceCallOption) (*DeleteResourceResponse, error) {
	callOpts := &rESTfulAPIServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/api/v1/resources/{resource_id}"
	path = strings.Replace(path, "{resource_id}", url.PathEscape(fmt.Sprint(req.ResourceId)), 1)
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "DELETE", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &DeleteResourceResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// DefaultPostMethod calls the DefaultPostMethod RPC.
func (c *rESTfulAPIServiceClient) DefaultPostMethod(ctx context.Context, req *DefaultPostRequest, opts ...RESTfulAPIServiceCallOption) (*DefaultPostResponse, error) {
	callOpts := &rESTfulAPIServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/api/v1/legacy/action"
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "POST", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &DefaultPostResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

// SearchResources calls the SearchResources RPC.
func (c *rESTfulAPIServiceClient) SearchResources(ctx context.Context, req *SearchResourcesRequest, opts ...RESTfulAPIServiceCallOption) (*ListResourcesResponse, error) {
	callOpts := &rESTfulAPIServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/api/v1/resources/search"
	reqURL := c.baseURL + path

	// Add query parameters
	queryParams := url.Values{}
	if req.StatusFilter != "" {
		queryParams.Set("status", fmt.Sprint(req.StatusFilter))
	}
	if req.Query != "" {
		queryParams.Set("q", fmt.Sprint(req.Query))
	}
	if len(queryParams) > 0 {
		reqURL += "?" + queryParams.Encode()
	}

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &ListResourcesResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

func (c *rESTfulAPIServiceClient) marshalRequest(req proto.Message, contentType string) ([]byte, error) {
	switch contentType {
	case ContentTypeJSON:
		// Check for custom JSON marshaler (unwrap support)
		if marshaler, ok := req.(json.Marshaler); ok {
			return marshaler.MarshalJSON()
		}
		return protojson.Marshal(req)
	case ContentTypeProto:
		return proto.Marshal(req)
	default:
		return protojson.Marshal(req)
	}
}

func (c *rESTfulAPIServiceClient) handleErrorResponse(statusCode int, body []byte, contentType string) error {
	// Try to parse as ValidationError first (for 400 errors)
	if statusCode == http.StatusBadRequest {
		validationErr := &sebufhttp.ValidationError{}
		if unmarshalErr := c.unmarshalResponse(body, validationErr, contentType); unmarshalErr == nil {
			return validationErr
		}
	}

	// Try to parse as generic Error
	genericErr := &sebufhttp.Error{}
	if unmarshalErr := c.unmarshalResponse(body, genericErr, contentType); unmarshalErr == nil {
		return genericErr
	}

	// Fallback to raw error message
	return fmt.Errorf("request failed with status %d: %s", statusCode, string(body))
}

func (c *rESTfulAPIServiceClient) unmarshalResponse(body []byte, msg proto.Message, contentType string) error {
	if len(body) == 0 {
		return nil
	}

	switch contentType {
	case ContentTypeJSON:
		// Check for custom JSON unmarshaler (unwrap support)
		if unmarshaler, ok := msg.(json.Unmarshaler); ok {
			return unmarshaler.UnmarshalJSON(body)
		}
		return protojson.Unmarshal(body, msg)
	case ContentTypeProto:
		return proto.Unmarshal(body, msg)
	default:
		return protojson.Unmarshal(body, msg)
	}
}

// BackwardCompatServiceClient is the client API for BackwardCompatService service.
type BackwardCompatServiceClient interface {
	LegacyAction(ctx context.Context, req *LegacyRequest, opts ...BackwardCompatServiceCallOption) (*LegacyResponse, error)
}

// backwardCompatServiceClient is the implementation of BackwardCompatServiceClient.
type backwardCompatServiceClient struct {
	baseURL        string
	httpClient     *http.Client
	contentType    string
	defaultHeaders map[string]string
}

var _ BackwardCompatServiceClient = (*backwardCompatServiceClient)(nil)

// BackwardCompatServiceClientOption configures a BackwardCompatService client.
type BackwardCompatServiceClientOption func(*backwardCompatServiceClient)

// WithBackwardCompatServiceHTTPClient sets the HTTP client to use for requests.
func WithBackwardCompatServiceHTTPClient(client *http.Client) BackwardCompatServiceClientOption {
	return func(c *backwardCompatServiceClient) {
		c.httpClient = client
	}
}

// WithBackwardCompatServiceContentType sets the default content type for requests.
// Use ContentTypeJSON or ContentTypeProto.
func WithBackwardCompatServiceContentType(contentType string) BackwardCompatServiceClientOption {
	return func(c *backwardCompatServiceClient) {
		c.contentType = contentType
	}
}

// WithBackwardCompatServiceDefaultHeader sets a default header to include in all requests.
func WithBackwardCompatServiceDefaultHeader(key, value string) BackwardCompatServiceClientOption {
	return func(c *backwardCompatServiceClient) {
		if c.defaultHeaders == nil {
			c.defaultHeaders = make(map[string]string)
		}
		c.defaultHeaders[key] = value
	}
}

// BackwardCompatServiceCallOption configures a single RPC call.
type BackwardCompatServiceCallOption func(*backwardCompatServiceCallOptions)

// backwardCompatServiceCallOptions holds options for a single RPC call.
type backwardCompatServiceCallOptions struct {
	headers     map[string]string
	contentType string
}

// WithBackwardCompatServiceHeader adds a header to a single request.
func WithBackwardCompatServiceHeader(key, value string) BackwardCompatServiceCallOption {
	return func(o *backwardCompatServiceCallOptions) {
		if o.headers == nil {
			o.headers = make(map[string]string)
		}
		o.headers[key] = value
	}
}

// WithBackwardCompatServiceCallContentType sets the content type for a single request.
func WithBackwardCompatServiceCallContentType(contentType string) BackwardCompatServiceCallOption {
	return func(o *backwardCompatServiceCallOptions) {
		o.contentType = contentType
	}
}

// NewBackwardCompatServiceClient creates a new BackwardCompatService client.
func NewBackwardCompatServiceClient(baseURL string, opts ...BackwardCompatServiceClientOption) BackwardCompatServiceClient {
	c := &backwardCompatServiceClient{
		baseURL:        strings.TrimSuffix(baseURL, "/"),
		httpClient:     http.DefaultClient,
		contentType:    ContentTypeJSON,
		defaultHeaders: make(map[string]string),
	}

	for _, opt := range opts {
		opt(c)
	}

	return c
}

// LegacyAction calls the LegacyAction RPC.
func (c *backwardCompatServiceClient) LegacyAction(ctx context.Context, req *LegacyRequest, opts ...BackwardCompatServiceCallOption) (*LegacyResponse, error) {
	callOpts := &backwardCompatServiceCallOptions{}
	for _, opt := range opts {
		opt(callOpts)
	}

	// Build URL
	path := "/legacyAction"
	reqURL := c.baseURL + path

	contentType := c.contentType
	if callOpts.contentType != "" {
		contentType = callOpts.contentType
	}

	// Marshal request body
	body, err := c.marshalRequest(req, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "POST", reqURL, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	httpReq.Header.Set("Content-Type", contentType)
	for k, v := range c.defaultHeaders {
		httpReq.Header.Set(k, v)
	}
	for k, v := range callOpts.headers {
		httpReq.Header.Set(k, v)
	}

	// Execute request
	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)
	}

	// Unmarshal response
	result := &LegacyResponse{}
	if err := c.unmarshalResponse(respBody, result, contentType); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return result, nil
}

func (c *backwardCompatServiceClient) marshalRequest(req proto.Message, contentType string) ([]byte, error) {
	switch contentType {
	case ContentTypeJSON:
		// Check for custom JSON marshaler (unwrap support)
		if marshaler, ok := req.(json.Marshaler); ok {
			return marshaler.MarshalJSON()
		}
		return protojson.Marshal(req)
	case ContentTypeProto:
		return proto.Marshal(req)
	default:
		return protojson.Marshal(req)
	}
}

func (c *backwardCompatServiceClient) handleErrorResponse(statusCode int, body []byte, contentType string) error {
	// Try to parse as ValidationError first (for 400 errors)
	if statusCode == http.StatusBadRequest {
		validationErr := &sebufhttp.ValidationError{}
		if unmarshalErr := c.unmarshalResponse(body, validationErr, contentType); unmarshalErr == nil {
			return validationErr
		}
	}

	// Try to parse as generic Error
	genericErr := &sebufhttp.Error{}
	if unmarshalErr := c.unmarshalResponse(body, genericErr, contentType); unmarshalErr == nil {
		return genericErr
	}

	// Fallback to raw error message
	return fmt.Errorf("request failed with status %d: %s", statusCode, string(body))
}

func (c *backwardCompatServiceClient) unmarshalResponse(body []byte, msg proto.Message, contentType string) error {
	if len(body) == 0 {
		return nil
	}

	switch contentType {
	case ContentTypeJSON:
		// Check for custom JSON unmarshaler (unwrap support)
		if unmarshaler, ok := msg.(json.Unmarshaler); ok {
			return unmarshaler.UnmarshalJSON(body)
		}
		return protojson.Unmarshal(body, msg)
	case ContentTypeProto:
		return proto.Unmarshal(body, msg)
	default:
		return protojson.Unmarshal(body, msg)
	}
}
