package clientgen

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"

	"github.com/SebastienMelki/sebuf/http"
)

// Generator handles HTTP client code generation for protobuf services.
type Generator struct {
	plugin *protogen.Plugin
}

// New creates a new HTTP client generator.
func New(plugin *protogen.Plugin) *Generator {
	return &Generator{
		plugin: plugin,
	}
}

// Generate processes all files and generates HTTP clients.
func (g *Generator) Generate() error {
	for _, file := range g.plugin.Files {
		if !file.Generate {
			continue
		}
		if err := g.generateFile(file); err != nil {
			return err
		}
	}
	return nil
}

func (g *Generator) generateFile(file *protogen.File) error {
	if len(file.Services) == 0 {
		return nil
	}

	// Generate client file
	return g.generateClientFile(file)
}

func (g *Generator) generateClientFile(file *protogen.File) error {
	filename := file.GeneratedFilenamePrefix + "_client.pb.go"
	gf := g.plugin.NewGeneratedFile(filename, file.GoImportPath)

	g.writeHeader(gf, file)
	g.writeImports(gf)

	// Generate content type constants once at file level
	g.generateContentTypeConstants(gf)

	for _, service := range file.Services {
		if err := g.generateServiceClient(gf, file, service); err != nil {
			return err
		}
	}

	return nil
}

func (g *Generator) writeHeader(gf *protogen.GeneratedFile, file *protogen.File) {
	gf.P("// Code generated by protoc-gen-go-client. DO NOT EDIT.")
	gf.P("// source: ", file.Desc.Path())
	gf.P()
	gf.P("package ", file.GoPackageName)
	gf.P()
}

func (g *Generator) writeImports(gf *protogen.GeneratedFile) {
	gf.P("import (")
	gf.P(`"bytes"`)
	gf.P(`"context"`)
	gf.P(`"fmt"`)
	gf.P(`"io"`)
	gf.P(`"net/http"`)
	gf.P(`"net/url"`)
	gf.P(`"strings"`)
	gf.P()
	gf.P(`"google.golang.org/protobuf/encoding/protojson"`)
	gf.P(`"google.golang.org/protobuf/proto"`)
	gf.P()
	gf.P(`sebufhttp "github.com/SebastienMelki/sebuf/http"`)
	gf.P(")")
	gf.P()
}

func (g *Generator) generateServiceClient(
	gf *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
) error {
	serviceName := service.GoName

	// Generate client interface
	g.generateClientInterface(gf, service)

	// Generate client struct
	g.generateClientStruct(gf, serviceName)

	// Generate ClientOption type and options
	g.generateClientOptions(gf, serviceName)

	// Generate CallOption type and options
	g.generateCallOptions(gf, serviceName)

	// Generate header helper options from annotations
	g.generateHeaderHelperOptions(gf, service)

	// Generate constructor
	g.generateConstructor(gf, serviceName)

	// Generate RPC methods
	for _, method := range service.Methods {
		if err := g.generateRPCMethod(gf, file, service, method); err != nil {
			return err
		}
	}

	// Generate helper methods
	g.generateHelperMethods(gf, serviceName)

	return nil
}

func (g *Generator) generateClientInterface(gf *protogen.GeneratedFile, service *protogen.Service) {
	serviceName := service.GoName

	gf.P("// ", serviceName, "Client is the client API for ", serviceName, " service.")
	gf.P("type ", serviceName, "Client interface {")
	for _, method := range service.Methods {
		gf.P(
			method.GoName,
			"(ctx context.Context, req *",
			method.Input.GoIdent,
			", opts ...",
			serviceName,
			"CallOption) (*",
			method.Output.GoIdent,
			", error)",
		)
	}
	gf.P("}")
	gf.P()
}

func (g *Generator) generateClientStruct(gf *protogen.GeneratedFile, serviceName string) {
	lowerName := lowerFirst(serviceName)

	gf.P("// ", lowerName, "Client is the implementation of ", serviceName, "Client.")
	gf.P("type ", lowerName, "Client struct {")
	gf.P("baseURL string")
	gf.P("httpClient *http.Client")
	gf.P("contentType string")
	gf.P("defaultHeaders map[string]string")
	gf.P("}")
	gf.P()

	// Ensure struct implements interface
	gf.P("var _ ", serviceName, "Client = (*", lowerName, "Client)(nil)")
	gf.P()
}

func (g *Generator) generateContentTypeConstants(gf *protogen.GeneratedFile) {
	gf.P("const (")
	gf.P("// ContentTypeJSON is the content type for JSON requests/responses.")
	gf.P(`ContentTypeJSON = "application/json"`)
	gf.P("// ContentTypeProto is the content type for binary protobuf requests/responses.")
	gf.P(`ContentTypeProto = "application/x-protobuf"`)
	gf.P(")")
	gf.P()
}

func (g *Generator) generateClientOptions(gf *protogen.GeneratedFile, serviceName string) {
	lowerName := lowerFirst(serviceName)

	gf.P("// ", serviceName, "ClientOption configures a ", serviceName, " client.")
	gf.P("type ", serviceName, "ClientOption func(*", lowerName, "Client)")
	gf.P()

	// With{Service}HTTPClient
	gf.P("// With", serviceName, "HTTPClient sets the HTTP client to use for requests.")
	gf.P("func With", serviceName, "HTTPClient(client *http.Client) ", serviceName, "ClientOption {")
	gf.P("return func(c *", lowerName, "Client) {")
	gf.P("c.httpClient = client")
	gf.P("}")
	gf.P("}")
	gf.P()

	// With{Service}ContentType
	gf.P("// With", serviceName, "ContentType sets the default content type for requests.")
	gf.P("// Use ContentTypeJSON or ContentTypeProto.")
	gf.P("func With", serviceName, "ContentType(contentType string) ", serviceName, "ClientOption {")
	gf.P("return func(c *", lowerName, "Client) {")
	gf.P("c.contentType = contentType")
	gf.P("}")
	gf.P("}")
	gf.P()

	// With{Service}DefaultHeader
	gf.P("// With", serviceName, "DefaultHeader sets a default header to include in all requests.")
	gf.P("func With", serviceName, "DefaultHeader(key, value string) ", serviceName, "ClientOption {")
	gf.P("return func(c *", lowerName, "Client) {")
	gf.P("if c.defaultHeaders == nil {")
	gf.P("c.defaultHeaders = make(map[string]string)")
	gf.P("}")
	gf.P("c.defaultHeaders[key] = value")
	gf.P("}")
	gf.P("}")
	gf.P()
}

func (g *Generator) generateCallOptions(gf *protogen.GeneratedFile, serviceName string) {
	lowerName := lowerFirst(serviceName)

	// CallOption type
	gf.P("// ", serviceName, "CallOption configures a single RPC call.")
	gf.P("type ", serviceName, "CallOption func(*", lowerName, "CallOptions)")
	gf.P()

	// CallOptions struct
	gf.P("// ", lowerName, "CallOptions holds options for a single RPC call.")
	gf.P("type ", lowerName, "CallOptions struct {")
	gf.P("headers map[string]string")
	gf.P("contentType string")
	gf.P("}")
	gf.P()

	// With{Service}Header
	gf.P("// With", serviceName, "Header adds a header to a single request.")
	gf.P("func With", serviceName, "Header(key, value string) ", serviceName, "CallOption {")
	gf.P("return func(o *", lowerName, "CallOptions) {")
	gf.P("if o.headers == nil {")
	gf.P("o.headers = make(map[string]string)")
	gf.P("}")
	gf.P("o.headers[key] = value")
	gf.P("}")
	gf.P("}")
	gf.P()

	// With{Service}CallContentType
	gf.P("// With", serviceName, "CallContentType sets the content type for a single request.")
	gf.P("func With", serviceName, "CallContentType(contentType string) ", serviceName, "CallOption {")
	gf.P("return func(o *", lowerName, "CallOptions) {")
	gf.P("o.contentType = contentType")
	gf.P("}")
	gf.P("}")
	gf.P()
}

func (g *Generator) generateHeaderHelperOptions(gf *protogen.GeneratedFile, service *protogen.Service) {
	serviceName := service.GoName

	// Generate helper options from service headers
	serviceHeaders := getServiceHeaders(service)
	for _, header := range serviceHeaders {
		g.generateHeaderOption(gf, serviceName, header, true)
	}

	// Generate helper options from method headers
	for _, method := range service.Methods {
		methodHeaders := getMethodHeaders(method)
		for _, header := range methodHeaders {
			g.generateHeaderOption(gf, serviceName, header, false)
		}
	}
}

func (g *Generator) generateHeaderOption(
	gf *protogen.GeneratedFile,
	serviceName string,
	header *http.Header,
	isClientOption bool,
) {
	headerName := header.GetName()
	funcName := headerNameToFuncName(headerName)
	description := header.GetDescription()
	if description == "" {
		description = fmt.Sprintf("sets the %s header", headerName)
	}

	if isClientOption {
		// Generate ClientOption for service-level headers
		gf.P("// With", serviceName, funcName, " ", description)
		gf.P("func With", serviceName, funcName, "(value string) ", serviceName, "ClientOption {")
		gf.P("return With", serviceName, "DefaultHeader(\"", headerName, "\", value)")
		gf.P("}")
		gf.P()
	}

	// Generate CallOption for both service and method headers
	gf.P("// With", serviceName, "Call", funcName, " ", description, " for a single request.")
	gf.P("func With", serviceName, "Call", funcName, "(value string) ", serviceName, "CallOption {")
	gf.P("return With", serviceName, "Header(\"", headerName, "\", value)")
	gf.P("}")
	gf.P()
}

func (g *Generator) generateConstructor(gf *protogen.GeneratedFile, serviceName string) {
	lowerName := lowerFirst(serviceName)

	gf.P("// New", serviceName, "Client creates a new ", serviceName, " client.")
	gf.P(
		"func New",
		serviceName,
		"Client(baseURL string, opts ...",
		serviceName,
		"ClientOption) ",
		serviceName,
		"Client {",
	)
	gf.P("c := &", lowerName, "Client{")
	gf.P("baseURL: strings.TrimSuffix(baseURL, \"/\"),")
	gf.P("httpClient: http.DefaultClient,")
	gf.P("contentType: ContentTypeJSON,")
	gf.P("defaultHeaders: make(map[string]string),")
	gf.P("}")
	gf.P()
	gf.P("for _, opt := range opts {")
	gf.P("opt(c)")
	gf.P("}")
	gf.P()
	gf.P("return c")
	gf.P("}")
	gf.P()
}

// rpcMethodConfig holds the configuration for generating an RPC method.
type rpcMethodConfig struct {
	serviceName string
	lowerName   string
	methodName  string
	httpMethod  string
	fullPath    string
	pathParams  []string
	queryParams []QueryParam
	hasBody     bool
}

func (g *Generator) buildRPCMethodConfig(service *protogen.Service, method *protogen.Method) *rpcMethodConfig {
	serviceName := service.GoName
	methodName := method.GoName

	// Get HTTP config
	httpConfig := getMethodHTTPConfig(method)
	httpMethod := "POST"
	httpPath := "/" + lowerFirst(methodName)
	var pathParams []string

	if httpConfig != nil {
		if httpConfig.Method != "" {
			httpMethod = httpConfig.Method
		}
		if httpConfig.Path != "" {
			httpPath = httpConfig.Path
		}
		pathParams = httpConfig.PathParams
	}

	// Get base path from service config
	serviceConfig := getServiceHTTPConfig(service)
	basePath := ""
	if serviceConfig != nil {
		basePath = serviceConfig.BasePath
	}

	// Combine base path and method path
	fullPath := httpPath
	if basePath != "" {
		basePath = strings.TrimSuffix(basePath, "/")
		if !strings.HasPrefix(httpPath, "/") {
			httpPath = "/" + httpPath
		}
		fullPath = basePath + httpPath
	}

	return &rpcMethodConfig{
		serviceName: serviceName,
		lowerName:   lowerFirst(serviceName),
		methodName:  methodName,
		httpMethod:  httpMethod,
		fullPath:    fullPath,
		pathParams:  pathParams,
		queryParams: getQueryParams(method.Input),
		hasBody:     httpMethod == "POST" || httpMethod == "PUT" || httpMethod == "PATCH",
	}
}

func (g *Generator) generateRPCMethod(
	gf *protogen.GeneratedFile,
	_ *protogen.File,
	service *protogen.Service,
	method *protogen.Method,
) error {
	cfg := g.buildRPCMethodConfig(service, method)

	g.generateRPCMethodSignature(gf, cfg, method)
	g.generateRPCMethodCallOptions(gf, cfg)
	g.generateRPCMethodURLBuilding(gf, cfg)
	g.generateRPCMethodRequest(gf, cfg)
	g.generateRPCMethodHeaders(gf, cfg)
	g.generateRPCMethodExecution(gf)
	g.generateRPCMethodResponse(gf, method)

	return nil
}

func (g *Generator) generateRPCMethodSignature(
	gf *protogen.GeneratedFile,
	cfg *rpcMethodConfig,
	method *protogen.Method,
) {
	gf.P("// ", cfg.methodName, " calls the ", cfg.methodName, " RPC.")
	gf.P(
		"func (c *", cfg.lowerName, "Client) ", cfg.methodName,
		"(ctx context.Context, req *", method.Input.GoIdent,
		", opts ...", cfg.serviceName, "CallOption) (*", method.Output.GoIdent, ", error) {",
	)
}

func (g *Generator) generateRPCMethodCallOptions(gf *protogen.GeneratedFile, cfg *rpcMethodConfig) {
	gf.P("callOpts := &", cfg.lowerName, "CallOptions{}")
	gf.P("for _, opt := range opts {")
	gf.P("opt(callOpts)")
	gf.P("}")
	gf.P()
}

func (g *Generator) generateRPCMethodURLBuilding(gf *protogen.GeneratedFile, cfg *rpcMethodConfig) {
	gf.P("// Build URL")
	g.generateURLBuilding(gf, cfg.fullPath, cfg.pathParams, cfg.queryParams, cfg.httpMethod)
}

func (g *Generator) generateRPCMethodRequest(gf *protogen.GeneratedFile, cfg *rpcMethodConfig) {
	gf.P()
	gf.P("contentType := c.contentType")
	gf.P("if callOpts.contentType != \"\" {")
	gf.P("contentType = callOpts.contentType")
	gf.P("}")
	gf.P()

	if cfg.hasBody {
		gf.P("// Marshal request body")
		gf.P("body, err := c.marshalRequest(req, contentType)")
		gf.P("if err != nil {")
		gf.P("return nil, fmt.Errorf(\"failed to marshal request: %w\", err)")
		gf.P("}")
		gf.P()
		gf.P("// Create HTTP request")
		gf.P("httpReq, err := http.NewRequestWithContext(ctx, \"", cfg.httpMethod, "\", reqURL, bytes.NewReader(body))")
	} else {
		gf.P("// Create HTTP request")
		gf.P("httpReq, err := http.NewRequestWithContext(ctx, \"", cfg.httpMethod, "\", reqURL, nil)")
	}

	gf.P("if err != nil {")
	gf.P("return nil, fmt.Errorf(\"failed to create request: %w\", err)")
	gf.P("}")
}

func (g *Generator) generateRPCMethodHeaders(gf *protogen.GeneratedFile, _ *rpcMethodConfig) {
	gf.P()
	gf.P("// Set headers")
	gf.P("httpReq.Header.Set(\"Content-Type\", contentType)")
	gf.P("for k, v := range c.defaultHeaders {")
	gf.P("httpReq.Header.Set(k, v)")
	gf.P("}")
	gf.P("for k, v := range callOpts.headers {")
	gf.P("httpReq.Header.Set(k, v)")
	gf.P("}")
}

func (g *Generator) generateRPCMethodExecution(gf *protogen.GeneratedFile) {
	gf.P()
	gf.P("// Execute request")
	gf.P("resp, err := c.httpClient.Do(httpReq)")
	gf.P("if err != nil {")
	gf.P("return nil, fmt.Errorf(\"failed to execute request: %w\", err)")
	gf.P("}")
	gf.P("defer resp.Body.Close()")
}

func (g *Generator) generateRPCMethodResponse(gf *protogen.GeneratedFile, method *protogen.Method) {
	gf.P()
	gf.P("// Read response body")
	gf.P("respBody, err := io.ReadAll(resp.Body)")
	gf.P("if err != nil {")
	gf.P("return nil, fmt.Errorf(\"failed to read response body: %w\", err)")
	gf.P("}")
	gf.P()
	gf.P("// Check for error status codes")
	gf.P("if resp.StatusCode >= 400 {")
	gf.P("return nil, c.handleErrorResponse(resp.StatusCode, respBody, contentType)")
	gf.P("}")
	gf.P()
	gf.P("// Unmarshal response")
	gf.P("result := &", method.Output.GoIdent, "{}")
	gf.P("if err := c.unmarshalResponse(respBody, result, contentType); err != nil {")
	gf.P("return nil, fmt.Errorf(\"failed to unmarshal response: %w\", err)")
	gf.P("}")
	gf.P()
	gf.P("return result, nil")
	gf.P("}")
	gf.P()
}

func (g *Generator) generateURLBuilding(
	gf *protogen.GeneratedFile,
	fullPath string,
	pathParams []string,
	queryParams []QueryParam,
	httpMethod string,
) {
	// Start with base path
	gf.P("path := \"", fullPath, "\"")

	// Replace path parameters
	if len(pathParams) > 0 {
		for _, param := range pathParams {
			goFieldName := snakeToUpperCamel(param)
			gf.P(
				"path = strings.Replace(path, \"{",
				param,
				"}\", url.PathEscape(fmt.Sprint(req.",
				goFieldName,
				")), 1)",
			)
		}
	}

	gf.P("reqURL := c.baseURL + path")

	// Add query parameters for GET/DELETE
	if (httpMethod == "GET" || httpMethod == "DELETE") && len(queryParams) > 0 {
		gf.P()
		gf.P("// Add query parameters")
		gf.P("queryParams := url.Values{}")
		for _, qp := range queryParams {
			g.generateQueryParamEncoding(gf, qp)
		}
		gf.P("if len(queryParams) > 0 {")
		gf.P("reqURL += \"?\" + queryParams.Encode()")
		gf.P("}")
	}
}

func (g *Generator) generateQueryParamEncoding(gf *protogen.GeneratedFile, qp QueryParam) {
	fieldGoName := qp.FieldGoName
	paramName := qp.ParamName

	// For simplicity, we generate code that handles common types
	// In practice, the field type would determine the encoding
	gf.P("if req.", fieldGoName, " != ", getZeroValue(qp), " {")
	gf.P("queryParams.Set(\"", paramName, "\", fmt.Sprint(req.", fieldGoName, "))")
	gf.P("}")
}

func (g *Generator) generateHelperMethods(gf *protogen.GeneratedFile, serviceName string) {
	lowerName := lowerFirst(serviceName)

	// marshalRequest
	gf.P("func (c *", lowerName, "Client) marshalRequest(req proto.Message, contentType string) ([]byte, error) {")
	gf.P("switch contentType {")
	gf.P("case ContentTypeJSON:")
	gf.P("return protojson.Marshal(req)")
	gf.P("case ContentTypeProto:")
	gf.P("return proto.Marshal(req)")
	gf.P("default:")
	gf.P("return protojson.Marshal(req)")
	gf.P("}")
	gf.P("}")
	gf.P()

	// handleErrorResponse
	gf.P("func (c *", lowerName, "Client) handleErrorResponse(statusCode int, body []byte, contentType string) error {")
	gf.P("// Try to parse as ValidationError first (for 400 errors)")
	gf.P("if statusCode == http.StatusBadRequest {")
	gf.P("validationErr := &sebufhttp.ValidationError{}")
	gf.P("if unmarshalErr := c.unmarshalResponse(body, validationErr, contentType); unmarshalErr == nil {")
	gf.P("return validationErr")
	gf.P("}")
	gf.P("}")
	gf.P()
	gf.P("// Try to parse as generic Error")
	gf.P("genericErr := &sebufhttp.Error{}")
	gf.P("if unmarshalErr := c.unmarshalResponse(body, genericErr, contentType); unmarshalErr == nil {")
	gf.P("return genericErr")
	gf.P("}")
	gf.P()
	gf.P("// Fallback to raw error message")
	gf.P("return fmt.Errorf(\"request failed with status %d: %s\", statusCode, string(body))")
	gf.P("}")
	gf.P()

	// unmarshalResponse
	gf.P(
		"func (c *",
		lowerName,
		"Client) unmarshalResponse(body []byte, msg proto.Message, contentType string) error {",
	)
	gf.P("if len(body) == 0 {")
	gf.P("return nil")
	gf.P("}")
	gf.P()
	gf.P("switch contentType {")
	gf.P("case ContentTypeJSON:")
	gf.P("return protojson.Unmarshal(body, msg)")
	gf.P("case ContentTypeProto:")
	gf.P("return proto.Unmarshal(body, msg)")
	gf.P("default:")
	gf.P("return protojson.Unmarshal(body, msg)")
	gf.P("}")
	gf.P("}")
	gf.P()
}

// Helper functions

func lowerFirst(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func snakeToUpperCamel(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

func headerNameToFuncName(headerName string) string {
	// Convert X-API-Key to APIKey, X-Request-ID to RequestID
	name := strings.TrimPrefix(headerName, "X-")
	name = strings.ReplaceAll(name, "-", "")
	return name
}

func getZeroValue(qp QueryParam) string {
	// Return the appropriate zero value based on field kind
	switch qp.FieldKind {
	case "string":
		return `""`
	case "bool":
		return "false"
	case "int32", "sint32", "sfixed32", "int64", "sint64", "sfixed64",
		"uint32", "fixed32", "uint64", "fixed64":
		return "0"
	case "float", "double":
		return "0"
	default:
		return `""`
	}
}
