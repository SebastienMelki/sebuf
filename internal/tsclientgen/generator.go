package tsclientgen

import (
	"fmt"
	"net/http"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

// Generator handles TypeScript HTTP client code generation for protobuf services.
type Generator struct {
	plugin *protogen.Plugin
}

// New creates a new TypeScript client generator.
func New(plugin *protogen.Plugin) *Generator {
	return &Generator{
		plugin: plugin,
	}
}

// Generate processes all files and generates TypeScript clients.
func (g *Generator) Generate() error {
	for _, file := range g.plugin.Files {
		if !file.Generate {
			continue
		}
		if err := g.generateFile(file); err != nil {
			return err
		}
	}
	return nil
}

func (g *Generator) generateFile(file *protogen.File) error {
	if len(file.Services) == 0 {
		return nil
	}
	return g.generateClientFile(file)
}

func (g *Generator) generateClientFile(file *protogen.File) error {
	// Output .ts file alongside the proto source
	filename := file.GeneratedFilenamePrefix + "_client.ts"
	gf := g.plugin.NewGeneratedFile(filename, "")

	// Collect all referenced messages and enums
	ms := collectServiceMessages(file)

	// Helper to print to generated file
	p := func(format string, args ...interface{}) {
		if len(args) == 0 {
			gf.P(format)
		} else {
			gf.P(fmt.Sprintf(format, args...))
		}
	}

	// 1. Header
	g.writeHeader(p, file)

	// 2. Message interfaces
	for _, msg := range ms.orderedMessages() {
		generateInterface(p, msg)
	}

	// 3. Enum types
	for _, enum := range ms.orderedEnums() {
		generateEnumType(p, enum)
	}

	// 4. Error types
	g.writeErrorTypes(p)

	// 5. Per service: options + client class
	for _, service := range file.Services {
		if err := g.generateServiceClient(p, service); err != nil {
			return err
		}
	}

	return nil
}

func (g *Generator) writeHeader(p printer, file *protogen.File) {
	p("// Code generated by protoc-gen-ts-client. DO NOT EDIT.")
	p("// source: %s", file.Desc.Path())
	p("")
}

func (g *Generator) writeErrorTypes(p printer) {
	// FieldViolation
	p("export interface FieldViolation {")
	p("  field: string;")
	p("  description: string;")
	p("}")
	p("")

	// ValidationError
	p("export class ValidationError extends Error {")
	p("  violations: FieldViolation[];")
	p("")
	p("  constructor(violations: FieldViolation[]) {")
	p(`    super("Validation failed");`)
	p(`    this.name = "ValidationError";`)
	p("    this.violations = violations;")
	p("  }")
	p("}")
	p("")

	// ApiError
	p("export class ApiError extends Error {")
	p("  statusCode: number;")
	p("  body: string;")
	p("")
	p("  constructor(statusCode: number, message: string, body: string) {")
	p("    super(message);")
	p(`    this.name = "ApiError";`)
	p("    this.statusCode = statusCode;")
	p("    this.body = body;")
	p("  }")
	p("}")
	p("")
}

func (g *Generator) generateServiceClient(p printer, service *protogen.Service) error {
	serviceName := service.GoName

	// Client options interface
	g.generateClientOptionsInterface(p, service)

	// Call options interface
	g.generateCallOptionsInterface(p, service)

	// Client class
	g.generateClientClass(p, service)

	_ = serviceName
	return nil
}

// generateClientOptionsInterface generates the {Service}ClientOptions interface.
func (g *Generator) generateClientOptionsInterface(p printer, service *protogen.Service) {
	serviceName := service.GoName

	p("export interface %sClientOptions {", serviceName)
	p("  fetch?: typeof fetch;")
	p("  defaultHeaders?: Record<string, string>;")

	// Add typed properties for service-level headers
	serviceHeaders := getServiceHeaders(service)
	for _, header := range serviceHeaders {
		propName := headerNameToPropertyName(header.GetName())
		p("  %s?: string;", propName)
	}

	p("}")
	p("")
}

// generateCallOptionsInterface generates the {Service}CallOptions interface.
func (g *Generator) generateCallOptionsInterface(p printer, service *protogen.Service) {
	serviceName := service.GoName

	p("export interface %sCallOptions {", serviceName)
	p("  headers?: Record<string, string>;")
	p("  signal?: AbortSignal;")

	// Add typed properties for service-level headers (also available per-call)
	serviceHeaders := getServiceHeaders(service)
	for _, header := range serviceHeaders {
		propName := headerNameToPropertyName(header.GetName())
		p("  %s?: string;", propName)
	}

	// Add typed properties for method-level headers
	seen := make(map[string]bool)
	for _, method := range service.Methods {
		methodHeaders := getMethodHeaders(method)
		for _, header := range methodHeaders {
			propName := headerNameToPropertyName(header.GetName())
			if seen[propName] {
				continue
			}
			seen[propName] = true
			p("  %s?: string;", propName)
		}
	}

	p("}")
	p("")
}

// generateClientClass generates the client class with constructor and methods.
func (g *Generator) generateClientClass(p printer, service *protogen.Service) {
	serviceName := service.GoName

	p("export class %sClient {", serviceName)

	// Private fields
	p("  private baseURL: string;")
	p("  private fetchFn: typeof fetch;")
	p("  private defaultHeaders: Record<string, string>;")
	p("")

	// Constructor
	g.generateConstructor(p, service)

	// RPC methods
	for _, method := range service.Methods {
		g.generateRPCMethod(p, service, method)
	}

	// Error handler
	g.generateHandleError(p)

	p("}")
	p("")
}

// generateConstructor generates the client constructor.
func (g *Generator) generateConstructor(p printer, service *protogen.Service) {
	serviceName := service.GoName

	p("  constructor(baseURL: string, options?: %sClientOptions) {", serviceName)
	p(`    this.baseURL = baseURL.replace(/\/+$/, "");`)
	p("    this.fetchFn = options?.fetch ?? globalThis.fetch;")
	p("    this.defaultHeaders = { ...options?.defaultHeaders };")

	// Apply service-level headers from options
	serviceHeaders := getServiceHeaders(service)
	for _, header := range serviceHeaders {
		propName := headerNameToPropertyName(header.GetName())
		headerName := header.GetName()
		p("    if (options?.%s) {", propName)
		p(`      this.defaultHeaders["%s"] = options.%s;`, headerName, propName)
		p("    }")
	}

	p("  }")
	p("")
}

// rpcMethodConfig holds the configuration for generating an RPC method.
type rpcMethodConfig struct {
	serviceName string
	methodName  string
	httpMethod  string
	fullPath    string
	pathParams  []string
	queryParams []QueryParam
	hasBody     bool
}

func (g *Generator) buildRPCMethodConfig(service *protogen.Service, method *protogen.Method) *rpcMethodConfig {
	serviceName := service.GoName
	methodName := method.GoName

	httpConfig := getMethodHTTPConfig(method)
	httpMethod := http.MethodPost
	httpPath := "/" + lowerFirst(methodName)
	var pathParams []string

	if httpConfig != nil {
		if httpConfig.Method != "" {
			httpMethod = httpConfig.Method
		}
		if httpConfig.Path != "" {
			httpPath = httpConfig.Path
		}
		pathParams = httpConfig.PathParams
	}

	serviceConfig := getServiceHTTPConfig(service)
	basePath := ""
	if serviceConfig != nil {
		basePath = serviceConfig.BasePath
	}

	fullPath := httpPath
	if basePath != "" {
		basePath = strings.TrimSuffix(basePath, "/")
		if !strings.HasPrefix(httpPath, "/") {
			httpPath = "/" + httpPath
		}
		fullPath = basePath + httpPath
	}

	return &rpcMethodConfig{
		serviceName: serviceName,
		methodName:  methodName,
		httpMethod:  httpMethod,
		fullPath:    fullPath,
		pathParams:  pathParams,
		queryParams: getQueryParams(method.Input),
		hasBody:     httpMethod == "POST" || httpMethod == "PUT" || httpMethod == "PATCH",
	}
}

// generateRPCMethod generates a single async RPC method.
func (g *Generator) generateRPCMethod(p printer, service *protogen.Service, method *protogen.Method) {
	cfg := g.buildRPCMethodConfig(service, method)

	inputType := string(method.Input.Desc.Name())
	outputType := g.resolveOutputType(method)

	tsMethodName := lowerFirst(cfg.methodName)

	p("  async %s(req: %s, options?: %sCallOptions): Promise<%s> {",
		tsMethodName, inputType, cfg.serviceName, outputType)

	// Build URL with path params
	g.generateURLBuilding(p, cfg)

	// Build headers
	g.generateHeaderMerging(p, service, method)

	// Build fetch options
	g.generateFetchCall(p, cfg)

	// Handle response
	g.generateResponseHandling(p, method)

	p("  }")
	p("")
}

// resolveOutputType returns the TypeScript return type, handling root unwrap.
func (g *Generator) resolveOutputType(method *protogen.Method) string {
	msg := method.Output
	if isRootUnwrap(msg) {
		return rootUnwrapTSType(msg)
	}
	return string(msg.Desc.Name())
}

// generateURLBuilding generates URL construction with path and query params.
func (g *Generator) generateURLBuilding(p printer, cfg *rpcMethodConfig) {
	p(`    let path = "%s";`, cfg.fullPath)

	// Path parameter substitution
	for _, param := range cfg.pathParams {
		jsonName := snakeToLowerCamel(param)
		p(`    path = path.replace("{%s}", encodeURIComponent(String(req.%s)));`, param, jsonName)
	}

	// Query parameters
	if (cfg.httpMethod == "GET" || cfg.httpMethod == "DELETE") && len(cfg.queryParams) > 0 {
		p("    const params = new URLSearchParams();")
		for _, qp := range cfg.queryParams {
			check := tsZeroCheck(qp.FieldKind)
			if check == "" {
				// bool: only add if true
				p("    if (req.%s) params.set(\"%s\", String(req.%s));",
					qp.FieldJSONName, qp.ParamName, qp.FieldJSONName)
			} else {
				p("    if (req.%s%s) params.set(\"%s\", String(req.%s));",
					qp.FieldJSONName, check, qp.ParamName, qp.FieldJSONName)
			}
		}
		p(`    const url = this.baseURL + path + (params.toString() ? "?" + params.toString() : "");`)
	} else {
		p("    const url = this.baseURL + path;")
	}

	p("")
}

// generateHeaderMerging generates header construction from defaults + options.
func (g *Generator) generateHeaderMerging(p printer, service *protogen.Service, method *protogen.Method) {
	p("    const headers: Record<string, string> = {")
	p(`      "Content-Type": "application/json",`)
	p("      ...this.defaultHeaders,")
	p("      ...options?.headers,")
	p("    };")

	// Apply service-level headers from call options
	serviceHeaders := getServiceHeaders(service)
	for _, header := range serviceHeaders {
		propName := headerNameToPropertyName(header.GetName())
		headerName := header.GetName()
		p("    if (options?.%s) headers[\"%s\"] = options.%s;", propName, headerName, propName)
	}

	// Apply method-level headers from call options
	methodHeaders := getMethodHeaders(method)
	for _, header := range methodHeaders {
		propName := headerNameToPropertyName(header.GetName())
		headerName := header.GetName()
		p("    if (options?.%s) headers[\"%s\"] = options.%s;", propName, headerName, propName)
	}

	p("")
}

// generateFetchCall generates the fetch invocation.
func (g *Generator) generateFetchCall(p printer, cfg *rpcMethodConfig) {
	if cfg.hasBody {
		p("    const resp = await this.fetchFn(url, {")
		p(`      method: "%s",`, cfg.httpMethod)
		p("      headers,")
		p("      body: JSON.stringify(req),")
		p("      signal: options?.signal,")
		p("    });")
	} else {
		p("    const resp = await this.fetchFn(url, {")
		p(`      method: "%s",`, cfg.httpMethod)
		p("      headers,")
		p("      signal: options?.signal,")
		p("    });")
	}
	p("")
}

// generateResponseHandling generates response parsing and error handling.
func (g *Generator) generateResponseHandling(p printer, method *protogen.Method) {
	outputType := g.resolveOutputType(method)

	p("    if (!resp.ok) {")
	p("      return this.handleError(resp);")
	p("    }")
	p("")
	p("    return await resp.json() as %s;", outputType)
}

// generateHandleError generates the private error handler method.
func (g *Generator) generateHandleError(p printer) {
	p("  private async handleError(resp: Response): Promise<never> {")
	p("    const body = await resp.text();")
	p("    if (resp.status === 400) {")
	p("      try {")
	p("        const parsed = JSON.parse(body);")
	p("        if (parsed.violations) {")
	p("          throw new ValidationError(parsed.violations);")
	p("        }")
	p("      } catch (e) {")
	p("        if (e instanceof ValidationError) throw e;")
	p("      }")
	p("    }")
	p("    throw new ApiError(resp.status, `Request failed with status ${resp.status}`, body);")
	p("  }")
}
