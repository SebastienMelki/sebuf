// Code generated by protoc-gen-go-http. DO NOT EDIT.
// source: oneof_discriminator.proto

package oneofdiscriminator

import (
	"encoding/json"
	"fmt"

	"google.golang.org/protobuf/encoding/protojson"
)

// MarshalJSON implements json.Marshaler for FlattenedEvent.
// This method handles oneof discriminator fields: content
func (x *FlattenedEvent) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}

	// Use protojson for base serialization
	data, err := protojson.Marshal(x)
	if err != nil {
		return nil, err
	}

	// Parse into a map to add discriminator fields
	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return nil, err
	}

	// Handle oneof content with discriminator "type"
	switch x.GetContent().(type) {
	case *FlattenedEvent_Text:
		raw["type"], _ = json.Marshal("text")
		// Flatten: marshal variant via json.Marshal to invoke child MarshalJSON
		if inner := x.GetText(); inner != nil {
			variantData, varErr := json.Marshal(inner)
			if varErr == nil {
				var variantMap map[string]json.RawMessage
				if json.Unmarshal(variantData, &variantMap) == nil {
					// Merge variant fields into parent
					for fk, fv := range variantMap {
						raw[fk] = fv
					}
				}
			}
			delete(raw, "text")
		}
	case *FlattenedEvent_Image:
		raw["type"], _ = json.Marshal("img")
		// Flatten: marshal variant via json.Marshal to invoke child MarshalJSON
		if inner := x.GetImage(); inner != nil {
			variantData, varErr := json.Marshal(inner)
			if varErr == nil {
				var variantMap map[string]json.RawMessage
				if json.Unmarshal(variantData, &variantMap) == nil {
					// Merge variant fields into parent
					for fk, fv := range variantMap {
						raw[fk] = fv
					}
				}
			}
			delete(raw, "image")
		}
	default:
		// Oneof not set: omit discriminator entirely
	}

	return json.Marshal(raw)
}

// UnmarshalJSON implements json.Unmarshaler for FlattenedEvent.
// This method handles oneof discriminator fields: content
func (x *FlattenedEvent) UnmarshalJSON(data []byte) error {
	// Parse into a map to read discriminator fields
	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}

	// Read discriminator for oneof content
	if discRaw, ok := raw["type"]; ok {
		var disc string
		if err := json.Unmarshal(discRaw, &disc); err != nil {
			return fmt.Errorf("invalid discriminator %q: %%w", "type", err)
		}

		switch disc {
		case "text":
			// Flatten unmarshal: extract Text fields from flat map
			variantMap := make(map[string]json.RawMessage)
			if fv, exists := raw["body"]; exists {
				variantMap["body"] = fv
				delete(raw, "body")
			}
			variantData, _ := json.Marshal(variantMap)
			variant := &TextContent{}
			if err := json.Unmarshal(variantData, variant); err != nil {
				return fmt.Errorf("failed to unmarshal variant %s: %%w", "Text", err)
			}
			x.Content = &FlattenedEvent_Text{Text: variant}
			raw["text"], _ = json.Marshal(variant)
		case "img":
			// Flatten unmarshal: extract Image fields from flat map
			variantMap := make(map[string]json.RawMessage)
			if fv, exists := raw["url"]; exists {
				variantMap["url"] = fv
				delete(raw, "url")
			}
			if fv, exists := raw["width"]; exists {
				variantMap["width"] = fv
				delete(raw, "width")
			}
			if fv, exists := raw["height"]; exists {
				variantMap["height"] = fv
				delete(raw, "height")
			}
			variantData, _ := json.Marshal(variantMap)
			variant := &ImageContent{}
			if err := json.Unmarshal(variantData, variant); err != nil {
				return fmt.Errorf("failed to unmarshal variant %s: %%w", "Image", err)
			}
			x.Content = &FlattenedEvent_Image{Image: variant}
			raw["image"], _ = json.Marshal(variant)
		}
	}

	// Remove discriminator fields before protojson unmarshal
	delete(raw, "type")

	// Re-marshal remaining fields for protojson
	modified, err := json.Marshal(raw)
	if err != nil {
		return err
	}

	return protojson.Unmarshal(modified, x)
}

// MarshalJSON implements json.Marshaler for NestedEvent.
// This method handles oneof discriminator fields: content
func (x *NestedEvent) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}

	// Use protojson for base serialization
	data, err := protojson.Marshal(x)
	if err != nil {
		return nil, err
	}

	// Parse into a map to add discriminator fields
	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return nil, err
	}

	// Handle oneof content with discriminator "kind"
	switch x.GetContent().(type) {
	case *NestedEvent_Text:
		raw["kind"], _ = json.Marshal("text")
	case *NestedEvent_Image:
		raw["kind"], _ = json.Marshal("image")
	case *NestedEvent_Video:
		raw["kind"], _ = json.Marshal("vid")
	default:
		// Oneof not set: omit discriminator entirely
	}

	return json.Marshal(raw)
}

// UnmarshalJSON implements json.Unmarshaler for NestedEvent.
// This method handles oneof discriminator fields: content
func (x *NestedEvent) UnmarshalJSON(data []byte) error {
	// Parse into a map to read discriminator fields
	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}

	// Read discriminator for oneof content
	if discRaw, ok := raw["kind"]; ok {
		var disc string
		if err := json.Unmarshal(discRaw, &disc); err != nil {
			return fmt.Errorf("invalid discriminator %q: %%w", "kind", err)
		}

		switch disc {
		case "text":
			// Non-flattened unmarshal: use json.Unmarshal for child UnmarshalJSON support
			if variantRaw, exists := raw["text"]; exists {
				variant := &TextContent{}
				if err := json.Unmarshal(variantRaw, variant); err != nil {
					return fmt.Errorf("failed to unmarshal variant %s: %%w", "Text", err)
				}
				x.Content = &NestedEvent_Text{Text: variant}
			}
		case "image":
			// Non-flattened unmarshal: use json.Unmarshal for child UnmarshalJSON support
			if variantRaw, exists := raw["image"]; exists {
				variant := &ImageContent{}
				if err := json.Unmarshal(variantRaw, variant); err != nil {
					return fmt.Errorf("failed to unmarshal variant %s: %%w", "Image", err)
				}
				x.Content = &NestedEvent_Image{Image: variant}
			}
		case "vid":
			// Non-flattened unmarshal: use json.Unmarshal for child UnmarshalJSON support
			if variantRaw, exists := raw["video"]; exists {
				variant := &VideoContent{}
				if err := json.Unmarshal(variantRaw, variant); err != nil {
					return fmt.Errorf("failed to unmarshal variant %s: %%w", "Video", err)
				}
				x.Content = &NestedEvent_Video{Video: variant}
			}
		}
	}

	// Remove discriminator fields before protojson unmarshal
	delete(raw, "kind")

	// Re-marshal remaining fields for protojson
	modified, err := json.Marshal(raw)
	if err != nil {
		return err
	}

	return protojson.Unmarshal(modified, x)
}
