// Code generated by protoc-gen-go-http. DO NOT EDIT.
// source: query_params.proto

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"strings"
	"sync"
	"time"
	"unicode/utf8"

	protovalidate "buf.build/go/protovalidate"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"

	sebufhttp "github.com/SebastienMelki/sebuf/http"
)

const (
	// JSONContentType is the content type for JSON
	JSONContentType = "application/json"
	// BinaryContentType is the content type for binary protobuf
	BinaryContentType = "application/octet-stream"
	// ProtoContentType is the content type for protobuf
	ProtoContentType = "application/x-protobuf"
)

type bodyCtxKey struct{}

func getRequest[Req any](ctx context.Context) Req {
	val := ctx.Value(bodyCtxKey{})
	request, ok := val.(Req)
	if ok {
		return request
	}
	return *new(Req)
}

// BindingMiddleware creates a middleware that binds HTTP requests to protobuf messages
// and validates them using protovalidate and header validation
func BindingMiddleware[Req any](next http.Handler, serviceHeaders, methodHeaders []*sebufhttp.Header) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Validate headers first
		if validationErr := validateHeaders(r, serviceHeaders, methodHeaders); validationErr != nil {
			writeValidationErrorResponse(w, r, validationErr)
			return
		}

		toBind := new(Req)

		err := bindDataBasedOnContentType(r, toBind)
		if err != nil {
			// For binding errors, return a simple validation error
			validationErr := &sebufhttp.ValidationError{
				Violations: []*sebufhttp.FieldViolation{
					{
						Field:       "body",
						Description: fmt.Sprintf("failed to parse request body: %v", err),
					},
				},
			}
			writeValidationErrorResponse(w, r, validationErr)
			return
		}

		// Validate the message if it's a proto.Message
		if msg, ok := any(toBind).(proto.Message); ok {
			if err := ValidateMessage(msg); err != nil {
				writeValidationError(w, r, err)
				return
			}
		}

		ctx := context.WithValue(r.Context(), bodyCtxKey{}, toBind)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

func filterFlags(content string) string {
	for i, char := range content {
		if char == ' ' || char == ';' {
			return content[:i]
		}
	}
	return content
}

func bindDataBasedOnContentType[Req any](r *http.Request, toBind *Req) error {
	contentType := filterFlags(r.Header.Get("Content-Type"))
	switch contentType {
	case JSONContentType:
		return bindDataFromJSONRequest(r, toBind)
	case BinaryContentType, ProtoContentType:
		return bindDataFromBinaryRequest(r, toBind)
	default:
		return bindDataFromBinaryRequest(r, toBind)
	}
}

func bindDataFromJSONRequest[Req any](r *http.Request, toBind *Req) error {
	bodyBytes, err := io.ReadAll(r.Body)
	r.Body = io.NopCloser(bytes.NewReader(bodyBytes))
	if err != nil {
		return fmt.Errorf("could not read request body: %w", err)
	}

	if len(bodyBytes) == 0 {
		return nil
	}

	protoRequest, ok := any(toBind).(proto.Message)
	if !ok {
		return errors.New("JSON request is not a protocol buffer message")
	}

	err = protojson.Unmarshal(bodyBytes, protoRequest)
	if err != nil {
		return fmt.Errorf("could not unmarshal request JSON: %w", err)
	}
	return nil
}

func bindDataFromBinaryRequest[Req any](r *http.Request, toBind *Req) error {
	bodyBytes, err := io.ReadAll(r.Body)
	r.Body = io.NopCloser(bytes.NewReader(bodyBytes))

	if len(bodyBytes) == 0 {
		return nil
	}

	if err != nil && !errors.Is(err, io.ErrUnexpectedEOF) {
		return fmt.Errorf("could not read request body: %w", err)
	}

	protoRequest, ok := any(toBind).(proto.Message)
	if !ok {
		return errors.New("binary request is not a protocol buffer message")
	}

	err = proto.Unmarshal(bodyBytes, protoRequest)
	if err != nil {
		return fmt.Errorf("could not unmarshal binary request: %w", err)
	}
	return nil
}

func genericHandler[Req any, Res any](serve func(context.Context, Req) (Res, error)) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		request := getRequest[Req](r.Context())

		response, err := serve(r.Context(), request)
		if err != nil {
			errorMsg := &sebufhttp.Error{
				Message: err.Error(),
			}
			writeErrorResponse(w, r, errorMsg)
			return
		}

		responseBytes, err := marshalResponse(r, response)
		if err != nil {
			errorMsg := &sebufhttp.Error{
				Message: fmt.Sprintf("failed to marshal response: %v", err),
			}
			writeErrorResponse(w, r, errorMsg)
			return
		}

		_, err = w.Write(responseBytes)
		if err != nil {
			errorMsg := &sebufhttp.Error{
				Message: fmt.Sprintf("failed to write response: %v", err),
			}
			writeErrorResponse(w, r, errorMsg)
			return
		}
	}
}

func marshalResponse(r *http.Request, response any) ([]byte, error) {
	contentType := r.Header.Get("Content-Type")
	if contentType == "" {
		contentType = JSONContentType
	}

	msg, ok := response.(proto.Message)
	if !ok {
		return nil, fmt.Errorf("response is not a protocol buffer message")
	}

	switch filterFlags(contentType) {
	case JSONContentType:
		return protojson.Marshal(msg)
	case BinaryContentType, ProtoContentType:
		return proto.Marshal(msg)
	default:
		return nil, fmt.Errorf("unsupported content type: %s", contentType)
	}
}

// writeProtoMessageResponse writes a protobuf message as an HTTP response
func writeProtoMessageResponse(w http.ResponseWriter, r *http.Request, msg proto.Message, statusCode int, fallbackMsg string) {
	contentType := r.Header.Get("Content-Type")
	if contentType == "" {
		contentType = JSONContentType
	}

	var responseBytes []byte
	var err error

	switch filterFlags(contentType) {
	case JSONContentType:
		responseBytes, err = protojson.Marshal(msg)
	case BinaryContentType, ProtoContentType:
		responseBytes, err = proto.Marshal(msg)
	default:
		// Default to JSON for error responses
		responseBytes, err = protojson.Marshal(msg)
	}

	if err != nil {
		// Fallback to plain text error if marshaling fails
		http.Error(w, fallbackMsg, statusCode)
		return
	}

	w.WriteHeader(statusCode)
	_, _ = w.Write(responseBytes)
}

// writeValidationErrorResponse writes a ValidationError as a response
func writeValidationErrorResponse(w http.ResponseWriter, r *http.Request, validationErr *sebufhttp.ValidationError) {
	writeProtoMessageResponse(w, r, validationErr, http.StatusBadRequest, "validation failed")
}

// writeValidationError converts a protovalidate error to ValidationError and writes it as response
func writeValidationError(w http.ResponseWriter, r *http.Request, err error) {
	validationErr := &sebufhttp.ValidationError{}

	// Handle protovalidate.ValidationError
	var valErr *protovalidate.ValidationError
	if errors.As(err, &valErr) {
		for _, violation := range valErr.Violations {
			// Extract field path from violation
			fieldPath := ""
			if violation.Proto != nil && violation.Proto.GetField() != nil {
				elements := violation.Proto.GetField().GetElements()
				if len(elements) > 0 {
					fieldPath = elements[0].GetFieldName()
					for i := 1; i < len(elements); i++ {
						fieldPath += "." + elements[i].GetFieldName()
					}
				}
			}
			if fieldPath == "" {
				fieldPath = "unknown"
			}

			validationErr.Violations = append(validationErr.Violations, &sebufhttp.FieldViolation{
				Field:       fieldPath,
				Description: violation.Proto.GetMessage(),
			})
		}
	} else {
		// Shouldn't happen, but handle as generic error
		validationErr.Violations = append(validationErr.Violations, &sebufhttp.FieldViolation{
			Field:       "unknown",
			Description: err.Error(),
		})
	}

	writeValidationErrorResponse(w, r, validationErr)
}

// writeErrorResponse writes an Error as a response
func writeErrorResponse(w http.ResponseWriter, r *http.Request, errorMsg *sebufhttp.Error) {
	writeProtoMessageResponse(w, r, errorMsg, http.StatusInternalServerError, "internal server error")
}

var (
	// Global validator instance - created once and reused
	validatorOnce sync.Once
	validator     protovalidate.Validator
	validatorErr  error
)

// getValidator returns a cached validator instance
func getValidator() (protovalidate.Validator, error) {
	validatorOnce.Do(func() {
		validator, validatorErr = protovalidate.New()
	})
	return validator, validatorErr
}

// ValidateMessage validates a protobuf message using protovalidate
func ValidateMessage(msg proto.Message) error {
	// Get cached validator
	v, err := getValidator()
	if err != nil {
		// If we can't create a validator, log and continue
		// This allows the service to run even if validation setup fails
		return nil
	}

	// Validate the message and return any error
	return v.Validate(msg)
}

// validateHeaders validates required headers for a service and method
// Returns a ValidationError if any required headers are missing or invalid
func validateHeaders(r *http.Request, serviceHeaders, methodHeaders []*sebufhttp.Header) *sebufhttp.ValidationError {
	// Merge service and method headers, with method headers taking precedence
	allHeaders := make(map[string]*sebufhttp.Header)

	// Add service headers first
	for _, header := range serviceHeaders {
		if header.GetRequired() {
			allHeaders[strings.ToLower(header.GetName())] = header
		}
	}

	// Add method headers (override service headers if same name)
	for _, header := range methodHeaders {
		if header.GetRequired() {
			allHeaders[strings.ToLower(header.GetName())] = header
		}
	}

	// Collect all validation violations
	var violations []*sebufhttp.FieldViolation

	// Validate each required header
	for _, headerSpec := range allHeaders {
		value := r.Header.Get(headerSpec.GetName())
		if value == "" {
			violations = append(violations, &sebufhttp.FieldViolation{
				Field:       headerSpec.GetName(),
				Description: fmt.Sprintf("required header '%s' is missing", headerSpec.GetName()),
			})
			continue
		}

		if err := validateHeaderValue(headerSpec, value); err != nil {
			violations = append(violations, &sebufhttp.FieldViolation{
				Field:       headerSpec.GetName(),
				Description: fmt.Sprintf("header '%s' validation failed: %v", headerSpec.GetName(), err),
			})
		}
	}

	// Return ValidationError if there are violations
	if len(violations) > 0 {
		return &sebufhttp.ValidationError{
			Violations: violations,
		}
	}

	return nil
}

// validateHeaderValue validates a single header value against its specification
func validateHeaderValue(headerSpec *sebufhttp.Header, value string) error {
	headerType := headerSpec.GetType()
	format := headerSpec.GetFormat()

	// Validate based on type
	switch headerType {
	case "string":
		return validateStringHeader(value, format)
	case "integer":
		return validateIntegerHeader(value)
	case "number":
		return validateNumberHeader(value)
	case "boolean":
		return validateBooleanHeader(value)
	case "array":
		return validateArrayHeader(value)
	default:
		// Default to string validation if type is not specified
		return validateStringHeader(value, format)
	}
}

// validateStringHeader validates string headers with optional format validation
func validateStringHeader(value, format string) error {
	if !utf8.ValidString(value) {
		return fmt.Errorf("value is not valid UTF-8")
	}

	// Apply format-specific validation
	switch format {
	case "uuid":
		return validateUUIDFormat(value)
	case "email":
		return validateEmailFormat(value)
	case "date-time":
		return validateDateTimeFormat(value)
	case "date":
		return validateDateFormat(value)
	case "time":
		return validateTimeFormat(value)
	}

	return nil
}

// validateIntegerHeader validates integer headers
func validateIntegerHeader(value string) error {
	_, err := strconv.ParseInt(value, 10, 64)
	if err != nil {
		return fmt.Errorf("value is not a valid integer: %w", err)
	}
	return nil
}

// validateNumberHeader validates numeric headers (float)
func validateNumberHeader(value string) error {
	_, err := strconv.ParseFloat(value, 64)
	if err != nil {
		return fmt.Errorf("value is not a valid number: %w", err)
	}
	return nil
}

// validateBooleanHeader validates boolean headers
func validateBooleanHeader(value string) error {
	_, err := strconv.ParseBool(value)
	if err != nil {
		return fmt.Errorf("value is not a valid boolean: %w", err)
	}
	return nil
}

// validateArrayHeader validates array headers (comma-separated values)
func validateArrayHeader(value string) error {
	// Arrays are typically comma-separated values
	// Basic validation: ensure it's not empty
	if strings.TrimSpace(value) == "" {
		return fmt.Errorf("array value cannot be empty")
	}
	return nil
}

// validateUUIDFormat validates UUID format (basic check)
func validateUUIDFormat(value string) error {
	// Basic UUID format check: 8-4-4-4-12 hex digits
	if len(value) != 36 {
		return fmt.Errorf("UUID must be 36 characters long")
	}

	// Check for correct dash positions
	if value[8] != '-' || value[13] != '-' || value[18] != '-' || value[23] != '-' {
		return fmt.Errorf("invalid UUID format")
	}

	return nil
}

// validateEmailFormat validates email format (basic check)
func validateEmailFormat(value string) error {
	// Basic email format check
	if !strings.Contains(value, "@") {
		return fmt.Errorf("invalid email format: missing @")
	}

	parts := strings.Split(value, "@")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		return fmt.Errorf("invalid email format")
	}

	return nil
}

// validateDateTimeFormat validates RFC3339 date-time format
func validateDateTimeFormat(value string) error {
	_, err := time.Parse(time.RFC3339, value)
	if err != nil {
		return fmt.Errorf("invalid date-time format, expected RFC3339: %w", err)
	}
	return nil
}

// validateDateFormat validates date format (YYYY-MM-DD)
func validateDateFormat(value string) error {
	_, err := time.Parse("2006-01-02", value)
	if err != nil {
		return fmt.Errorf("invalid date format, expected YYYY-MM-DD: %w", err)
	}
	return nil
}

// validateTimeFormat validates time format (HH:MM:SS)
func validateTimeFormat(value string) error {
	_, err := time.Parse("15:04:05", value)
	if err != nil {
		return fmt.Errorf("invalid time format, expected HH:MM:SS: %w", err)
	}
	return nil
}
