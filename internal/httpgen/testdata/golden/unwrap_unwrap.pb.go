// Code generated by protoc-gen-go-http. DO NOT EDIT.
// source: unwrap.proto

package generated

import (
	"encoding/json"

	"google.golang.org/protobuf/encoding/protojson"
)

// MarshalJSON implements json.Marshaler for GetOptionBarsResponse.
// This method handles unwrap field serialization for map values.
func (x *GetOptionBarsResponse) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}

	out := make(map[string]json.RawMessage)

	// Handle unwrap map field: Bars
	if x.Bars != nil {
		mapData := make(map[string]json.RawMessage)
		for k, wrapper := range x.Bars {
			if wrapper != nil {
				// Marshal the unwrap field directly (the array)
				items := make([]json.RawMessage, 0, len(wrapper.GetBars()))
				for _, item := range wrapper.GetBars() {
					data, err := protojson.Marshal(item)
					if err != nil {
						return nil, err
					}
					items = append(items, data)
				}
				arrayData, err := json.Marshal(items)
				if err != nil {
					return nil, err
				}
				mapData[k] = arrayData
			}
		}
		data, err := json.Marshal(mapData)
		if err != nil {
			return nil, err
		}
		out["bars"] = data
	}

	// Handle scalar field: NextPageToken
	if x.NextPageToken != "" {
		data, err := json.Marshal(x.NextPageToken)
		if err != nil {
			return nil, err
		}
		out["nextPageToken"] = data
	}

	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler for GetOptionBarsResponse.
// This method handles unwrap field deserialization for map values.
func (x *GetOptionBarsResponse) UnmarshalJSON(data []byte) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}

	// Handle unwrap map field: Bars
	if rawField, ok := raw["bars"]; ok {
		var mapRaw map[string]json.RawMessage
		if err := json.Unmarshal(rawField, &mapRaw); err != nil {
			return err
		}
		x.Bars = make(map[string]*OptionBarsList)
		for k, arrayRaw := range mapRaw {
			var itemsRaw []json.RawMessage
			if err := json.Unmarshal(arrayRaw, &itemsRaw); err != nil {
				return err
			}
			items := make([]*OptionBar, 0, len(itemsRaw))
			for _, itemRaw := range itemsRaw {
				item := &OptionBar{}
				if err := protojson.Unmarshal(itemRaw, item); err != nil {
					return err
				}
				items = append(items, item)
			}
			x.Bars[k] = &OptionBarsList{Bars: items}
		}
	}

	// Handle field: NextPageToken
	if rawField, ok := raw["nextPageToken"]; ok {
		if err := json.Unmarshal(rawField, &x.NextPageToken); err != nil {
			return err
		}
	}

	return nil
}

// MarshalJSON implements json.Marshaler for ScalarMapResponse.
// This method handles unwrap field serialization for map values.
func (x *ScalarMapResponse) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}

	out := make(map[string]json.RawMessage)

	// Handle unwrap map field: Data
	if x.Data != nil {
		mapData := make(map[string]json.RawMessage)
		for k, wrapper := range x.Data {
			if wrapper != nil {
				// Marshal the unwrap field directly (the array of scalars)
				arrayData, err := json.Marshal(wrapper.GetValues())
				if err != nil {
					return nil, err
				}
				mapData[k] = arrayData
			}
		}
		data, err := json.Marshal(mapData)
		if err != nil {
			return nil, err
		}
		out["data"] = data
	}

	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler for ScalarMapResponse.
// This method handles unwrap field deserialization for map values.
func (x *ScalarMapResponse) UnmarshalJSON(data []byte) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}

	// Handle unwrap map field: Data
	if rawField, ok := raw["data"]; ok {
		var mapRaw map[string]json.RawMessage
		if err := json.Unmarshal(rawField, &mapRaw); err != nil {
			return err
		}
		x.Data = make(map[string]*IntList)
		for k, arrayRaw := range mapRaw {
			var itemsRaw []json.RawMessage
			if err := json.Unmarshal(arrayRaw, &itemsRaw); err != nil {
				return err
			}
			var items []int32
			if err := json.Unmarshal(arrayRaw, &items); err != nil {
				return err
			}
			x.Data[k] = &IntList{Values: items}
		}
	}

	return nil
}

// MarshalJSON implements json.Marshaler for MixedResponse.
// This method handles unwrap field serialization for map values.
func (x *MixedResponse) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}

	out := make(map[string]json.RawMessage)

	// Handle unwrap map field: UnwrappedBars
	if x.UnwrappedBars != nil {
		mapData := make(map[string]json.RawMessage)
		for k, wrapper := range x.UnwrappedBars {
			if wrapper != nil {
				// Marshal the unwrap field directly (the array)
				items := make([]json.RawMessage, 0, len(wrapper.GetBars()))
				for _, item := range wrapper.GetBars() {
					data, err := protojson.Marshal(item)
					if err != nil {
						return nil, err
					}
					items = append(items, data)
				}
				arrayData, err := json.Marshal(items)
				if err != nil {
					return nil, err
				}
				mapData[k] = arrayData
			}
		}
		data, err := json.Marshal(mapData)
		if err != nil {
			return nil, err
		}
		out["unwrappedBars"] = data
	}

	// Handle regular map field: RegularBars
	if len(x.RegularBars) > 0 {
		data, err := json.Marshal(x.RegularBars)
		if err != nil {
			return nil, err
		}
		out["regularBars"] = data
	}

	// Handle scalar field: Status
	if x.Status != "" {
		data, err := json.Marshal(x.Status)
		if err != nil {
			return nil, err
		}
		out["status"] = data
	}

	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler for MixedResponse.
// This method handles unwrap field deserialization for map values.
func (x *MixedResponse) UnmarshalJSON(data []byte) error {
	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}

	// Handle unwrap map field: UnwrappedBars
	if rawField, ok := raw["unwrappedBars"]; ok {
		var mapRaw map[string]json.RawMessage
		if err := json.Unmarshal(rawField, &mapRaw); err != nil {
			return err
		}
		x.UnwrappedBars = make(map[string]*OptionBarsList)
		for k, arrayRaw := range mapRaw {
			var itemsRaw []json.RawMessage
			if err := json.Unmarshal(arrayRaw, &itemsRaw); err != nil {
				return err
			}
			items := make([]*OptionBar, 0, len(itemsRaw))
			for _, itemRaw := range itemsRaw {
				item := &OptionBar{}
				if err := protojson.Unmarshal(itemRaw, item); err != nil {
					return err
				}
				items = append(items, item)
			}
			x.UnwrappedBars[k] = &OptionBarsList{Bars: items}
		}
	}

	// Handle regular map field: RegularBars
	if rawField, ok := raw["regularBars"]; ok {
		if err := json.Unmarshal(rawField, &x.RegularBars); err != nil {
			return err
		}
	}

	// Handle field: Status
	if rawField, ok := raw["status"]; ok {
		if err := json.Unmarshal(rawField, &x.Status); err != nil {
			return err
		}
	}

	return nil
}
