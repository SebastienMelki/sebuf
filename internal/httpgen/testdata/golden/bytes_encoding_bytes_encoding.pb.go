// Code generated by protoc-gen-go-http. DO NOT EDIT.
// source: bytes_encoding.proto

package bytesencoding

import (
	"encoding/base64"
	"encoding/hex"
	"encoding/json"

	"google.golang.org/protobuf/encoding/protojson"
)

// MarshalJSON implements json.Marshaler for BytesEncodingTest.
// This method handles bytes_encoding fields: base64_raw_data, base64url_data, base64url_raw_data, hex_data
func (x *BytesEncodingTest) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}

	// Use protojson for base serialization (handles all other fields correctly)
	data, err := protojson.Marshal(x)
	if err != nil {
		return nil, err
	}

	// Parse into a map to modify bytes-encoded fields
	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return nil, err
	}

	// Encode base64_raw_data with BYTES_ENCODING_BASE64_RAW
	if len(x.Base64RawData) > 0 {
		raw["base64RawData"], _ = json.Marshal(base64.RawStdEncoding.EncodeToString(x.Base64RawData))
	}

	// Encode base64url_data with BYTES_ENCODING_BASE64URL
	if len(x.Base64UrlData) > 0 {
		raw["base64urlData"], _ = json.Marshal(base64.URLEncoding.EncodeToString(x.Base64UrlData))
	}

	// Encode base64url_raw_data with BYTES_ENCODING_BASE64URL_RAW
	if len(x.Base64UrlRawData) > 0 {
		raw["base64urlRawData"], _ = json.Marshal(base64.RawURLEncoding.EncodeToString(x.Base64UrlRawData))
	}

	// Encode hex_data with BYTES_ENCODING_HEX
	if len(x.HexData) > 0 {
		raw["hexData"], _ = json.Marshal(hex.EncodeToString(x.HexData))
	}

	return json.Marshal(raw)
}

// UnmarshalJSON implements json.Unmarshaler for BytesEncodingTest.
// This method handles bytes_encoding fields: base64_raw_data, base64url_data, base64url_raw_data, hex_data
func (x *BytesEncodingTest) UnmarshalJSON(data []byte) error {
	// Parse the raw JSON to extract bytes-encoded fields
	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}

	// Decode base64_raw_data from BYTES_ENCODING_BASE64_RAW to standard base64
	if v, ok := raw["base64RawData"]; ok {
		var s string
		if err := json.Unmarshal(v, &s); err == nil {
			decoded, decErr := base64.RawStdEncoding.DecodeString(s)
			if decErr == nil {
				raw["base64RawData"], _ = json.Marshal(base64.StdEncoding.EncodeToString(decoded))
			}
		}
	}

	// Decode base64url_data from BYTES_ENCODING_BASE64URL to standard base64
	if v, ok := raw["base64urlData"]; ok {
		var s string
		if err := json.Unmarshal(v, &s); err == nil {
			decoded, decErr := base64.URLEncoding.DecodeString(s)
			if decErr == nil {
				raw["base64urlData"], _ = json.Marshal(base64.StdEncoding.EncodeToString(decoded))
			}
		}
	}

	// Decode base64url_raw_data from BYTES_ENCODING_BASE64URL_RAW to standard base64
	if v, ok := raw["base64urlRawData"]; ok {
		var s string
		if err := json.Unmarshal(v, &s); err == nil {
			decoded, decErr := base64.RawURLEncoding.DecodeString(s)
			if decErr == nil {
				raw["base64urlRawData"], _ = json.Marshal(base64.StdEncoding.EncodeToString(decoded))
			}
		}
	}

	// Decode hex_data from BYTES_ENCODING_HEX to standard base64
	if v, ok := raw["hexData"]; ok {
		var s string
		if err := json.Unmarshal(v, &s); err == nil {
			decoded, decErr := hex.DecodeString(s)
			if decErr == nil {
				raw["hexData"], _ = json.Marshal(base64.StdEncoding.EncodeToString(decoded))
			}
		}
	}

	// Re-marshal with standard base64 values for protojson
	modified, err := json.Marshal(raw)
	if err != nil {
		return err
	}

	// Use protojson to unmarshal the rest
	return protojson.Unmarshal(modified, x)
}
